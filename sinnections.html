<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connections</title>
    <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/hat-im/hat-im.github.io/main/connections-favicon.ico">
    <style>
        @font-face {
            font-family: 'Franklin';
            src: url('https://raw.githubusercontent.com/hat-im/hat-im.github.io/main/fonts/franklin-normal-700.ttf') format('truetype');
            font-weight: 700;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'Franklin';
            src: url('https://raw.githubusercontent.com/hat-im/hat-im.github.io/main/fonts/franklin-normal-500.ttf') format('truetype');
            font-weight: 500;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'Karnak';
            src: url('https://raw.githubusercontent.com/hat-im/hat-im.github.io/main/fonts/karnak-cond-normal.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'KarnakNormal';
            src: url('https://raw.githubusercontent.com/hat-im/hat-im.github.io/main/fonts/karnak-normal.woff') format('woff');
            font-weight: 400;
            font-style: normal;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Franklin', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 16px;
            font-weight: 500;
            background-color: #ffffff;
            color: #121212;
            line-height: 1.4;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: #ffffff;
            border-bottom: 1px solid #dfdfdf;
            padding: 20px 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header:nth-of-type(2) {
            z-index: 99;
        }
        
        .header.help-header {
            padding: 0;
            height: 48px;
            z-index: 98;
        }

        .header-content {
            max-width: 600px;
            margin: 0 auto;
            padding: 0 20px;
            text-align: center;
        }
        
        .help-bar {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            height: 48px;
            width: 100vw;
            margin-left: calc(-50vw + 50%);
        }
        
        .help-icon {
            width: 32px;
            height: 32px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s ease;
            margin-right: 20px;
        }
        
        .help-icon:hover {
            opacity: 0.7;
        }
        
        .help-icon svg {
            --text: #121212;
        }

        .main-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem 0;
        }

        .container {
            width: fit-content;
            padding: 0;
        }

        .title {
            font-family: 'Karnak', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 37px;
            font-weight: 400;
            color: #121212;
            margin: 0;
            letter-spacing: -0.5px;
            line-height: 1;
        }

        .subtitle {
            font-family: 'Franklin', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 16px;
            font-weight: 500;
            color: #363636;
            margin: 20px 0;
            line-height: 1.3;
            text-align: center;
        }

        .mistakes-section {
            text-align: center;
            margin: 20px 0;
        }

        .timer-section {
            font-family: 'Franklin', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            text-align: center;
            margin: 16px 0;
            color: #363636;
            font-size: 16px;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .timer-section.show {
            opacity: 1;
        }

        .mistakes {
            font-family: 'Franklin', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 16px;
            font-weight: 500;
            color: #121212;
            display: inline-flex;
            align-items: center;
        }

        .mistake-dots {
            display: inline-flex;
            gap: 6px;
            margin-left: 8px;
        }

        .mistake-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #5a594e;
            transition: opacity 0.3s ease;
            opacity: 1;
        }

        .mistake-dot.used {
            background-color: #dfdfdf;
            opacity: 0;
        }

        .word-grid {
            display: grid;
            grid-template-columns: repeat(4, 150px);
            gap: 8px;
            margin: 0 auto 24px auto;
            min-height: calc(4 * (80px + 8px));
            width: fit-content;
        }

        .word-tile {
            background-color: #efefe6;
            border: none;
            border-radius: 6px;
            padding: 0;
            text-align: center;
            font-weight: 700;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            user-select: none;
            width: 150px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            will-change: transform, background-color;
            backface-visibility: hidden;
            transform: translateZ(0);
            transition: all 0.15s ease;
            color: #121212;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .word-tile:hover {
            background-color: #e6e6dd;
            transform: scale(1.02);
        }

        .word-tile.selected {
            background-color: #5a594e;
            color: #ffffff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .word-tile.correct {
            background-color: #a0c35a;
            border-color: #a0c35a;
            color: #fff;
            cursor: default;
            animation: correctTile 0.5s ease-out;
        }

        @keyframes correctTile {
            0% {
                transform: scale(1);
            }
            35% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 24px;
        }

        .btn {
            font-family: 'Franklin', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            padding: 0 16px;
            border: 2px solid #000000;
            background-color: #ffffff;
            color: #000000;
            border-radius: 20px;
            font-weight: 500;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: capitalize;
            letter-spacing: 0.5px;
            height: 40px;
            min-width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn:hover {
            background-color: #000000;
            color: #ffffff;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: #ffffff;
            color: #000000;
        }

        .btn:disabled:hover {
            background-color: #ffffff;
            color: #000000;
        }

        .toast {
            font-family: 'Franklin', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            font-weight: 500;
            font-size: 16px;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            min-width: 200px;
            text-align: center;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        @keyframes incorrect-shake {
            0% { transform: translate3d(0, 0, 0); }
            25% { transform: translate3d(-5px, 0, 0); }
            50% { transform: translate3d(5px, 0, 0); }
            75% { transform: translate3d(-5px, 0, 0); }
            100% { transform: translate3d(0, 0, 0); }
        }

        .word-tile.incorrect-guess {
            animation: incorrect-shake 0.4s cubic-bezier(0.36, 0.07, 0.19, 0.97);
            will-change: transform;
        }

        @keyframes hop {
            0% { transform: translate3d(0, 0, 0); }
            50% { transform: translate3d(0, -8px, 0); }
            100% { transform: translate3d(0, 0, 0); }
        }

        .word-tile.hop {
            animation: hop 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            will-change: transform;
        }

        .word-tile.moving {
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            will-change: transform;
        }

        @keyframes subtle-shake-1 {
            0%, 100% { transform: translate3d(0, 0, 0); }
            25% { transform: translate3d(-1px, 0, 0); }
            75% { transform: translate3d(1px, 0, 0); }
        }

        @keyframes subtle-shake-2 {
            0%, 100% { transform: translate3d(0, 0, 0); }
            33% { transform: translate3d(0, -1px, 0); }
            66% { transform: translate3d(0, 1px, 0); }
        }

        @keyframes subtle-shake-3 {
            0%, 100% { transform: translate3d(0, 0, 0); }
            20% { transform: translate3d(-1px, 0, 0); }
            40% { transform: translate3d(1px, -1px, 0); }
            60% { transform: translate3d(0, 1px, 0); }
            80% { transform: translate3d(1px, 0, 0); }
        }

        @keyframes subtle-shake-4 {
            0%, 100% { transform: rotate3d(0, 0, 1, 0deg); }
            25% { transform: rotate3d(0, 0, 1, -0.5deg); }
            75% { transform: rotate3d(0, 0, 1, 0.5deg); }
        }

        .word-tile.victory-shake {
            animation: subtle-shake-1 2s ease-in-out infinite;
            cursor: pointer;
            position: relative;
        }

        .word-tile.victory-shake:hover {
            animation-duration: 1s;
            background-color: #e5e5dc;
            border-color: #d5d5cc;
        }

        .attempt-cell.victory-shake {
            cursor: pointer;
            position: relative;
        }

        .attempt-cell.victory-shake:hover {
            animation-duration: 1s !important;
            transform: scale(1.1);
            z-index: 10;
        }

        .attempts-grid {
            display: grid !important;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin: 20px auto;
            max-width: 200px;
            min-height: 50px;
            width: 200px;
            flex-shrink: 0;
        }

        .attempt-cell {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            border-radius: 4px;
            background-color: #ddd;
            opacity: 1;
            transform: scale(1);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }

        /* Override for colored cells */
        .attempts-grid .attempt-cell[data-bg-color] {
            background-color: attr(data-bg-color) !important;
        }
        
        .attempts-grid .attempt-cell[data-color="yellow"] {
            background-color: #f9df84 !important;
        }
        
        .attempts-grid .attempt-cell[data-color="green"] {
            background-color: #a0c35a !important;
        }
        
        .attempts-grid .attempt-cell[data-color="blue"] {
            background-color: #b0c4ef !important;
        }
        
        .attempts-grid .attempt-cell[data-color="purple"] {
            background-color: #ba81c5 !important;
        }


        @keyframes cellAppear {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .attempt-row {
            display: contents;
        }

        .attempt-cell.animate {
            opacity: 0;
            transform: scale(0.9);
            animation: cellAppear 0.3s ease-out forwards;
            animation-delay: calc(var(--row-index) * 0.1s + var(--cell-index) * 0.05s);
        }

        .completion-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin: 20px auto;
            max-width: 200px;
        }

        .completion-cell {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            border-radius: 4px;
        }

        .completion-cell span {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.9rem;
            text-align: center;
            width: 90%;
            word-break: break-word;
            line-height: 1.1;
        }

        .completion-grid-link {
            text-decoration: none;
            display: block;
            transition: transform 0.3s ease;
        }

        .completion-grid-link:hover {
            transform: scale(1.05);
            z-index: 1;
        }

        .game-over {
            text-align: center;
            padding: 30px;
            background-color: #fff;
            border-radius: 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -40%);
            z-index: 1000;
            width: 540px;
            max-width: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-over.show {
            opacity: 1;
            transform: translate(-50%, -50%);
            pointer-events: auto;
        }

        .game-over h2 {
            font-family: 'Karnak', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 2rem;
            font-weight: 400;
            margin-bottom: 15px;
            color: #333;
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.2s forwards;
        }

        .game-over p {
            font-family: 'KarnakNormal', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 16px;
            font-weight: 400;
            color: #666;
            margin-bottom: 20px;
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.3s forwards;
        }

        .game-over .btn {
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.4s forwards;
        }

        /* Mobile users will be redirected to mobile version */
        
        /* Early Access Popup - Match game-over popup style */
        .early-access-popup {
            text-align: center;
            padding: 30px;
            background-color: #fff;
            border-radius: 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -40%);
            z-index: 1000;
            width: 540px;
            max-width: 90%;
            display: none;
        }
        
        .early-access-popup.show {
            opacity: 1;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .early-access-popup h2 {
            font-family: 'Karnak', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 2rem;
            font-weight: 400;
            margin-bottom: 15px;
            color: #333;
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.2s forwards;
        }
        
        .early-access-popup p {
            font-family: 'KarnakNormal', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 16px;
            font-weight: 400;
            color: #666;
            margin-bottom: 20px;
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.3s forwards;
        }
        
        .early-access-popup .btn {
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.4s forwards;
        }
        
        /* How to Play Popup */
        .how-to-play-popup {
            text-align: left;
            padding: 30px;
            background-color: #fff;
            border-radius: 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -40%);
            z-index: 1000;
            width: 540px;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        
        .how-to-play-popup.show {
            opacity: 1;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            display: block;
        }
        
        .how-to-play-popup h2 {
            font-family: 'Karnak', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 2rem;
            font-weight: 400;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        .how-to-play-popup p {
            font-family: 'KarnakNormal', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 16px;
            font-weight: 400;
            color: #333;
            margin-bottom: 20px;
            line-height: 1.4;
        }
        
        .how-to-play-popup ul {
            font-family: 'KarnakNormal', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 16px;
            font-weight: 400;
            color: #333;
            margin-bottom: 20px;
            padding-left: 20px;
            line-height: 1.6;
        }
        
        .how-to-play-popup li {
            margin-bottom: 8px;
        }
        
        .how-to-play-popup h3 {
            font-family: 'Karnak', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 1.2rem;
            font-weight: 400;
            margin: 25px 0 15px 0;
            color: #333;
        }
        
        .close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s ease;
        }
        
        .close-btn:hover {
            color: #000;
        }
        
        .difficulty-colors {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 15px 0;
        }
        
        .difficulty-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
        
        .color-yellow { background-color: #f9df84; }
        .color-green { background-color: #a0c35a; }
        .color-blue { background-color: #b0c4ef; }
        .color-purple { background-color: #ba81c5; }

        .group-block {
            grid-column: span 4;
            background-color: #a0c35a;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
            color: #fff;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .group-block.new-group {
            animation: groupAppear 0.5s ease-out;
        }

        @keyframes groupAppear {
            from {
                transform: translateY(20px) scale(0.95);
                opacity: 0;
            }
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .group-block.yellow {
            background-color: #f9df84;
            color: #121212;
        }

        .group-block.green {
            background-color: #a0c35a;
            color: #ffffff;
        }

        .group-block.blue {
            background-color: #b0c4ef;
            color: #121212;
        }

        .group-block.purple {
            background-color: #ba81c5;
            color: #ffffff;
        }

        .group-category {
            font-family: 'Franklin', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 20px;
            margin-bottom: 2px;
            font-weight: 700;
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.2s forwards;
            line-height: 1;
            color: #121212;
        }

        .group-words {
            font-family: 'Franklin', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 20px;
            opacity: 0;
            font-weight: 500;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.3s forwards;
            line-height: 1;
            color: #121212;
        }

        @keyframes textAppear {
            to {
                opacity: 0.9;
                transform: translateY(0);
            }
        }

        .cooldown-timer {
            font-family: 'Franklin', 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 16px;
            font-weight: 500;
            margin: 15px 0;
            color: #666;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
        </div>
    </header>
    
    <header class="header">
        <div class="header-content">
            <h1 class="title">Connections</h1>
        </div>
    </header>
    
    <header class="header help-header">
        <div class="header-content">
            <div class="help-bar">
                <div class="help-icon" id="helpIcon">
                    <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" height="32" viewBox="0 0 32 32" width="32" class="game-icon" data-testid="icon-help">
                        <path fill="var(--text)" d="M15 24H17.6667V21.3333H15V24ZM16.3333 2.66666C8.97333 2.66666 3 8.63999 3 16C3 23.36 8.97333 29.3333 16.3333 29.3333C23.6933 29.3333 29.6667 23.36 29.6667 16C29.6667 8.63999 23.6933 2.66666 16.3333 2.66666ZM16.3333 26.6667C10.4533 26.6667 5.66667 21.88 5.66667 16C5.66667 10.12 10.4533 5.33332 16.3333 5.33332C22.2133 5.33332 27 10.12 27 16C27 21.88 22.2133 26.6667 16.3333 26.6667ZM16.3333 7.99999C13.3867 7.99999 11 10.3867 11 13.3333H13.6667C13.6667 11.8667 14.8667 10.6667 16.3333 10.6667C17.8 10.6667 19 11.8667 19 13.3333C19 16 15 15.6667 15 20H17.6667C17.6667 17 21.6667 16.6667 21.6667 13.3333C21.6667 10.3867 19.28 7.99999 16.3333 7.99999Z"></path>
                    </svg>
                </div>
            </div>
        </div>
    </header>

    <main class="main-content">
        <div class="container">
            <p class="subtitle">Create four groups of four!</p>
            <div class="toast" id="toast"></div>
            <div class="word-grid" id="wordGrid"></div>

            <div class="mistakes-section">
                <div class="mistakes">
                    Mistakes remaining:
                    <div class="mistake-dots">
                        <div class="mistake-dot" id="dot4"></div>
                        <div class="mistake-dot" id="dot3"></div>
                        <div class="mistake-dot" id="dot2"></div>
                        <div class="mistake-dot" id="dot1"></div>
                    </div>
                </div>
            </div>

            <div class="timer-section" id="timerSection">
                Next attempt available in: <span id="timer">00:00:00</span>
            </div>

            <div class="controls">
                <button class="btn" id="shuffleBtn">Shuffle</button>
                <button class="btn" id="deselectBtn">Deselect All</button>
                <button class="btn" id="submitBtn" disabled>Submit</button>
            </div>

            <div class="game-over" id="gameOver">
                <button class="close-btn" onclick="closeGameOverPopup()">✕</button>
                <h2 id="gameOverTitle">Game Over!</h2>
                <p id="gameOverMessage"></p>
                <div class="cooldown-timer" id="cooldownTimer"></div>
                <button class="btn" id="playAgainBtn">Play Again</button>
            </div>
        </div>
    </main>

    <script>
        // Mobile redirect - redirect to mobile version if on mobile device
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (window.innerWidth <= 768 && window.innerHeight <= 1024);
        }
        
        if (isMobile()) {
            window.location.href = 'sinnections-mobile.html';
        }
        
        // Game data
        const gameData = {
            groups: [
                {
                    category: "FRIENDS-TO-VAMPIRES",
                    words: ["CORNBREAD", "STACK", "MARY", "PEARLINE"],
                    color: "yellow",
                    difficulty: 1
                },
                {
                    category: "SAMMIE'S SUMMONED SYMPHONIES",
                    words: ["TRAP", "BLUES", "ROCK", "CLUB"],
                    color: "green",
                    difficulty: 2
                },
                {
                    category: "VAMPIRE-SLAYERS",
                    words: ["SMOKE", "SUNLIGHT", "SILVER", "STAKE"],
                    color: "blue",
                    difficulty: 3
                },
                {
                    category: "MY THOUGHTS ON SINNERS",
                    words: ["FIRE", "SMART", "SHARP", "FRESH"],
                    color: "purple",
                    difficulty: 4
                }
            ]
        };

        // Flag to control next puzzle access
        const NEXT_PUZZLES_ENABLED = false; // Set to true to enable all next puzzles
        
        // Cooldown duration in milliseconds
        const COOLDOWN_DURATION = 3600000; // 1 hour (3600000ms)
        
        // Game state
        let gameState = {
            words: [],
            selectedWords: [],
            foundGroups: [],
            completionOrder: [],
            mistakes: 0,
            maxMistakes: 4,
            gameOver: false,
            previousGuesses: new Set(), // Track previous incorrect guesses
            lastAttemptTime: null, // Track when the last attempt was made
            timerInterval: null, // Track the timer interval
            attempts: [], // Track all attempts with their colors
            wordSubsets: {} // Track selected word subsets for each category
        };

        // DOM elements
        const wordGrid = document.getElementById('wordGrid');
        const toastEl = document.getElementById('toast');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const deselectBtn = document.getElementById('deselectBtn');
        const submitBtn = document.getElementById('submitBtn');
        const gameOverEl = document.getElementById('gameOver');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const cooldownTimer = document.getElementById('cooldownTimer');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const timerSection = document.getElementById('timerSection');
        const timerEl = document.getElementById('timer');

        // Check if user is in cooldown period
        function isInCooldown() {
            const lastAttempt = localStorage.getItem('sinnections_lastAttemptTime');
            if (!lastAttempt) return false;

            const now = new Date().getTime();
            const timeDiff = now - parseInt(lastAttempt);
            return timeDiff < COOLDOWN_DURATION;
        }

        // Update cooldown timer display
        function updateCooldownTimer() {
            const lastAttempt = localStorage.getItem('sinnections_lastAttemptTime');
            if (!lastAttempt) return;

            const now = new Date().getTime();
            const timeDiff = now - parseInt(lastAttempt);
            const timeLeft = Math.max(COOLDOWN_DURATION - timeDiff, 0);

            if (timeLeft === 0) {
                cooldownTimer.textContent = 'You can now play again!';
                playAgainBtn.disabled = false;
                playAgainBtn.textContent = 'Play Again';
                clearInterval(gameState.timerInterval);
                // Don't auto-close popup - let user click Play Again button
                return;
            }

            const hours = Math.floor(timeLeft / 3600000);
            const minutes = Math.floor((timeLeft % 3600000) / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);

            cooldownTimer.textContent = `Next game available in: ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            playAgainBtn.disabled = true;
            playAgainBtn.textContent = 'Please Wait';
        }

        // Show toast message
        function showToast(message) {
            // Clear any existing timeout
            if (window.toastTimeout) {
                clearTimeout(window.toastTimeout);
            }
            
            toastEl.textContent = message;
            toastEl.className = 'toast show';
            
            window.toastTimeout = setTimeout(() => {
                toastEl.className = 'toast';
            }, 2000);
        }
        
        // Show early access popup
        function showEarlyAccessPopup() {
            const popup = document.getElementById('early-access-popup');
            popup.classList.add('show');
        }
        
        // Close early access popup
        function closeEarlyAccessPopup() {
            const popup = document.getElementById('early-access-popup');
            popup.classList.remove('show');
        }

        // Save game state with error handling
        function saveGameState() {
            try {
                if (!gameState || gameState.gameOver) {
                    return; // Don't save if game is over
                }
                
                const stateToSave = {
                    words: gameState.words || [],
                    selectedWords: gameState.selectedWords || [], // Always save current selections
                    foundGroups: gameState.foundGroups || [],
                    completionOrder: gameState.completionOrder || [],
                    mistakes: gameState.mistakes || 0,
                    maxMistakes: gameState.maxMistakes || 4,
                    previousGuesses: Array.from(gameState.previousGuesses || []),
                    attempts: gameState.attempts || [],
                    wordSubsets: gameState.wordSubsets || {},
                    timestamp: Date.now()
                };
                localStorage.setItem('sinnections_gameState', JSON.stringify(stateToSave));
            } catch (e) {
                console.warn('Failed to save game state:', e);
            }
        }
        
        // Load game state with validation
        function loadGameState() {
            try {
                const savedState = localStorage.getItem('sinnections_gameState');
                if (!savedState) return false;
                
                const state = JSON.parse(savedState);
                
                // Validate the loaded state
                if (!state.words || !Array.isArray(state.words) || state.words.length === 0) {
                    return false;
                }
                
                // Restore game state
                gameState.words = state.words;
                gameState.selectedWords = state.selectedWords || [];
                gameState.foundGroups = state.foundGroups || [];
                gameState.completionOrder = state.completionOrder || [];
                gameState.mistakes = state.mistakes || 0;
                gameState.maxMistakes = state.maxMistakes || 4;
                gameState.previousGuesses = new Set(state.previousGuesses || []);
                gameState.attempts = state.attempts || [];
                gameState.wordSubsets = state.wordSubsets || {};
                gameState.gameOver = false;
                gameState.lastAttemptTime = null;
                gameState.timerInterval = null;
                
                return true;
            } catch (e) {
                console.warn('Failed to load game state:', e);
                localStorage.removeItem('sinnections_gameState');
                return false;
            }
        }
        
        // Clear saved game state
        function clearSavedGameState() {
            try {
                localStorage.removeItem('sinnections_gameState');
            } catch (e) {
                console.warn('Failed to clear game state:', e);
            }
        }

        // Initialize game
        function initGame() {
            // Check if cooldown has expired and clean up if needed
            const lastAttempt = localStorage.getItem('sinnections_lastAttemptTime');
            if (lastAttempt) {
                const now = new Date().getTime();
                const timeDiff = now - parseInt(lastAttempt);
                if (timeDiff >= COOLDOWN_DURATION) {
                    // Cooldown has expired - clear all saved data for fresh start
                    localStorage.removeItem('sinnections_lastAttemptTime');
                    clearSavedGameState();
                    localStorage.removeItem('sinnections_attempts');
                }
            }
            
            // NOW check cooldown (after cleanup)
            if (isInCooldown()) {
                // Try to load the saved game state from when they lost
                const hasLoadedState = loadGameState();
                
                if (!hasLoadedState) {
                    // Fallback if no saved state - create basic game state
                    gameState = {
                        words: getGameWords(),
                        selectedWords: [],
                        foundGroups: [],
                        completionOrder: [],
                        mistakes: 4,
                        maxMistakes: 4,
                        gameOver: true,
                        previousGuesses: new Set(),
                        lastAttemptTime: null,
                        timerInterval: null,
                        attempts: [],
                        wordSubsets: getWordSubsets()
                    };
                    shuffleArray(gameState.words);
                } else {
                    // Use loaded state but ensure game is marked as over
                    gameState.gameOver = true;
                }
                
                // Reset UI and render grid so tiles are visible behind popup
                toastEl.className = 'toast';
                updateMistakesDisplay();
                renderWordGrid();
                updateControls();
                showGameOverScreen(false, true);
                return;
            }

            // Initialize base game state
            gameState = {
                words: [],
                selectedWords: [],
                foundGroups: [],
                completionOrder: [],
                mistakes: 0,
                maxMistakes: 4,
                gameOver: false,
                previousGuesses: new Set(),
                lastAttemptTime: null,
                timerInterval: null,
                attempts: [],
                wordSubsets: {}
            };

            // Try to load existing game state
            const hasLoadedState = loadGameState();
            
            if (!hasLoadedState) {
                // Create new game - get word subsets and shuffle
                gameState.wordSubsets = getWordSubsets();
                gameState.words = getGameWords();
                shuffleArray(gameState.words);
            }

            // Check if user won and closed popup previously
            const winPopupClosed = localStorage.getItem('sinnections_winPopupClosed');
            const hasWon = gameState.foundGroups.length === 4;
            
            // Reset UI
            toastEl.className = 'toast';
            gameOverEl.className = 'game-over';
            updateMistakesDisplay();
            renderWordGrid();
            updateControls();
            
            // If user won but popup was closed, show categories without popup
            // If user won and refreshed, show popup again
            if (hasWon) {
                if (winPopupClosed === 'true') {
                    // Show categories without popup
                    gameState.gameOver = true;
                } else {
                    // Show win popup on refresh
                    gameState.gameOver = true;
                    showGameOverScreen(true);
                }
            }
        }

        // Get or create word subsets for categories with more than 4 words
        function getWordSubsets() {
            // Try to load existing subsets first
            const savedSubsets = localStorage.getItem('sinnections_wordSubsets');
            if (savedSubsets) {
                try {
                    return JSON.parse(savedSubsets);
                } catch (e) {
                    console.warn('Failed to load word subsets:', e);
                }
            }
            
            // Create new subsets
            const subsets = {};
            gameData.groups.forEach(group => {
                if (group.words.length > 4) {
                    // Randomly select 4 words from the group
                    const shuffledWords = [...group.words];
                    shuffleArray(shuffledWords);
                    subsets[group.category] = shuffledWords.slice(0, 4);
                } else {
                    // Use all words if 4 or fewer
                    subsets[group.category] = [...group.words];
                }
            });
            
            // Save the subsets
            try {
                localStorage.setItem('sinnections_wordSubsets', JSON.stringify(subsets));
            } catch (e) {
                console.warn('Failed to save word subsets:', e);
            }
            
            return subsets;
        }
        
        // Get the current game words based on subsets
        function getGameWords() {
            const subsets = gameState.wordSubsets || getWordSubsets();
            return Object.values(subsets).flat();
        }
        
        // Clear word subsets (only called when user wins and plays again)
        function clearWordSubsets() {
            try {
                localStorage.removeItem('sinnections_wordSubsets');
            } catch (e) {
                console.warn('Failed to clear word subsets:', e);
            }
        }

        // Shuffle array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Optimized render word grid with reduced DOM manipulation
        function renderWordGrid() {
            const currentTiles = wordGrid.querySelectorAll('.word-tile');
            const currentWords = Array.from(currentTiles).map(tile => tile.textContent);
            
            // Get remaining words (not found yet) - use Set for faster lookup
            const foundWords = new Set(gameState.foundGroups.flatMap(group => group.words));
            const remainingWords = gameState.words.filter(word => !foundWords.has(word));
            const selectedWordsSet = new Set(gameState.selectedWords);
            
            // Update existing tiles if possible (but only if order is also the same)
            if (currentWords.length === remainingWords.length && 
                currentWords.every((word, index) => word === remainingWords[index])) {
                // Just update selection states - words are in same order
                currentTiles.forEach(tile => {
                    const word = tile.textContent;
                    tile.classList.toggle('selected', selectedWordsSet.has(word));
                });
            } else {
                // Full re-render needed - use DocumentFragment for better performance
                const fragment = document.createDocumentFragment();
                
                // Add found groups first (at the top) - preserve existing groups
                gameState.foundGroups.forEach((group, index) => {
                    const groupBlock = document.createElement('div');
                    groupBlock.className = `group-block ${group.color}`;
                    
                    groupBlock.innerHTML = `
                        <div class="group-category">${group.category}</div>
                        <div class="group-words">${group.words.join(', ')}</div>
                    `;
                    
                    fragment.appendChild(groupBlock);
                });
                
                // Add remaining word tiles below the groups
                remainingWords.forEach(word => {
                    const tile = document.createElement('div');
                    tile.className = `word-tile${selectedWordsSet.has(word) ? ' selected' : ''}`;
                    tile.textContent = word;
                    tile.addEventListener('click', () => selectWord(word), { passive: true });
                    
                    fragment.appendChild(tile);
                });
                
                // Single DOM update
                wordGrid.innerHTML = '';
                wordGrid.appendChild(fragment);
            }
        }

        // Select/deselect word
        function selectWord(word) {
            if (gameState.gameOver) return;
            
            // Check if word is already found
            const isFound = gameState.foundGroups.some(group => 
                group.words.includes(word)
            );
            if (isFound) return;

            const index = gameState.selectedWords.indexOf(word);
            
            if (index > -1) {
                // Deselect word
                gameState.selectedWords.splice(index, 1);
            } else if (gameState.selectedWords.length < 4) {
                // Select word
                gameState.selectedWords.push(word);
            }
            
            renderWordGrid();
            updateControls();
        }

        // Update control buttons
        function updateControls() {
            submitBtn.disabled = gameState.selectedWords.length !== 4;
            deselectBtn.disabled = gameState.selectedWords.length === 0;
        }

        // Shuffle words with optimized performance
        function shuffleWords() {
            // Get remaining words (not found yet) - use cached check for better performance
            const foundWords = new Set(gameState.foundGroups.flatMap(group => group.words));
            const remainingWords = gameState.words.filter(word => !foundWords.has(word));
            
            // Shuffle only the remaining words
            shuffleArray(remainingWords);
            
            // Update the words array with found groups first, then shuffled remaining
            gameState.words = [
                ...gameState.foundGroups.flatMap(group => group.words),
                ...remainingWords
            ];
            
            // DON'T clear selections when shuffling - keep user's selected words
            
            // Use requestAnimationFrame for smoother rendering
            requestAnimationFrame(() => {
                wordGrid.innerHTML = '';
                renderWordGrid();
                updateControls();
            });
        }

        // Deselect all words
        function deselectAll() {
            gameState.selectedWords = [];
            renderWordGrid();
            updateControls();
        }

        // Submit guess
        function submitGuess() {
            if (gameState.selectedWords.length !== 4) return;

            // Sort selected words to ensure consistent comparison
            const sortedGuess = [...gameState.selectedWords].sort().join(',');

            // Check if this guess was already tried
            if (gameState.previousGuesses.has(sortedGuess)) {
                showToast('Already guessed');
                gameState.selectedWords = [];
                saveGameState(); // Save state after clearing selections
                renderWordGrid();
                updateControls();
                return;
            }

            // Check if this combination forms a valid group (using subsets)
            const correctGroup = gameData.groups.find(group => {
                const groupSubset = gameState.wordSubsets[group.category] || group.words;
                return gameState.selectedWords.every(word => groupSubset.includes(word)) &&
                       groupSubset.every(word => gameState.selectedWords.includes(word)) &&
                       gameState.selectedWords.length === 4;
            });

            if (correctGroup) {
                // Animate correct guess sequence
                animateCorrectGuess(correctGroup);
            } else {
                // Add to previous guesses
                gameState.previousGuesses.add(sortedGuess);

                // Find the group that has the most matches with the selected words (using subsets)
                let bestMatch = null;
                let maxMatches = 0;
                gameData.groups.forEach(group => {
                    const groupSubset = gameState.wordSubsets[group.category] || group.words;
                    const matches = gameState.selectedWords.filter(word => 
                        groupSubset.includes(word)
                    ).length;
                    if (matches > maxMatches) {
                        maxMatches = matches;
                        bestMatch = group;
                    }
                });

                // Track the attempt with colors in order (using subsets)
                const selectedColors = gameState.selectedWords.map(word => {
                    // Find which group this word belongs to
                    const group = gameData.groups.find(g => {
                        const groupSubset = gameState.wordSubsets[g.category] || g.words;
                        return groupSubset.includes(word);
                    });
                    return group ? group.color : 'gray';
                });
                gameState.attempts.push({
                    words: [...gameState.selectedWords],
                    colors: selectedColors,
                    correct: false
                });

                // Check if "one away" (3 out of 4 words are correct, using subsets)
                const oneAwayGroup = gameData.groups.find(group => {
                    const groupSubset = gameState.wordSubsets[group.category] || group.words;
                    const matchingWords = gameState.selectedWords.filter(word => 
                        groupSubset.includes(word)
                    );
                    return matchingWords.length === 3;
                });

                if (oneAwayGroup) {
                    showToast('One away');
                }

                // Shake the selected tiles for incorrect guess - optimized cleanup
                const selectedTiles = document.querySelectorAll('.word-tile.selected');
                selectedTiles.forEach(tile => {
                    tile.classList.add('incorrect-guess');
                    // Use requestAnimationFrame for smoother cleanup
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            tile.classList.remove('incorrect-guess');
                        }, 400);
                    });
                });

                // Incorrect guess
                gameState.mistakes++;
                // Clear selected words after submitting guess
                gameState.selectedWords = [];
                
                updateMistakesDisplay();
                saveGameState(); // Save state after incorrect guess
                renderWordGrid(); // Re-render to show cleared selections
                
                // Check if game is lost
                if (gameState.mistakes >= gameState.maxMistakes) {
                    // Store the loss time in localStorage
                    localStorage.setItem('sinnections_lastAttemptTime', new Date().getTime().toString());
                    // DON'T clear saved state on loss - preserve it for cooldown period
                    saveGameState(); // Save final state so user can see it during cooldown
                    endGame(false);
                }
            }
            
            updateControls();
        }

async function animateCorrectGuess(correctGroup) {
    const selectedTiles = Array.from(document.querySelectorAll('.word-tile.selected'));
    
    // Step 1: Hop animation - each tile hops one at a time with optimized timing
    const hopPromises = selectedTiles.map((tile, i) => {
        return new Promise(resolve => {
            setTimeout(() => {
                tile.classList.add('hop');
                // Use requestAnimationFrame for smoother cleanup
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        tile.classList.remove('hop');
                        resolve();
                    }, 300);
                });
            }, i * 100);
        });
    });
    
    await Promise.all(hopPromises);
    
    // Step 2: Calculate target row and positions
    const grid = document.getElementById('wordGrid');
    const gridRect = grid.getBoundingClientRect();
    const allTiles = Array.from(grid.querySelectorAll('.word-tile'));
    
    // Target row is right after existing groups (at index gameState.foundGroups.length)
    const targetRowIndex = gameState.foundGroups.length;
    
    // Calculate the exact grid positions for the target row
    const targetPositions = [];
    const tileHeight = selectedTiles[0].offsetHeight;
    const tileWidth = selectedTiles[0].offsetWidth;
    const gap = 8; // CSS gap value
    
    for (let col = 0; col < 4; col++) {
        const x = gridRect.left + col * (tileWidth + gap);
        const y = gridRect.top + targetRowIndex * (tileHeight + gap);
        targetPositions.push({ x, y });
    }
    
    // Step 3: Find tiles that are exactly in the target row positions
    const tilesToDisplace = [];
    const swapAnimations = [];
    
    // Get all non-selected tiles currently in the target row
    const tilesInTargetRow = allTiles.filter(tile => {
        if (tile.classList.contains('selected')) return false;
        
        const tileRect = tile.getBoundingClientRect();
        const tileRowIndex = Math.round((tileRect.top - gridRect.top) / (tileHeight + gap));
        
        // Only include tiles that are exactly in the target row
        return tileRowIndex === targetRowIndex;
    });
    
    // These are the tiles that need to be displaced
    tilesToDisplace.push(...tilesInTargetRow);
    
    // Move selected tiles to target row
    selectedTiles.forEach((selectedTile, index) => {
        const selectedRect = selectedTile.getBoundingClientRect();
        const targetPos = targetPositions[index];
        
        const deltaX = targetPos.x - selectedRect.left;
        const deltaY = targetPos.y - selectedRect.top;
        
        selectedTile.classList.add('moving');
        selectedTile.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
    });
    
    // Calculate exact destination positions for displaced tiles
    const remainingTiles = allTiles.filter(tile => 
        !tile.classList.contains('selected') && 
        !tilesToDisplace.includes(tile)
    );
    
    // Create a list of all available positions after the target row
    const availablePositions = [];
    for (let row = targetRowIndex + 1; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
            const x = gridRect.left + col * (tileWidth + gap);
            const y = gridRect.top + row * (tileHeight + gap);
            availablePositions.push({ x, y, row, col });
        }
    }
    
    // First, account for tiles that are already in correct positions and don't need to move
    const occupiedPositions = new Set();
    remainingTiles.forEach(tile => {
        const tileRect = tile.getBoundingClientRect();
        availablePositions.forEach((pos, index) => {
            if (Math.abs(tileRect.left - pos.x) < 10 && Math.abs(tileRect.top - pos.y) < 10) {
                occupiedPositions.add(index);
            }
        });
    });
    
    // Assign displaced tiles to the first available positions
    let assignmentIndex = 0;
    tilesToDisplace.forEach((displacedTile) => {
        // Find next available position
        while (assignmentIndex < availablePositions.length && occupiedPositions.has(assignmentIndex)) {
            assignmentIndex++;
        }
        
        if (assignmentIndex < availablePositions.length) {
            const targetPos = availablePositions[assignmentIndex];
            const tileRect = displacedTile.getBoundingClientRect();
            
            const deltaX = targetPos.x - tileRect.left;
            const deltaY = targetPos.y - tileRect.top;
            
            displacedTile.classList.add('moving');
            displacedTile.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            swapAnimations.push({ targetTile: displacedTile });
            
            // Mark this position as occupied
            occupiedPositions.add(assignmentIndex);
            assignmentIndex++;
        }
    });
    
    // Wait for movement animation to complete
    await new Promise(resolve => setTimeout(resolve, 600));
    
    // Step 4: Update game state
    // Create a copy of the group with the subset words
    const groupWithSubset = {
        ...correctGroup,
        words: gameState.wordSubsets[correctGroup.category] || correctGroup.words
    };
    gameState.foundGroups.push(groupWithSubset);
    gameState.completionOrder.push(correctGroup.color);
    gameState.attempts.push({
        words: [...gameState.selectedWords],
        colors: gameState.selectedWords.map(() => correctGroup.color),
        correct: true
    });
    gameState.selectedWords = [];
    
    // Step 5: Clean up transforms first, THEN modify DOM
    selectedTiles.forEach(tile => {
        tile.classList.remove('moving', 'selected');
        tile.style.transform = '';
    });
    
    swapAnimations.forEach(({ targetTile }) => {
        targetTile.classList.remove('moving');
        targetTile.style.transform = '';
    });
    
    // Wait a frame to ensure transforms are cleared
    await new Promise(resolve => requestAnimationFrame(resolve));
    
    // Step 6: Temporarily disable transitions to prevent second movement
    const allRemainingTiles = wordGrid.querySelectorAll('.word-tile:not(.selected)');
    allRemainingTiles.forEach(tile => {
        tile.style.transition = 'none';
    });
    
    // Now remove tiles and insert group block
    selectedTiles.forEach(tile => {
        tile.remove();
    });
    
    // Create the new group block
    const groupBlock = document.createElement('div');
    groupBlock.className = `group-block ${correctGroup.color} new-group`;
    
    const categoryEl = document.createElement('div');
    categoryEl.className = 'group-category';
    categoryEl.textContent = correctGroup.category;
    
    const wordsEl = document.createElement('div');
    wordsEl.className = 'group-words';
    wordsEl.textContent = correctGroup.words.join(', ');
    
    groupBlock.appendChild(categoryEl);
    groupBlock.appendChild(wordsEl);
    
    // Insert at the correct position
    const firstTile = wordGrid.querySelector('.word-tile');
    
    if (firstTile) {
        wordGrid.insertBefore(groupBlock, firstTile);
    } else {
        wordGrid.appendChild(groupBlock);
    }
    
    // Re-enable transitions after a frame
    requestAnimationFrame(() => {
        allRemainingTiles.forEach(tile => {
            if (tile.parentNode) { // Check if tile still exists
                tile.style.transition = '';
            }
        });
    });
    
    // Remove the animation class after animation completes
    setTimeout(() => {
        groupBlock.classList.remove('new-group');
    }, 500);
    
    updateControls();
    saveGameState(); // Save state after correct guess
    
    // Check if game is won
    if (gameState.foundGroups.length === 4) {
        clearSavedGameState(); // Clear saved state on game completion
        clearWordSubsets(); // Clear word subsets on win so new game gets new subsets
        endGame(true);
    }
}

        // Update mistakes display
        function updateMistakesDisplay() {            
            for (let i = 1; i <= 4; i++) {
                const dot = document.getElementById(`dot${i}`);
                if (i <= gameState.mistakes) {
                    dot.classList.add('used');
                } else {
                    dot.classList.remove('used');
                }
            }
        }

        // Show game over screen
        function showGameOverScreen(won, fromCooldown = false) {
            gameState.gameOver = true;
            
            // Clear any existing grids from previous games (but only from inside game-over element)
            const existingGrids = gameOverEl.querySelectorAll('.attempts-grid, .completion-grid');
            existingGrids.forEach(grid => grid.remove());
            
            // Handle close button visibility
            const closeBtn = gameOverEl.querySelector('.close-btn');
            if (won || !fromCooldown) {
                // Show close button for wins or new losses
                closeBtn.style.display = 'block';
            } else {
                // Hide close button during cooldown
                closeBtn.style.display = 'none';
            }
            
            if (won) {
                gameOverTitle.textContent = 'Congratulations!';
                gameOverMessage.textContent = 'You found all the connections!';
                playAgainBtn.disabled = false;
                playAgainBtn.textContent = 'Play Again';
                cooldownTimer.textContent = '';
                // Mark connect1ons as completed
                localStorage.setItem('connect1ons_completed', 'true');
            } else {
                gameOverTitle.textContent = 'Game Over';
                gameOverMessage.textContent = 'Better luck next time!';
                playAgainBtn.textContent = 'Play Again';
                
                if (fromCooldown) {
                    // Start the cooldown timer, button starts disabled
                    playAgainBtn.disabled = true;
                    updateCooldownTimer();
                    gameState.timerInterval = setInterval(updateCooldownTimer, 1000);
                } else {
                    // Start the cooldown timer, button starts disabled
                    playAgainBtn.disabled = true;
                    updateCooldownTimer();
                    gameState.timerInterval = setInterval(updateCooldownTimer, 1000);
                }
            }

            // Always show attempts grid at the end
            if (gameState.attempts.length > 0) {
                const attemptsGrid = document.createElement('div');
                attemptsGrid.className = 'attempts-grid';
                
                gameState.attempts.forEach((attempt, rowIndex) => {
                    const attemptRow = document.createElement('div');
                    attemptRow.className = 'attempt-row';
                    
                    attempt.colors.forEach((color, cellIndex) => {
                        const cell = document.createElement('div');
                        cell.className = 'attempt-cell';
                        
                        const bgColor = getColorCode(color);
                        
                        // Try multiple approaches to ensure color is set
                        cell.style.backgroundColor = bgColor;
                        cell.style.background = bgColor;
                        cell.setAttribute('data-color', color);
                        cell.setAttribute('data-bg-color', bgColor);
                        
                        // Calculate unique cell index across all attempts
                        const globalCellIndex = rowIndex * 4 + cellIndex;
                        const totalCells = gameState.attempts.length * 4;
                        
                        // Only add links to the last row (final 4 cells)
                        if (globalCellIndex >= totalCells - 4) {
                            // Define unique links for the last row
                            const lastRowLinks = [
                                '',
                                '',
                                '',
                                ''
                            ];
                            
                            const lastRowIndex = globalCellIndex - (totalCells - 4);
                            
                            cell.style.cursor = 'pointer';
                            cell.addEventListener('click', () => {
                                const link = lastRowLinks[lastRowIndex];
                                
                                // If next puzzles are disabled, always show popup
                                if (!NEXT_PUZZLES_ENABLED) {
                                    showEarlyAccessPopup();
                                } else {
                                    // Only check link validity when puzzles are enabled
                                    if (link && link.trim() !== '') {
                                        window.open(link, '_blank');
                                    } else {
                                        showToast('Not yet!');
                                    }
                                }
                            });
                        }
                        
                        cell.style.setProperty('--row-index', rowIndex);
                        cell.style.setProperty('--cell-index', cellIndex);
                        attemptRow.appendChild(cell);
                    });
                    
                    attemptsGrid.appendChild(attemptRow);
                });
                
                gameOverMessage.insertAdjacentElement('afterend', attemptsGrid);
            }

            // Use groups in the order they were solved (preserve existing layout)
            const solvedGroups = gameState.foundGroups;
            
            // Clear the word grid
            wordGrid.innerHTML = '';
            
            // Add all groups in the order they were solved
            solvedGroups.forEach(group => {
                const groupBlock = document.createElement('div');
                groupBlock.className = `group-block ${group.color}`;
                
                const categoryEl = document.createElement('div');
                categoryEl.className = 'group-category';
                categoryEl.textContent = group.category;
                
                const wordsEl = document.createElement('div');
                wordsEl.className = 'group-words';
                wordsEl.textContent = group.words.join(', ');
                
                groupBlock.appendChild(categoryEl);
                groupBlock.appendChild(wordsEl);
                wordGrid.appendChild(groupBlock);
            });
            
            // Show the game over screen
            gameOverEl.className = 'game-over show';
            
            // Ensure all attempt cells are visible with optimized DOM manipulation
            requestAnimationFrame(() => {
                const attemptsGrid = gameOverEl.querySelector('.attempts-grid');
                if (attemptsGrid) {
                    attemptsGrid.style.display = 'grid';
                    // Batch DOM updates for better performance
                    const attemptCells = attemptsGrid.querySelectorAll('.attempt-cell');
                    attemptCells.forEach(cell => {
                        cell.style.cssText = 'opacity: 1; transform: scale(1);';
                    });
                }
            });
        }

        // End game
        function endGame(won) {
            showGameOverScreen(won);
            
            if (won) {
                // Add victory shake to the last row of group blocks after screen is shown
                setTimeout(() => {
                    addVictoryShake();
                }, 200);
            }
        }

        // Add victory shake and click handlers to the last row of attempts grid
        function addVictoryShake() {
            // Use a more reliable approach to wait for the attempts grid
            const checkForGrid = () => {
                const attemptsGrid = gameOverEl.querySelector('.attempts-grid');
                
                if (attemptsGrid && gameState.attempts.length > 0) {
                    const attemptCells = attemptsGrid.querySelectorAll('.attempt-cell');
                    
                    // Calculate expected number of cells (4 cells per attempt)
                    const expectedCells = gameState.attempts.length * 4;
                    
                    if (attemptCells.length >= expectedCells && attemptCells.length >= 4) {
                        // Get the last 4 cells (representing the final winning attempt)
                        const lastRowCells = Array.from(attemptCells).slice(-4);
                        
                        // Double-check that these cells are visible
                        const allVisible = lastRowCells.every(cell => {
                            const style = window.getComputedStyle(cell);
                            return style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
                        });
                        
                        if (allVisible) {
                            // Define unique links for each cell in the last row
                            const links = [
                                '/',
                                'https://www.google.com/search?q=congratulations+you+won',
                                'https://www.wikipedia.org/wiki/Puzzle',
                                'https://github.com/anthropics/claude-code'
                            ];
                            
                            // Add victory shake and click handlers to each cell in the last row
                            lastRowCells.forEach((cell, index) => {
                                cell.classList.add('victory-shake');
                                
                                // Randomly assign one of the shake animations
                                const shakeAnimations = ['subtle-shake-1', 'subtle-shake-2', 'subtle-shake-3', 'subtle-shake-4'];
                                const randomAnimation = shakeAnimations[Math.floor(Math.random() * shakeAnimations.length)];
                                
                                // Add random duration between 1.5s and 2.5s for more variety
                                const randomDuration = (1.5 + Math.random()).toFixed(1);
                                
                                // Add random delay between 0 and 0.5s to stagger the animations
                                const randomDelay = (Math.random() * 0.5).toFixed(2);
                                
                                cell.style.animation = `${randomAnimation} ${randomDuration}s ease-in-out infinite`;
                                cell.style.animationDelay = `${randomDelay}s`;
                                
                                // Click handlers are already added in showGameOverScreen function
                            });
                            
                            return true; // Successfully added victory shake
                        }
                    }
                }
                return false; // Grid not ready yet
            };
            
            // Try immediately first
            if (!checkForGrid()) {
                // If not ready, wait and try again with shorter intervals for better responsiveness
                let attempts = 0;
                const maxAttempts = 10;
                
                const tryAgain = () => {
                    attempts++;
                    if (checkForGrid() || attempts >= maxAttempts) {
                        return; // Success or max attempts reached
                    }
                    setTimeout(tryAgain, 200); // Try every 200ms for up to 2 seconds
                };
                
                setTimeout(tryAgain, 100);
            }
        }

        // Helper function to get color codes
        function getColorCode(color) {
            const colorMap = {
                'yellow': '#f9df84',
                'green': '#a0c35a',
                'blue': '#b0c4ef',
                'purple': '#ba81c5'
            };
            return colorMap[color] || '#999';
        }

        // Show how to play popup
        function showHowToPlayPopup() {
            const popup = document.getElementById('how-to-play-popup');
            popup.classList.add('show');
        }
        
        // Close how to play popup
        function closeHowToPlayPopup() {
            const popup = document.getElementById('how-to-play-popup');
            popup.classList.remove('show');
        }

        // Close game over popup
        function closeGameOverPopup() {
            gameOverEl.classList.remove('show');
            // If the user won, mark the win state as closed so they can see the categories
            if (gameState.foundGroups.length === 4) {
                localStorage.setItem('sinnections_winPopupClosed', 'true');
            }
        }

        // Event listeners
        shuffleBtn.addEventListener('click', shuffleWords);
        deselectBtn.addEventListener('click', deselectAll);
        submitBtn.addEventListener('click', submitGuess);
        playAgainBtn.addEventListener('click', () => {
            // If cooldown just ended, clear all saved data first
            if (!isInCooldown()) {
                localStorage.removeItem('sinnections_lastAttemptTime');
                clearSavedGameState();
                localStorage.removeItem('sinnections_attempts');
                localStorage.removeItem('sinnections_winPopupClosed');
                // Clear word subsets when starting a new game after win/cooldown
                clearWordSubsets();
                gameOverEl.classList.remove('show');
            }
            initGame();
        });
        document.getElementById('helpIcon').addEventListener('click', showHowToPlayPopup);

        // Initialize game on load
        initGame();
    </script>
    
    <!-- Early Access Popup -->
    <div class="early-access-popup" id="early-access-popup">
        <button class="close-btn" onclick="closeEarlyAccessPopup()">✕</button>
        <h2>You Found It!</h2>
        <p>Impressive work connecting all those patterns!<br><br>You've discovered something that's still taking shape.</p>
        <p style="font-style: italic; font-size: 1rem; color: #999;">The final pieces are yet to connect...</p>
        <button class="btn" onclick="closeEarlyAccessPopup()">Understood</button>
    </div>
    
    <!-- How to Play Popup -->
    <div class="how-to-play-popup" id="how-to-play-popup">
        <button class="close-btn" onclick="closeHowToPlayPopup()">✕</button>
        <h2>How to Play</h2>
        <p>Find groups of four items that share something in common.</p>
        
        <ul>
            <li>Select four items and tap <strong>'Submit'</strong> to check if your guess is correct.</li>
            <li>Find the groups without making 4 mistakes!</li>
        </ul>
        
        <h3>Category Examples</h3>
        <ul>
            <li><strong>FISH:</strong> Bass, Flounder, Salmon, Trout</li>
            <li><strong>FIRE ___:</strong> Ant, Drill, Island, Opal</li>
        </ul>
        
        <p>Categories will always be more specific than "5-LETTER-WORDS," "NAMES" or "VERBS."</p>
        
        <p>Each puzzle has exactly one solution. Watch out for words that seem to belong to multiple categories!</p>
        
        <p>Each group is assigned a color, which will be revealed as you solve:</p>
        
        <div class="difficulty-colors">
            <div class="difficulty-item">
                <div class="color-box color-yellow"></div>
                <span>Straightforward</span>
            </div>
            <div class="difficulty-item">
                <div class="color-box color-green"></div>
                <span>↓</span>
            </div>
            <div class="difficulty-item">
                <div class="color-box color-blue"></div>
                <span></span>
            </div>
            <div class="difficulty-item">
                <div class="color-box color-purple"></div>
                <span>Tricky</span>
            </div>
        </div>
    </div>
</body>
</html>