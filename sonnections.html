<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sonnections</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'nyt-franklin', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: #ffffff;
            color: #121212;
            line-height: 1.4;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: #ffffff;
            border-bottom: 1px solid #dfdfdf;
            padding: 20px 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 600px;
            margin: 0 auto;
            padding: 0 20px;
            text-align: center;
        }

        .main-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem 0;
        }

        .container {
            max-width: 600px;
            width: 100%;
            padding: 0 20px;
        }

        .title {
            font-size: 37px;
            font-weight: 700;
            color: #121212;
            margin: 0;
            letter-spacing: -0.5px;
            line-height: 1;
        }

        .subtitle {
            font-size: 14px;
            color: #363636;
            margin: 8px 0 0 0;
            font-weight: 400;
            line-height: 1.3;
        }

        .mistakes-section {
            text-align: center;
            margin: 20px 0;
        }

        .timer-section {
            text-align: center;
            margin: 16px 0;
            color: #363636;
            font-size: 14px;
            font-weight: 400;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .timer-section.show {
            opacity: 1;
        }

        .mistakes {
            font-size: 14px;
            color: #121212;
            display: inline-flex;
            align-items: center;
            font-weight: 400;
        }

        .mistake-dots {
            display: inline-flex;
            gap: 6px;
            margin-left: 8px;
        }

        .mistake-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #121212;
            transition: opacity 0.3s ease;
            opacity: 1;
        }

        .mistake-dot.used {
            background-color: #dfdfdf;
            opacity: 1;
        }

        .word-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 24px;
            min-height: calc(4 * (56px + 8px));
        }

        .word-tile {
            background-color: #efefe6;
            border: none;
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            font-weight: 700;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            user-select: none;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            will-change: transform, background-color;
            backface-visibility: hidden;
            transform: translateZ(0);
            transition: all 0.15s ease;
            color: #121212;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .play-button {
            width: 32px;
            height: 32px;
            border: none;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            color: #121212;
            font-size: 16px;
            background: none;
        }

        .play-button:hover {
            transform: scale(1.1);
        }

        .play-button.playing {
            color: #121212;
        }

        .word-tile.selected .play-button {
            color: #ffffff;
        }

        .word-tile.selected .play-button:hover {
            color: #f0f0f0;
        }

        .word-tile.selected .play-button.playing {
            color: #ffffff;
        }

        .hidden-word {
            display: none;
        }

        .word-tile:hover {
            background-color: #e6e6dd;
            transform: scale(1.02);
        }

        .word-tile.selected {
            background-color: #5a594e;
            color: #ffffff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .word-tile.correct {
            background-color: #a0c35a;
            border-color: #a0c35a;
            color: #fff;
            cursor: default;
            animation: correctTile 0.5s ease-out;
        }

        @keyframes correctTile {
            0% {
                transform: scale(1);
            }
            35% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 24px;
        }

        .btn {
            padding: 10px 16px;
            border: 2px solid #000000;
            background-color: #ffffff;
            color: #000000;
            border-radius: 20px;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: inherit;
            height: 40px;
            min-width: 80px;
        }

        .btn:hover {
            background-color: #000000;
            color: #ffffff;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: #ffffff;
            color: #000000;
        }

        .btn:disabled:hover {
            background-color: #ffffff;
            color: #000000;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            font-weight: 600;
            font-size: 0.9rem;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            min-width: 200px;
            text-align: center;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        @keyframes incorrect-shake {
            0% { transform: translate3d(0, 0, 0); }
            25% { transform: translate3d(-5px, 0, 0); }
            50% { transform: translate3d(5px, 0, 0); }
            75% { transform: translate3d(-5px, 0, 0); }
            100% { transform: translate3d(0, 0, 0); }
        }

        .word-tile.incorrect-guess {
            animation: incorrect-shake 0.4s cubic-bezier(0.36, 0.07, 0.19, 0.97);
            will-change: transform;
        }

        @keyframes hop {
            0% { transform: translate3d(0, 0, 0); }
            50% { transform: translate3d(0, -8px, 0); }
            100% { transform: translate3d(0, 0, 0); }
        }

        .word-tile.hop {
            animation: hop 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            will-change: transform;
        }

        .word-tile.moving {
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            will-change: transform;
        }

        @keyframes subtle-shake-1 {
            0%, 100% { transform: translate3d(0, 0, 0); }
            25% { transform: translate3d(-1px, 0, 0); }
            75% { transform: translate3d(1px, 0, 0); }
        }

        @keyframes subtle-shake-2 {
            0%, 100% { transform: translate3d(0, 0, 0); }
            33% { transform: translate3d(0, -1px, 0); }
            66% { transform: translate3d(0, 1px, 0); }
        }

        @keyframes subtle-shake-3 {
            0%, 100% { transform: translate3d(0, 0, 0); }
            20% { transform: translate3d(-1px, 0, 0); }
            40% { transform: translate3d(1px, -1px, 0); }
            60% { transform: translate3d(0, 1px, 0); }
            80% { transform: translate3d(1px, 0, 0); }
        }

        @keyframes subtle-shake-4 {
            0%, 100% { transform: rotate3d(0, 0, 1, 0deg); }
            25% { transform: rotate3d(0, 0, 1, -0.5deg); }
            75% { transform: rotate3d(0, 0, 1, 0.5deg); }
        }

        .word-tile.victory-shake {
            animation: subtle-shake-1 2s ease-in-out infinite;
            cursor: pointer;
            position: relative;
        }

        .word-tile.victory-shake:hover {
            animation-duration: 1s;
            background-color: #e5e5dc;
            border-color: #d5d5cc;
        }

        .attempt-cell.victory-shake {
            cursor: pointer;
            position: relative;
        }

        .attempt-cell.victory-shake:hover {
            animation-duration: 1s !important;
            transform: scale(1.1);
            z-index: 10;
        }

        .attempts-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin: 20px auto;
            max-width: 200px;
        }

        .attempt-cell {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            border-radius: 4px;
            background-color: #ddd;
            opacity: 1;
            transform: scale(1);
            will-change: transform, opacity;
            backface-visibility: hidden;
        }

        /* Override for colored cells */
        .attempts-grid .attempt-cell[data-bg-color] {
            background-color: attr(data-bg-color) !important;
        }
        
        .attempts-grid .attempt-cell[data-color="yellow"] {
            background-color: #f9df84 !important;
        }
        
        .attempts-grid .attempt-cell[data-color="green"] {
            background-color: #a0c35a !important;
        }
        
        .attempts-grid .attempt-cell[data-color="blue"] {
            background-color: #b0c4ef !important;
        }
        
        .attempts-grid .attempt-cell[data-color="purple"] {
            background-color: #ba81c5 !important;
        }

        /* Shaking animation for special cells */
        .attempt-cell.shake-link {
            cursor: pointer;
            animation: shake-subtle 2s ease-in-out infinite;
        }

        .attempt-cell.shake-link:hover {
            animation-duration: 1s;
            transform: scale(1.05);
        }

        @keyframes shake-subtle {
            0%, 100% { transform: translate3d(0, 0, 0); }
            25% { transform: translate3d(-1px, 0, 0); }
            75% { transform: translate3d(1px, 0, 0); }
        }



        @keyframes cellAppear {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .attempt-row {
            display: contents;
        }

        .attempt-cell.animate {
            opacity: 0;
            transform: scale(0.9);
            animation: cellAppear 0.3s ease-out forwards;
            animation-delay: calc(var(--row-index) * 0.1s + var(--cell-index) * 0.05s);
        }

        .completion-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin: 20px auto;
            max-width: 200px;
        }

        .completion-cell {
            width: 100%;
            padding-bottom: 100%;
            position: relative;
            border-radius: 4px;
        }

        .completion-cell span {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.9rem;
            text-align: center;
            width: 90%;
            word-break: break-word;
            line-height: 1.1;
        }

        .completion-grid-link {
            text-decoration: none;
            display: block;
            transition: transform 0.3s ease;
        }

        .completion-grid-link:hover {
            transform: scale(1.05);
            z-index: 1;
        }

        .game-over {
            text-align: center;
            padding: 30px;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -40%);
            z-index: 1000;
            min-width: 300px;
            max-width: 90%;
        }

        .game-over.show {
            opacity: 1;
            transform: translate(-50%, -50%);
            pointer-events: auto;
        }

        .game-over h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            color: #333;
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.2s forwards;
        }

        .game-over p {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 20px;
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.3s forwards;
        }

        .game-over .btn {
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.4s forwards;
        }

        @media (max-width: 640px) {
            .main-content {
                padding: 16px 0;
            }
            
            .container {
                padding: 0 16px;
            }
            
            .header-content {
                padding: 0 16px;
            }
            
            .title {
                font-size: 30px;
            }
            
            .word-tile {
                font-size: 12px;
                height: 48px;
                padding: 6px;
            }

            .play-button {
                width: 28px;
                height: 28px;
                font-size: 14px;
            }

            .show-play-buttons .play-button {
                display: flex;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
                gap: 8px;
            }
            
            .btn {
                width: 100%;
                max-width: 200px;
            }
            
            .word-grid {
                gap: 6px;
                min-height: calc(4 * (48px + 6px));
            }

            .group-block {
                height: 48px;
                padding: 8px;
            }
        }

        .show-play-buttons .play-button {
            display: flex;
        }

        .group-block {
            grid-column: span 4;
            background-color: #a0c35a;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
            color: #fff;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            height: 56px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .group-block.new-group {
            animation: groupAppear 0.5s ease-out;
        }

        @keyframes groupAppear {
            from {
                transform: translateY(20px) scale(0.95);
                opacity: 0;
            }
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .group-block.yellow {
            background-color: #f9df84;
            color: #121212;
        }

        .group-block.green {
            background-color: #a0c35a;
            color: #ffffff;
        }

        .group-block.blue {
            background-color: #b0c4ef;
            color: #121212;
        }

        .group-block.purple {
            background-color: #ba81c5;
            color: #ffffff;
        }

        .group-category {
            font-size: 14px;
            margin-bottom: 2px;
            font-weight: 700;
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.2s forwards;
            line-height: 1;
            color: #121212;
        }

        .group-words {
            font-size: 12px;
            opacity: 0;
            font-weight: 400;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.3s forwards;
            line-height: 1;
            color: #121212;
        }

        @keyframes textAppear {
            to {
                opacity: 0.9;
                transform: translateY(0);
            }
        }

        .cooldown-timer {
            font-size: 1rem;
            margin: 15px 0;
            color: #666;
        }
        
        /* Early Access Popup - Match game-over popup style */
        .early-access-popup {
            text-align: center;
            padding: 30px;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -40%);
            z-index: 1000;
            min-width: 300px;
            max-width: 90%;
            display: none;
        }
        
        .early-access-popup.show {
            opacity: 1;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            display: block;
        }
        
        .early-access-popup h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            color: #333;
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.2s forwards;
        }
        
        .early-access-popup p {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 20px;
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.3s forwards;
        }
        
        .early-access-popup .btn {
            opacity: 0;
            transform: translateY(10px);
            animation: textAppear 0.3s ease-out 0.4s forwards;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <h1 class="title">Sonnections</h1>
            <p class="subtitle">Create four groups of four!</p>
        </div>
    </header>

    <main class="main-content">
        <div class="container">
            <div class="toast" id="toast"></div>
            <div class="word-grid" id="wordGrid"></div>

            <div class="mistakes-section">
                <div class="mistakes">
                    Mistakes remaining:
                    <div class="mistake-dots">
                        <div class="mistake-dot" id="dot4"></div>
                        <div class="mistake-dot" id="dot3"></div>
                        <div class="mistake-dot" id="dot2"></div>
                        <div class="mistake-dot" id="dot1"></div>
                    </div>
                </div>
            </div>

            <div class="timer-section" id="timerSection">
                Next attempt available in: <span id="timer">00:00:00</span>
            </div>

            <div class="controls">
                <button class="btn" id="shuffleBtn">Shuffle</button>
                <button class="btn" id="deselectBtn">Deselect All</button>
                <button class="btn" id="submitBtn" disabled>Submit</button>
            </div>

            <div class="game-over" id="gameOver">
                <h2 id="gameOverTitle">Game Over!</h2>
                <p id="gameOverMessage"></p>
                <div class="cooldown-timer" id="cooldownTimer"></div>
                <button class="btn" id="playAgainBtn">Play Again</button>
            </div>
        </div>
    </main>

    <script>
        // Game data
        const gameData = {
            groups: [
                    {
                        category: "\"CAFE\" SPELLED MUSICALLY",
                        words: ["GUITAR", "HARMONIUM", "ORCHESTRA", "PIANO"],
                        audioFiles: ["https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/guitar.mp3", "https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/harmonium.mp3", "https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/orchestra.mp3", "https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/piano.mp3"],
                        color: "yellow",
                        difficulty: 1
                    },
                    {
                        category: "WORKPLACE AMBIENCE",
                        words: ["SLACK NOTIFICATION", "TYPING", "GOOGLE MEET", "MICROWAVE"],
                        audioFiles: ["https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/slack.mp3", "https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/typing.mp3", "https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/gmeet.mp3", "https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/microwave.mp3"],
                        color: "green",
                        difficulty: 2
                    },
                    {
                        category: "SOUNDS LIKE BANGALORE",
                        words: ["NAMMA YATRI", "MONSOON", "AUTO RICKSHAW", "GPAY"],
                        audioFiles: ["https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/namma-yatri.mp3", "https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/monsoon.mp3", "https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/auto.mp3", "https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/gpay.mp3"],
                        color: "blue",
                        difficulty: 3
                    },
                    {
                        category: "SOUNDS ALSO MADE BY GEESE",
                        words: ["HONK", "HISS", "TRUMPET", "CHATTER"],
                        audioFiles: ["https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/honk.mp3", "https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/hiss.mp3", "https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/trumpet.mp3", "https://raw.githubusercontent.com/hat-im/hat-im.github.io/69fd20e412a394c31337361b6ea988af7bd01852/audio/chatter.mp3"],
                        color: "purple",
                        difficulty: 4
                    }
                ]
            };

        // Flag to control next puzzle access
        const NEXT_PUZZLES_ENABLED = false; // Set to true to enable all next puzzles
        
        // Game state
        let gameState = {
            words: [],
            wordToAudio: new Map(), // Map words to their audio files
            audioInstances: new Map(), // Map words to their audio instances
            selectedWords: [],
            foundGroups: [],
            completionOrder: [],
            mistakes: 0,
            maxMistakes: 4,
            gameOver: false,
            previousGuesses: new Set(), // Track previous incorrect guesses
            lastAttemptTime: null, // Track when the last attempt was made
            timerInterval: null, // Track the timer interval
            attempts: [], // Track all attempts with their colors
            playButtonsShown: false, // Track if play buttons have been shown
            firstSelectionMade: false // Track if first selection has been made
        };

        // Audio management
        function playSound(word, audioFile) {
            try {
                // Stop any currently playing audio for this word
                if (gameState.audioInstances.has(word)) {
                    const existingAudio = gameState.audioInstances.get(word);
                    existingAudio.pause();
                    existingAudio.currentTime = 0;
                }
                
                const audio = new Audio(audioFile);
                audio.volume = 0.7;
                
                // Store the audio instance
                gameState.audioInstances.set(word, audio);
                
                // Update button state when audio starts playing
                audio.addEventListener('play', () => {
                    updatePlayButtonState(word, 'playing');
                });
                
                // Update button state when audio ends
                audio.addEventListener('ended', () => {
                    updatePlayButtonState(word, 'stopped');
                    gameState.audioInstances.delete(word);
                });
                
                // Update button state when audio is paused
                audio.addEventListener('pause', () => {
                    updatePlayButtonState(word, 'stopped');
                });
                
                audio.play().catch(e => {
                    console.warn('Could not play audio:', audioFile, e);
                    updatePlayButtonState(word, 'stopped');
                });
            } catch (e) {
                console.warn('Audio error:', e);
            }
        }
        
        function stopSound(word) {
            if (gameState.audioInstances.has(word)) {
                const audio = gameState.audioInstances.get(word);
                audio.pause();
                audio.currentTime = 0;
                updatePlayButtonState(word, 'stopped');
                gameState.audioInstances.delete(word);
            }
        }
        
        function updatePlayButtonState(word, state) {
            const tiles = document.querySelectorAll('.word-tile');
            tiles.forEach(tile => {
                const hiddenWordEl = tile.querySelector('.hidden-word');
                const playButton = tile.querySelector('.play-button');
                if (hiddenWordEl && hiddenWordEl.textContent === word && playButton) {
                    if (state === 'playing') {
                        playButton.innerHTML = '⏸'; // Pause/stop symbol
                        playButton.classList.add('playing');
                    } else {
                        playButton.innerHTML = '▶'; // Play symbol
                        playButton.classList.remove('playing');
                    }
                }
            });
        }

        // DOM elements
        const wordGrid = document.getElementById('wordGrid');
        const toastEl = document.getElementById('toast');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const deselectBtn = document.getElementById('deselectBtn');
        const submitBtn = document.getElementById('submitBtn');
        const gameOverEl = document.getElementById('gameOver');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const cooldownTimer = document.getElementById('cooldownTimer');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const timerSection = document.getElementById('timerSection');
        const timerEl = document.getElementById('timer');

        // Check if user is in cooldown period
        function isInCooldown() {
            const lastAttempt = localStorage.getItem('sonnections_lastAttemptTime');
            if (!lastAttempt) return false;

            const now = new Date().getTime();
            const timeDiff = now - parseInt(lastAttempt);
            return timeDiff < 3600000; // 1 hour in milliseconds
        }

        // Update cooldown timer display
        function updateCooldownTimer() {
            const lastAttempt = localStorage.getItem('sonnections_lastAttemptTime');
            if (!lastAttempt) return;

            const now = new Date().getTime();
            const timeDiff = now - parseInt(lastAttempt);
            const timeLeft = Math.max(3600000 - timeDiff, 0);

            if (timeLeft === 0) {
                cooldownTimer.textContent = '';
                playAgainBtn.disabled = false;
                playAgainBtn.textContent = 'Play Again';
                clearInterval(gameState.timerInterval);
                return;
            }

            const hours = Math.floor(timeLeft / 3600000);
            const minutes = Math.floor((timeLeft % 3600000) / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);

            cooldownTimer.textContent = `Next game available in: ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            playAgainBtn.disabled = true;
            playAgainBtn.textContent = 'Please Wait';
        }

        // Show toast message
        function showToast(message) {
            // Clear any existing timeout
            if (window.toastTimeout) {
                clearTimeout(window.toastTimeout);
            }
            
            toastEl.textContent = message;
            toastEl.className = 'toast show';
            
            window.toastTimeout = setTimeout(() => {
                toastEl.className = 'toast';
            }, 2000);
        }
        
        // Show early access popup
        function showEarlyAccessPopup() {
            const popup = document.getElementById('early-access-popup');
            popup.classList.add('show');
        }
        
        // Close early access popup
        function closeEarlyAccessPopup() {
            const popup = document.getElementById('early-access-popup');
            popup.classList.remove('show');
        }

        // Initialize game
        function initGame() {
            // Check if we're in cooldown from a previous loss
            if (isInCooldown()) {
                showGameOverScreen(false, true);
                return;
            }

            // Reset game state
            gameState = {
                words: [],
                wordToAudio: new Map(),
                audioInstances: new Map(),
                selectedWords: [],
                foundGroups: [],
                completionOrder: [],
                mistakes: 0,
                maxMistakes: 4,
                gameOver: false,
                previousGuesses: new Set(),
                lastAttemptTime: null,
                timerInterval: null,
                attempts: [],
                playButtonsShown: false,
                firstSelectionMade: false
            };

            // Clear saved attempts when starting new game
            localStorage.removeItem('sonnections_lastAttempts');

            // Flatten all words and shuffle, also create word-to-audio mapping
            gameState.words = [];
            gameData.groups.forEach(group => {
                group.words.forEach((word, index) => {
                    gameState.words.push(word);
                    gameState.wordToAudio.set(word, group.audioFiles[index]);
                });
            });
            shuffleArray(gameState.words);

            // Reset UI
            toastEl.className = 'toast';
            gameOverEl.className = 'game-over';
            updateMistakesDisplay();
            renderWordGrid();
            updateControls();
        }

        // Shuffle array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Optimized render word grid with reduced DOM manipulation
        function renderWordGrid() {
            const currentTiles = wordGrid.querySelectorAll('.word-tile');
            const currentWords = Array.from(currentTiles).map(tile => {
                const hiddenWordElement = tile.querySelector('.hidden-word');
                return hiddenWordElement ? hiddenWordElement.textContent : tile.textContent;
            });
            
            // Get remaining words (not found yet) - use Set for faster lookup
            const foundWords = new Set(gameState.foundGroups.flatMap(group => group.words));
            const remainingWords = gameState.words.filter(word => !foundWords.has(word));
            const selectedWordsSet = new Set(gameState.selectedWords);
            
            // Update existing tiles if possible (but only if order is also the same)
            if (currentWords.length === remainingWords.length && 
                currentWords.every((word, index) => word === remainingWords[index])) {
                // Just update selection states - words are in same order
                currentTiles.forEach(tile => {
                    const hiddenWordElement = tile.querySelector('.hidden-word');
                    const word = hiddenWordElement ? hiddenWordElement.textContent : tile.textContent;
                    tile.classList.toggle('selected', selectedWordsSet.has(word));
                });
            } else {
                // Full re-render needed - use DocumentFragment for better performance
                const fragment = document.createDocumentFragment();
                
                // Add found groups first (at the top) - preserve existing groups
                gameState.foundGroups.forEach((group, index) => {
                    const groupBlock = document.createElement('div');
                    groupBlock.className = `group-block ${group.color}`;
                    
                    groupBlock.innerHTML = `
                        <div class="group-category">${group.category}</div>
                        <div class="group-words">${group.words.join(', ')}</div>
                    `;
                    
                    fragment.appendChild(groupBlock);
                });
                
                // Add remaining word tiles below the groups
                remainingWords.forEach(word => {
                    const tile = document.createElement('div');
                    tile.className = `word-tile${selectedWordsSet.has(word) ? ' selected' : ''}`;
                    
                    // Create play button
                    const playButton = document.createElement('button');
                    playButton.className = 'play-button';
                    playButton.innerHTML = '▶';
                    playButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (gameState.audioInstances.has(word)) {
                            // Audio is playing, stop it
                            stopSound(word);
                        } else {
                            // Audio is not playing, start it
                            playSound(word, gameState.wordToAudio.get(word));
                        }
                    });
                    
                    // Create hidden word element for reference
                    const hiddenWord = document.createElement('span');
                    hiddenWord.className = 'hidden-word';
                    hiddenWord.textContent = word;
                    
                    tile.appendChild(playButton);
                    tile.appendChild(hiddenWord);
                    tile.addEventListener('click', () => selectWord(word), { passive: true });
                    
                    fragment.appendChild(tile);
                });
                
                // Single DOM update
                wordGrid.innerHTML = '';
                wordGrid.appendChild(fragment);
            }
        }

        // Select/deselect word
        function selectWord(word) {
            if (gameState.gameOver) return;
            
            // Check if word is already found
            const isFound = gameState.foundGroups.some(group => 
                group.words.includes(word)
            );
            if (isFound) return;

            const index = gameState.selectedWords.indexOf(word);
            
            if (index > -1) {
                // Deselect word
                gameState.selectedWords.splice(index, 1);
            } else if (gameState.selectedWords.length < 4) {
                // Select word and only play sound on very first selection
                gameState.selectedWords.push(word);
                if (!gameState.firstSelectionMade) {
                    playSound(word, gameState.wordToAudio.get(word));
                    gameState.firstSelectionMade = true;
                }
            }
            
            // Show play buttons when any word is selected for the first time
            if (gameState.selectedWords.length > 0 && !gameState.playButtonsShown) {
                wordGrid.classList.add('show-play-buttons');
                gameState.playButtonsShown = true;
            }
            
            renderWordGrid();
            updateControls();
        }

        // Update control buttons
        function updateControls() {
            submitBtn.disabled = gameState.selectedWords.length !== 4;
            deselectBtn.disabled = gameState.selectedWords.length === 0;
        }

        // Shuffle words with optimized performance
        function shuffleWords() {
            // Get remaining words (not found yet) - use cached check for better performance
            const foundWords = new Set(gameState.foundGroups.flatMap(group => group.words));
            const remainingWords = gameState.words.filter(word => !foundWords.has(word));
            
            // Shuffle only the remaining words
            shuffleArray(remainingWords);
            
            // Update the words array with found groups first, then shuffled remaining
            gameState.words = [
                ...gameState.foundGroups.flatMap(group => group.words),
                ...remainingWords
            ];
            
            // Clear selections when shuffling
            gameState.selectedWords.length = 0; // More efficient than reassigning
            
            // Use requestAnimationFrame for smoother rendering
            requestAnimationFrame(() => {
                wordGrid.innerHTML = '';
                renderWordGrid();
                updateControls();
            });
        }

        // Deselect all words
        function deselectAll() {
            gameState.selectedWords = [];
            // Don't hide play buttons once they've been shown
            renderWordGrid();
            updateControls();
        }

        // Submit guess
        function submitGuess() {
            if (gameState.selectedWords.length !== 4) return;

            // Sort selected words to ensure consistent comparison
            const sortedGuess = [...gameState.selectedWords].sort().join(',');

            // Check if this guess was already tried
            if (gameState.previousGuesses.has(sortedGuess)) {
                showToast('Already guessed');
                gameState.selectedWords = [];
                // Don't hide play buttons once they've been shown
                renderWordGrid();
                updateControls();
                return;
            }

            // Check if this combination forms a valid group
            const correctGroup = gameData.groups.find(group => 
                gameState.selectedWords.every(word => group.words.includes(word)) &&
                gameState.selectedWords.length === 4
            );

            if (correctGroup) {
                // Animate correct guess sequence
                animateCorrectGuess(correctGroup);
            } else {
                // Add to previous guesses
                gameState.previousGuesses.add(sortedGuess);

                // Find the group that has the most matches with the selected words
                let bestMatch = null;
                let maxMatches = 0;
                gameData.groups.forEach(group => {
                    const matches = gameState.selectedWords.filter(word => 
                        group.words.includes(word)
                    ).length;
                    if (matches > maxMatches) {
                        maxMatches = matches;
                        bestMatch = group;
                    }
                });

                // Track the attempt with colors in order
                const selectedColors = gameState.selectedWords.map(word => {
                    // Find which group this word belongs to
                    const group = gameData.groups.find(g => g.words.includes(word));
                    return group ? group.color : 'gray';
                });
                gameState.attempts.push({
                    words: [...gameState.selectedWords],
                    colors: selectedColors,
                    correct: false
                });

                // Check if "one away" (3 out of 4 words are correct)
                const oneAwayGroup = gameData.groups.find(group => {
                    const matchingWords = gameState.selectedWords.filter(word => 
                        group.words.includes(word)
                    );
                    return matchingWords.length === 3;
                });

                if (oneAwayGroup) {
                    showToast('One away');
                }

                // Shake the selected tiles for incorrect guess - optimized cleanup
                const selectedTiles = document.querySelectorAll('.word-tile.selected');
                selectedTiles.forEach(tile => {
                    tile.classList.add('incorrect-guess');
                    // Use requestAnimationFrame for smoother cleanup
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            tile.classList.remove('incorrect-guess');
                        }, 400);
                    });
                });

                // Incorrect guess
                gameState.mistakes++;
                // Don't clear selectedWords - keep them selected
                
                updateMistakesDisplay();
                // Don't re-render grid to maintain selection state
                
                // Check if game is lost
                if (gameState.mistakes >= gameState.maxMistakes) {
                    // Store the loss time and attempts in localStorage
                    localStorage.setItem('sonnections_lastAttemptTime', new Date().getTime().toString());
                    localStorage.setItem('sonnections_lastAttempts', JSON.stringify(gameState.attempts));
                    endGame(false);
                }
            }
            
            updateControls();
        }

async function animateCorrectGuess(correctGroup) {
    const selectedTiles = Array.from(document.querySelectorAll('.word-tile.selected'));
    
    // Step 1: Hop animation - each tile hops one at a time with optimized timing
    const hopPromises = selectedTiles.map((tile, i) => {
        return new Promise(resolve => {
            setTimeout(() => {
                tile.classList.add('hop');
                // Use requestAnimationFrame for smoother cleanup
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        tile.classList.remove('hop');
                        resolve();
                    }, 300);
                });
            }, i * 100);
        });
    });
    
    await Promise.all(hopPromises);
    
    // Step 2: Calculate target row and positions
    const grid = document.getElementById('wordGrid');
    const gridRect = grid.getBoundingClientRect();
    const allTiles = Array.from(grid.querySelectorAll('.word-tile'));
    
    // Target row is right after existing groups (at index gameState.foundGroups.length)
    const targetRowIndex = gameState.foundGroups.length;
    
    // Calculate the exact grid positions for the target row
    const targetPositions = [];
    const tileHeight = selectedTiles[0].offsetHeight;
    const tileWidth = selectedTiles[0].offsetWidth;
    const gap = 8; // CSS gap value
    
    for (let col = 0; col < 4; col++) {
        const x = gridRect.left + col * (tileWidth + gap);
        const y = gridRect.top + targetRowIndex * (tileHeight + gap);
        targetPositions.push({ x, y });
    }
    
    // Step 3: Find tiles that are exactly in the target row positions
    const tilesToDisplace = [];
    const swapAnimations = [];
    
    // Get all non-selected tiles currently in the target row
    const tilesInTargetRow = allTiles.filter(tile => {
        if (tile.classList.contains('selected')) return false;
        
        const tileRect = tile.getBoundingClientRect();
        const tileRowIndex = Math.round((tileRect.top - gridRect.top) / (tileHeight + gap));
        
        // Only include tiles that are exactly in the target row
        return tileRowIndex === targetRowIndex;
    });
    
    // These are the tiles that need to be displaced
    tilesToDisplace.push(...tilesInTargetRow);
    
    // Move selected tiles to target row
    selectedTiles.forEach((selectedTile, index) => {
        const selectedRect = selectedTile.getBoundingClientRect();
        const targetPos = targetPositions[index];
        
        const deltaX = targetPos.x - selectedRect.left;
        const deltaY = targetPos.y - selectedRect.top;
        
        selectedTile.classList.add('moving');
        selectedTile.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
    });
    
    // Calculate exact destination positions for displaced tiles
    const remainingTiles = allTiles.filter(tile => 
        !tile.classList.contains('selected') && 
        !tilesToDisplace.includes(tile)
    );
    
    // Create a list of all available positions after the target row
    const availablePositions = [];
    for (let row = targetRowIndex + 1; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
            const x = gridRect.left + col * (tileWidth + gap);
            const y = gridRect.top + row * (tileHeight + gap);
            availablePositions.push({ x, y, row, col });
        }
    }
    
    // First, account for tiles that are already in correct positions and don't need to move
    const occupiedPositions = new Set();
    remainingTiles.forEach(tile => {
        const tileRect = tile.getBoundingClientRect();
        availablePositions.forEach((pos, index) => {
            if (Math.abs(tileRect.left - pos.x) < 10 && Math.abs(tileRect.top - pos.y) < 10) {
                occupiedPositions.add(index);
            }
        });
    });
    
    // Assign displaced tiles to the first available positions
    let assignmentIndex = 0;
    tilesToDisplace.forEach((displacedTile) => {
        // Find next available position
        while (assignmentIndex < availablePositions.length && occupiedPositions.has(assignmentIndex)) {
            assignmentIndex++;
        }
        
        if (assignmentIndex < availablePositions.length) {
            const targetPos = availablePositions[assignmentIndex];
            const tileRect = displacedTile.getBoundingClientRect();
            
            const deltaX = targetPos.x - tileRect.left;
            const deltaY = targetPos.y - tileRect.top;
            
            displacedTile.classList.add('moving');
            displacedTile.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            swapAnimations.push({ targetTile: displacedTile });
            
            // Mark this position as occupied
            occupiedPositions.add(assignmentIndex);
            assignmentIndex++;
        }
    });
    
    // Wait for movement animation to complete
    await new Promise(resolve => setTimeout(resolve, 600));
    
    // Step 4: Update game state
    gameState.foundGroups.push(correctGroup);
    gameState.completionOrder.push(correctGroup.color);
    gameState.attempts.push({
        words: [...gameState.selectedWords],
        colors: gameState.selectedWords.map(() => correctGroup.color),
        correct: true
    });
    gameState.selectedWords = [];
    
    // Don't hide play buttons once they've been shown
    
    // Step 5: Clean up transforms first, THEN modify DOM
    selectedTiles.forEach(tile => {
        tile.classList.remove('moving', 'selected');
        tile.style.transform = '';
    });
    
    swapAnimations.forEach(({ targetTile }) => {
        targetTile.classList.remove('moving');
        targetTile.style.transform = '';
    });
    
    // Wait a frame to ensure transforms are cleared
    await new Promise(resolve => requestAnimationFrame(resolve));
    
    // Step 6: Temporarily disable transitions to prevent second movement
    const allRemainingTiles = wordGrid.querySelectorAll('.word-tile:not(.selected)');
    allRemainingTiles.forEach(tile => {
        tile.style.transition = 'none';
    });
    
    // Now remove tiles and insert group block
    selectedTiles.forEach(tile => {
        tile.remove();
    });
    
    // Create the new group block
    const groupBlock = document.createElement('div');
    groupBlock.className = `group-block ${correctGroup.color} new-group`;
    
    const categoryEl = document.createElement('div');
    categoryEl.className = 'group-category';
    categoryEl.textContent = correctGroup.category;
    
    const wordsEl = document.createElement('div');
    wordsEl.className = 'group-words';
    wordsEl.textContent = correctGroup.words.join(', ');
    
    groupBlock.appendChild(categoryEl);
    groupBlock.appendChild(wordsEl);
    
    // Insert at the correct position
    const firstTile = wordGrid.querySelector('.word-tile');
    
    if (firstTile) {
        wordGrid.insertBefore(groupBlock, firstTile);
    } else {
        wordGrid.appendChild(groupBlock);
    }
    
    // Re-enable transitions after a frame
    requestAnimationFrame(() => {
        allRemainingTiles.forEach(tile => {
            if (tile.parentNode) { // Check if tile still exists
                tile.style.transition = '';
            }
        });
    });
    
    // Remove the animation class after animation completes
    setTimeout(() => {
        groupBlock.classList.remove('new-group');
    }, 500);
    
    updateControls();
    
    // Check if game is won
    if (gameState.foundGroups.length === 4) {
        endGame(true);
    }
}

        // Update mistakes display
        function updateMistakesDisplay() {            
            for (let i = 1; i <= 4; i++) {
                const dot = document.getElementById(`dot${i}`);
                if (i <= gameState.mistakes) {
                    dot.classList.add('used');
                } else {
                    dot.classList.remove('used');
                }
            }
        }

        // Show game over screen
        function showGameOverScreen(won, fromCooldown = false) {
            gameState.gameOver = true;
            
            // Clear any existing grids from previous games (but only from inside game-over element)
            const existingGrids = gameOverEl.querySelectorAll('.attempts-grid, .completion-grid');
            existingGrids.forEach(grid => grid.remove());
            
            if (won) {
                gameOverTitle.textContent = 'Congratulations!';
                gameOverMessage.textContent = 'You found all the sonnections!';
                playAgainBtn.disabled = false;
                playAgainBtn.textContent = 'Play Again';
                cooldownTimer.textContent = '';
                // Clear saved attempts when user wins
                localStorage.removeItem('sonnections_lastAttempts');
                // Mark sonnections as completed
                localStorage.setItem('sonnections_completed', 'true');
            } else {
                gameOverTitle.textContent = 'Game Over';
                gameOverMessage.textContent = 'Better luck next time!';
                
                if (fromCooldown) {
                    // Start the cooldown timer
                    updateCooldownTimer();
                    gameState.timerInterval = setInterval(updateCooldownTimer, 1000);
                } else {
                    // Start the cooldown timer
                    updateCooldownTimer();
                    gameState.timerInterval = setInterval(updateCooldownTimer, 1000);
                }
            }

            // For losers, always try to show saved attempts grid first
            let attemptsToShow = gameState.attempts;
            if (!won && fromCooldown) {
                const savedAttempts = localStorage.getItem('sonnections_lastAttempts');
                if (savedAttempts) {
                    try {
                        attemptsToShow = JSON.parse(savedAttempts);
                    } catch (e) {
                        console.warn('Failed to parse saved attempts:', e);
                    }
                }
            }

            // Always show attempts grid at the end
            if (attemptsToShow && attemptsToShow.length > 0) {
                const attemptsGrid = document.createElement('div');
                attemptsGrid.className = 'attempts-grid';
                
                attemptsToShow.forEach((attempt, rowIndex) => {
                    const attemptRow = document.createElement('div');
                    attemptRow.className = 'attempt-row';
                    
                    attempt.colors.forEach((color, cellIndex) => {
                        const cell = document.createElement('div');
                        cell.className = 'attempt-cell';
                        
                        const bgColor = getColorCode(color);
                        
                        // Try multiple approaches to ensure color is set
                        cell.style.backgroundColor = bgColor;
                        cell.style.background = bgColor;
                        cell.setAttribute('data-color', color);
                        cell.setAttribute('data-bg-color', bgColor);
                        
                        // Store cell reference for later link assignment
                        cell.globalIndex = rowIndex * 4 + cellIndex;
                        
                        cell.style.setProperty('--row-index', rowIndex);
                        cell.style.setProperty('--cell-index', cellIndex);
                        attemptRow.appendChild(cell);
                    });
                    
                    attemptsGrid.appendChild(attemptRow);
                });
                
                gameOverMessage.insertAdjacentElement('afterend', attemptsGrid);
                
                // Only add shaking links if the user won
                if (won) {
                    const allCells = Array.from(attemptsGrid.querySelectorAll('.attempt-cell'));
                    const totalCells = allCells.length;
                    
                    if (totalCells >= 2) {
                        // Randomly select 2 different cell indices
                        const selectedIndices = [];
                        while (selectedIndices.length < 2) {
                            const randomIndex = Math.floor(Math.random() * totalCells);
                            if (!selectedIndices.includes(randomIndex)) {
                                selectedIndices.push(randomIndex);
                            }
                        }
                        
                        // Define links for the 2 special cells
                        const specialLinks = [
                            'connect1ons.html',
                            'wordle.html'
                        ];
                        
                        selectedIndices.forEach((cellIndex, linkIndex) => {
                            const cell = allCells[cellIndex];
                            cell.classList.add('shake-link');
                            
                            cell.addEventListener('click', () => {
                                const link = specialLinks[linkIndex];
                                if (!NEXT_PUZZLES_ENABLED) {
                                    showEarlyAccessPopup();
                                } else {
                                    window.open(link, '_blank');
                                }
                            });
                        });
                    }
                }
            }

            // Use groups in the order they were solved (preserve existing layout)
            const solvedGroups = gameState.foundGroups;
            
            // Clear the word grid
            wordGrid.innerHTML = '';
            
            // Add all groups in the order they were solved
            solvedGroups.forEach(group => {
                const groupBlock = document.createElement('div');
                groupBlock.className = `group-block ${group.color}`;
                
                const categoryEl = document.createElement('div');
                categoryEl.className = 'group-category';
                categoryEl.textContent = group.category;
                
                const wordsEl = document.createElement('div');
                wordsEl.className = 'group-words';
                wordsEl.textContent = group.words.join(', ');
                
                groupBlock.appendChild(categoryEl);
                groupBlock.appendChild(wordsEl);
                wordGrid.appendChild(groupBlock);
            });
            
            // Show the game over screen
            gameOverEl.className = 'game-over show';
            
            // Ensure all attempt cells are visible with optimized DOM manipulation
            requestAnimationFrame(() => {
                const attemptsGrid = gameOverEl.querySelector('.attempts-grid');
                if (attemptsGrid) {
                    attemptsGrid.style.display = 'grid';
                    // Batch DOM updates for better performance
                    const attemptCells = attemptsGrid.querySelectorAll('.attempt-cell');
                    attemptCells.forEach(cell => {
                        cell.style.cssText = 'opacity: 1; transform: scale(1);';
                    });
                }
            });
        }

        // End game
        function endGame(won) {
            showGameOverScreen(won);
        }


        // Helper function to get color codes
        function getColorCode(color) {
            const colorMap = {
                'yellow': '#f9df84',
                'green': '#a0c35a',
                'blue': '#b0c4ef',
                'purple': '#ba81c5'
            };
            return colorMap[color] || '#999';
        }

        // Event listeners
        shuffleBtn.addEventListener('click', shuffleWords);
        deselectBtn.addEventListener('click', deselectAll);
        submitBtn.addEventListener('click', submitGuess);
        playAgainBtn.addEventListener('click', initGame);

        // Initialize game on load
        initGame();
    </script>
    
    <!-- Early Access Popup -->
    <div class="early-access-popup" id="early-access-popup">
        <h2>You Found It!</h2>
        <p>No harmony escapes you!<br><br>Your ears have led you to something still in harmony.</p>
        <p style="font-style: italic; font-size: 1rem; color: #999;">The next movement hasn't been composed yet...</p>
        <button class="btn" onclick="closeEarlyAccessPopup()">I hear you</button>
    </div>
</body>
</html>