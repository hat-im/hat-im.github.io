<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sonnections</title>
    <link
      rel="icon"
      type="image/x-icon"
      href="https://raw.githubusercontent.com/hat-im/hat-im.github.io/main/connections-favicon.ico"
    />
    <style>
      @font-face {
        font-family: "Franklin";
        src: url("https://raw.githubusercontent.com/hat-im/hat-im.github.io/main/fonts/franklin-normal-700.ttf")
          format("truetype");
        font-weight: 700;
        font-style: normal;
      }

      @font-face {
        font-family: "Franklin";
        src: url("https://raw.githubusercontent.com/hat-im/hat-im.github.io/main/fonts/franklin-normal-500.ttf")
          format("truetype");
        font-weight: 500;
        font-style: normal;
      }

      @font-face {
        font-family: "Karnak";
        src: url("https://raw.githubusercontent.com/hat-im/hat-im.github.io/main/fonts/karnak-cond-normal.ttf")
          format("truetype");
        font-weight: 400;
        font-style: normal;
      }

      @font-face {
        font-family: "KarnakNormal";
        src: url("https://raw.githubusercontent.com/hat-im/hat-im.github.io/main/fonts/karnak-normal.woff")
          format("woff");
        font-weight: 400;
        font-style: normal;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Franklin", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 16px;
        font-weight: 500;
        background-color: #ffffff;
        color: #121212;
        line-height: 1.4;
        margin: 0;
        padding: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .header {
        background-color: #ffffff;
        border-bottom: 1px solid #dfdfdf;
        padding: 20px 0;
        position: sticky;
        top: 0;
        z-index: 100;
      }

      .header:nth-of-type(2) {
        z-index: 99;
      }

      .header.help-header {
        padding: 0;
        height: 48px;
        z-index: 98;
      }

      .header-content {
        max-width: 600px;
        margin: 0 auto;
        padding: 0 20px;
        text-align: center;
      }

      .help-bar {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        height: 48px;
        width: 100vw;
        margin-left: calc(-50vw + 50%);
      }

      .help-icon {
        width: 32px;
        height: 32px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.2s ease;
        margin-right: 20px;
      }

      .help-icon:hover {
        opacity: 0.7;
      }

      .help-icon svg {
        --text: #121212;
      }

      .main-content {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 0;
      }

      .container {
        width: fit-content;
        padding: 0;
      }

      .title {
        font-family: "Karnak", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 37px;
        font-weight: 400;
        color: #121212;
        margin: 0;
        letter-spacing: -0.5px;
        line-height: 1;
      }

      .subtitle {
        font-family: "Franklin", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 16px;
        font-weight: 500;
        color: #363636;
        margin: 20px 0;
        line-height: 1.3;
        text-align: center;
      }

      .mistakes-section {
        text-align: center;
        margin: 20px 0;
      }

      .timer-section {
        font-family: "Franklin", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        text-align: center;
        margin: 16px 0;
        color: #363636;
        font-size: 16px;
        font-weight: 500;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .timer-section.show {
        opacity: 1;
      }

      .mistakes {
        font-family: "Franklin", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 16px;
        font-weight: 500;
        color: #121212;
        display: inline-flex;
        align-items: center;
      }

      .mistake-dots {
        display: inline-flex;
        gap: 6px;
        margin-left: 8px;
      }

      .mistake-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: #121212;
        transition: opacity 0.3s ease;
        opacity: 1;
      }

      .mistake-dot.used {
        background-color: #dfdfdf;
        opacity: 1;
      }

      .word-grid {
        display: grid;
        grid-template-columns: repeat(4, 150px);
        gap: 8px;
        margin: 0 auto 24px auto;
        min-height: calc(4 * (80px + 8px));
        width: fit-content;
      }

      .word-tile {
        background-color: #efefe6;
        border: none;
        border-radius: 6px;
        padding: 8px;
        text-align: center;
        font-weight: 700;
        font-size: 20px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        cursor: pointer;
        user-select: none;
        width: 150px;
        height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        will-change: transform, background-color;
        backface-visibility: hidden;
        transform: translateZ(0);
        transition: all 0.15s ease;
        color: #121212;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        position: relative;
      }

      .play-button {
        width: 32px;
        height: 32px;
        border: none;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        transition: all 0.15s ease;
        color: #121212;
        font-size: 16px;
        background: none;
      }

      .play-button:hover {
        transform: scale(1.1);
      }

      .play-button.playing {
        color: #121212;
      }

      .word-tile.selected .play-button {
        color: #ffffff;
      }

      .word-tile.selected .play-button:hover {
        color: #f0f0f0;
      }

      .word-tile.selected .play-button.playing {
        color: #ffffff;
      }

      .hidden-word {
        display: none;
      }

      .word-tile:hover {
        background-color: #e6e6dd;
        transform: scale(1.02);
      }

      .word-tile.selected {
        background-color: #5a594e;
        color: #ffffff;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }

      .word-tile.correct {
        background-color: #a0c35a;
        border-color: #a0c35a;
        color: #fff;
        cursor: default;
        animation: correctTile 0.5s ease-out;
      }

      @keyframes correctTile {
        0% {
          transform: scale(1);
        }
        35% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 12px;
        margin-bottom: 24px;
      }

      .btn {
        font-family: "Franklin", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        padding: 0 16px;
        border: 2px solid #000000;
        background-color: #ffffff;
        color: #000000;
        border-radius: 20px;
        font-weight: 500;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.15s ease;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        height: 40px;
        min-width: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .btn:hover {
        background-color: #000000;
        color: #ffffff;
      }

      .btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        background-color: #ffffff;
        color: #000000;
      }

      .btn:disabled:hover {
        background-color: #ffffff;
        color: #000000;
      }

      .toast {
        font-family: "Franklin", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%) translateY(100%);
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 12px 24px;
        font-weight: 500;
        font-size: 16px;
        opacity: 0;
        transition: all 0.3s ease;
        z-index: 1000;
        min-width: 200px;
        text-align: center;
      }

      .toast.show {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }

      @keyframes incorrect-shake {
        0% {
          transform: translate3d(0, 0, 0);
        }
        25% {
          transform: translate3d(-5px, 0, 0);
        }
        50% {
          transform: translate3d(5px, 0, 0);
        }
        75% {
          transform: translate3d(-5px, 0, 0);
        }
        100% {
          transform: translate3d(0, 0, 0);
        }
      }

      .word-tile.incorrect-guess {
        animation: incorrect-shake 0.4s cubic-bezier(0.36, 0.07, 0.19, 0.97);
        will-change: transform;
      }

      @keyframes hop {
        0% {
          transform: translate3d(0, 0, 0);
        }
        50% {
          transform: translate3d(0, -8px, 0);
        }
        100% {
          transform: translate3d(0, 0, 0);
        }
      }

      .word-tile.hop {
        animation: hop 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        will-change: transform;
      }

      .word-tile.moving {
        transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 10;
        will-change: transform;
      }

      @keyframes subtle-shake-1 {
        0%,
        100% {
          transform: translate3d(0, 0, 0);
        }
        25% {
          transform: translate3d(-1px, 0, 0);
        }
        75% {
          transform: translate3d(1px, 0, 0);
        }
      }

      @keyframes subtle-shake-2 {
        0%,
        100% {
          transform: translate3d(0, 0, 0);
        }
        33% {
          transform: translate3d(0, -1px, 0);
        }
        66% {
          transform: translate3d(0, 1px, 0);
        }
      }

      @keyframes subtle-shake-3 {
        0%,
        100% {
          transform: translate3d(0, 0, 0);
        }
        20% {
          transform: translate3d(-1px, 0, 0);
        }
        40% {
          transform: translate3d(1px, -1px, 0);
        }
        60% {
          transform: translate3d(0, 1px, 0);
        }
        80% {
          transform: translate3d(1px, 0, 0);
        }
      }

      @keyframes subtle-shake-4 {
        0%,
        100% {
          transform: rotate3d(0, 0, 1, 0deg);
        }
        25% {
          transform: rotate3d(0, 0, 1, -0.5deg);
        }
        75% {
          transform: rotate3d(0, 0, 1, 0.5deg);
        }
      }

      .word-tile.victory-shake {
        animation: subtle-shake-1 2s ease-in-out infinite;
        cursor: pointer;
        position: relative;
      }

      .word-tile.victory-shake:hover {
        animation-duration: 1s;
        background-color: #e5e5dc;
        border-color: #d5d5cc;
      }

      .attempt-cell.victory-shake {
        cursor: pointer;
        position: relative;
      }

      .attempt-cell.victory-shake:hover {
        animation-duration: 1s !important;
        transform: scale(1.1);
        z-index: 10;
      }

      .attempts-grid {
        display: grid !important;
        grid-template-columns: repeat(4, 1fr);
        gap: 4px;
        margin: 20px auto;
        max-width: 200px;
        min-height: 50px;
        width: 200px;
        flex-shrink: 0;
      }

      .attempt-cell {
        width: 100%;
        padding-bottom: 100%;
        position: relative;
        border-radius: 4px;
        background-color: #ddd;
        opacity: 1;
        transform: scale(1);
        will-change: transform, opacity;
        backface-visibility: hidden;
      }

      /* Override for colored cells */
      .attempts-grid .attempt-cell[data-bg-color] {
        background-color: attr(data-bg-color) !important;
      }

      .attempts-grid .attempt-cell[data-color="yellow"] {
        background-color: #f9df84 !important;
      }

      .attempts-grid .attempt-cell[data-color="green"] {
        background-color: #a0c35a !important;
      }

      .attempts-grid .attempt-cell[data-color="blue"] {
        background-color: #b0c4ef !important;
      }

      .attempts-grid .attempt-cell[data-color="purple"] {
        background-color: #ba81c5 !important;
      }

      /* Shaking animation for special cells */
      .attempt-cell.shake-link {
        cursor: pointer;
        animation: shake-subtle 2s ease-in-out infinite;
      }

      .attempt-cell.shake-link:hover {
        animation-duration: 1s;
        transform: scale(1.05);
      }

      @keyframes shake-subtle {
        0%,
        100% {
          transform: translate3d(0, 0, 0);
        }
        25% {
          transform: translate3d(-1px, 0, 0);
        }
        75% {
          transform: translate3d(1px, 0, 0);
        }
      }

      @keyframes cellAppear {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      .attempt-row {
        display: contents;
      }

      .attempt-cell.animate {
        opacity: 0;
        transform: scale(0.9);
        animation: cellAppear 0.3s ease-out forwards;
        animation-delay: calc(
          var(--row-index) * 0.1s + var(--cell-index) * 0.05s
        );
      }

      .completion-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 4px;
        margin: 20px auto;
        max-width: 200px;
      }

      .completion-cell {
        width: 100%;
        padding-bottom: 100%;
        position: relative;
        border-radius: 4px;
      }

      .completion-cell span {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-weight: bold;
        font-size: 0.9rem;
        text-align: center;
        width: 90%;
        word-break: break-word;
        line-height: 1.1;
      }

      .completion-grid-link {
        text-decoration: none;
        display: block;
        transition: transform 0.3s ease;
      }

      .completion-grid-link:hover {
        transform: scale(1.05);
        z-index: 1;
      }

      .game-over {
        text-align: center;
        padding: 30px;
        background-color: #fff;
        border-radius: 0;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        opacity: 0;
        transform: translateY(20px);
        pointer-events: none;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -40%);
        z-index: 1000;
        width: 540px;
        max-width: 90%;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .game-over.show {
        opacity: 1;
        transform: translate(-50%, -50%);
        pointer-events: auto;
      }

      .game-over h2 {
        font-family: "Karnak", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 2rem;
        font-weight: 400;
        margin-bottom: 15px;
        color: #333;
        opacity: 0;
        transform: translateY(10px);
        animation: textAppear 0.3s ease-out 0.2s forwards;
      }

      .game-over p {
        font-family: "KarnakNormal", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 16px;
        font-weight: 400;
        color: #666;
        margin-bottom: 20px;
        opacity: 0;
        transform: translateY(10px);
        animation: textAppear 0.3s ease-out 0.3s forwards;
      }

      .game-over .btn {
        opacity: 0;
        transform: translateY(10px);
        animation: textAppear 0.3s ease-out 0.4s forwards;
      }

      /* Mobile users will be redirected to mobile version */

      .show-play-buttons .play-button {
        display: flex;
      }

      .group-block {
        grid-column: span 4;
        background-color: #a0c35a;
        border-radius: 6px;
        padding: 12px;
        text-align: center;
        color: #fff;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        height: 80px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .group-block.new-group {
        animation: groupAppear 0.5s ease-out;
      }

      @keyframes groupAppear {
        from {
          transform: translateY(20px) scale(0.95);
          opacity: 0;
        }
        to {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
      }

      .group-block.yellow {
        background-color: #f9df84;
        color: #121212;
      }

      .group-block.green {
        background-color: #a0c35a;
        color: #ffffff;
      }

      .group-block.blue {
        background-color: #b0c4ef;
        color: #121212;
      }

      .group-block.purple {
        background-color: #ba81c5;
        color: #ffffff;
      }

      .group-category {
        font-family: "Franklin", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 20px;
        margin-bottom: 2px;
        font-weight: 700;
        opacity: 0;
        transform: translateY(10px);
        animation: textAppear 0.3s ease-out 0.2s forwards;
        line-height: 1;
        color: #121212;
      }

      .group-words {
        font-family: "Franklin", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 20px;
        opacity: 0;
        font-weight: 500;
        transform: translateY(10px);
        animation: textAppear 0.3s ease-out 0.3s forwards;
        line-height: 1;
        color: #121212;
      }

      @keyframes textAppear {
        to {
          opacity: 0.9;
          transform: translateY(0);
        }
      }

      .cooldown-timer {
        font-family: "Franklin", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 16px;
        font-weight: 500;
        margin: 15px 0;
        color: #666;
      }

      /* Early Access Popup - Match game-over popup style */
      .early-access-popup {
        text-align: center;
        padding: 30px;
        background-color: #fff;
        border-radius: 0;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        opacity: 0;
        transform: translateY(20px);
        pointer-events: none;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -40%);
        z-index: 1000;
        width: 540px;
        max-width: 90%;
        display: none;
      }

      .early-access-popup.show {
        opacity: 1;
        transform: translate(-50%, -50%);
        pointer-events: auto;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .early-access-popup h2 {
        font-family: "Karnak", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 2rem;
        font-weight: 400;
        margin-bottom: 15px;
        color: #333;
        opacity: 0;
        transform: translateY(10px);
        animation: textAppear 0.3s ease-out 0.2s forwards;
      }

      .early-access-popup p {
        font-family: "KarnakNormal", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 16px;
        font-weight: 400;
        color: #666;
        margin-bottom: 20px;
        opacity: 0;
        transform: translateY(10px);
        animation: textAppear 0.3s ease-out 0.3s forwards;
      }

      .early-access-popup .btn {
        opacity: 0;
        transform: translateY(10px);
        animation: textAppear 0.3s ease-out 0.4s forwards;
      }

      /* How to Play Popup */
      .how-to-play-popup {
        text-align: left;
        padding: 30px;
        background-color: #fff;
        border-radius: 0;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        opacity: 0;
        transform: translateY(20px);
        pointer-events: none;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -40%);
        z-index: 1000;
        width: 540px;
        max-width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        display: none;
      }

      .how-to-play-popup.show {
        opacity: 1;
        transform: translate(-50%, -50%);
        pointer-events: auto;
        display: block;
      }

      .how-to-play-popup h2 {
        font-family: "Karnak", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 2rem;
        font-weight: 400;
        margin-bottom: 15px;
        color: #333;
        text-align: center;
      }

      .how-to-play-popup p {
        font-family: "KarnakNormal", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 16px;
        font-weight: 400;
        color: #333;
        margin-bottom: 20px;
        line-height: 1.4;
      }

      .how-to-play-popup ul {
        font-family: "KarnakNormal", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 16px;
        font-weight: 400;
        color: #333;
        margin-bottom: 20px;
        padding-left: 20px;
        line-height: 1.6;
      }

      .how-to-play-popup li {
        margin-bottom: 8px;
      }

      .how-to-play-popup h3 {
        font-family: "Karnak", "nyt-franklin", "Helvetica Neue", Helvetica,
          Arial, sans-serif;
        font-size: 1.2rem;
        font-weight: 400;
        margin: 25px 0 15px 0;
        color: #333;
      }

      .close-btn {
        position: absolute;
        top: 15px;
        right: 20px;
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #666;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color 0.2s ease;
      }

      .close-btn:hover {
        color: #000;
      }

      .difficulty-colors {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin: 15px 0;
      }

      .difficulty-item {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .color-box {
        width: 20px;
        height: 20px;
        border-radius: 3px;
      }

      .color-yellow {
        background-color: #f9df84;
      }
      .color-green {
        background-color: #a0c35a;
      }
      .color-blue {
        background-color: #b0c4ef;
      }
      .color-purple {
        background-color: #ba81c5;
      }
    </style>
  </head>
  <body>
    <header class="header">
      <div class="header-content"></div>
    </header>

    <header class="header">
      <div class="header-content">
        <h1 class="title">Sonnections</h1>
      </div>
    </header>

    <header class="header help-header">
      <div class="header-content">
        <div class="help-bar">
          <div class="help-icon" id="helpIcon">
            <svg
              aria-hidden="true"
              xmlns="http://www.w3.org/2000/svg"
              height="32"
              viewBox="0 0 32 32"
              width="32"
              class="game-icon"
              data-testid="icon-help"
            >
              <path
                fill="var(--text)"
                d="M15 24H17.6667V21.3333H15V24ZM16.3333 2.66666C8.97333 2.66666 3 8.63999 3 16C3 23.36 8.97333 29.3333 16.3333 29.3333C23.6933 29.3333 29.6667 23.36 29.6667 16C29.6667 8.63999 23.6933 2.66666 16.3333 2.66666ZM16.3333 26.6667C10.4533 26.6667 5.66667 21.88 5.66667 16C5.66667 10.12 10.4533 5.33332 16.3333 5.33332C22.2133 5.33332 27 10.12 27 16C27 21.88 22.2133 26.6667 16.3333 26.6667ZM16.3333 7.99999C13.3867 7.99999 11 10.3867 11 13.3333H13.6667C13.6667 11.8667 14.8667 10.6667 16.3333 10.6667C17.8 10.6667 19 11.8667 19 13.3333C19 16 15 15.6667 15 20H17.6667C17.6667 17 21.6667 16.6667 21.6667 13.3333C21.6667 10.3867 19.28 7.99999 16.3333 7.99999Z"
              ></path>
            </svg>
          </div>
        </div>
      </div>
    </header>

    <main class="main-content">
      <div class="container">
        <p class="subtitle">Create four groups of four!</p>
        <div class="toast" id="toast"></div>
        <div class="word-grid" id="wordGrid"></div>

        <div class="mistakes-section">
          <div class="mistakes">
            Mistakes remaining:
            <div class="mistake-dots">
              <div class="mistake-dot" id="dot4"></div>
              <div class="mistake-dot" id="dot3"></div>
              <div class="mistake-dot" id="dot2"></div>
              <div class="mistake-dot" id="dot1"></div>
            </div>
          </div>
        </div>

        <div class="timer-section" id="timerSection">
          Next attempt available in: <span id="timer">00:00:00</span>
        </div>

        <div class="controls">
          <button class="btn" id="shuffleBtn">Shuffle</button>
          <button class="btn" id="deselectBtn">Deselect All</button>
          <button class="btn" id="submitBtn" disabled>Submit</button>
        </div>

        <div class="game-over" id="gameOver">
          <button class="close-btn" onclick="closeGameOverPopup()">✕</button>
          <h2 id="gameOverTitle">Game Over!</h2>
          <p id="gameOverMessage"></p>
          <div class="cooldown-timer" id="cooldownTimer"></div>
          <button class="btn" id="playAgainBtn">Play Again</button>
        </div>
      </div>
    </main>

    <script>
      // Mobile redirect - redirect to mobile version if on mobile device
      function isMobile() {
        return (
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) ||
          (window.innerWidth <= 768 && window.innerHeight <= 1024)
        );
      }

      if (isMobile()) {
        window.location.href = "sonnections-mobile.html";
      }

      // Game data
      const gameData = {
        groups: [
          {
            category: '"CAFE" SPELLED MUSICALLY',
            words: ["GUITAR", "HARMONIUM", "ORCHESTRA", "PIANO"],
            audioFiles: [
              "audio/guitar.mp3",
              "audio/harmonium.mp3",
              "audio/orchestra.mp3",
              "audio/piano.mp3",
            ],
            color: "yellow",
            difficulty: 1,
          },
          {
            category: "WORKPLACE AMBIENCE",
            words: ["SLACK NOTIFICATION", "TYPING", "GOOGLE MEET", "MICROWAVE"],
            audioFiles: [
              "audio/slack.mp3",
              "audio/typing.mp3",
              "audio/gmeet.mp3",
              "audio/microwave.mp3",
            ],
            color: "green",
            difficulty: 2,
          },
          {
            category: "SOUNDS LIKE BANGALORE",
            words: ["NAMMA YATRI", "MONSOON", "AUTO RICKSHAW", "GPAY"],
            audioFiles: [
              "audio/namma-yatri.mp3",
              "audio/monsoon.mp3",
              "audio/auto.mp3",
              "audio/gpay.mp3",
            ],
            color: "blue",
            difficulty: 3,
          },
          {
            category: "SOUNDS ALSO MADE BY GEESE",
            words: ["HONK", "HISS", "TRUMPET", "CHATTER"],
            audioFiles: [
              "audio/honk.mp3",
              "audio/hiss.mp3",
              "audio/trumpet.mp3",
              "audio/chatter.mp3",
            ],
            color: "purple",
            difficulty: 4,
          },
        ],
      };

      // Flag to control next puzzle access
      const NEXT_PUZZLES_ENABLED = true; // Set to true to enable all next puzzles

      // Cooldown duration in milliseconds
      const COOLDOWN_DURATION = 3600000; // 1 hour (3600000ms)

      // Game state
      let gameState = {
        words: [],
        wordToAudio: new Map(), // Map words to their audio files
        audioInstances: new Map(), // Map words to their audio instances
        selectedWords: [],
        foundGroups: [],
        completionOrder: [],
        mistakes: 0,
        maxMistakes: 4,
        gameOver: false,
        previousGuesses: new Set(), // Track previous incorrect guesses
        lastAttemptTime: null, // Track when the last attempt was made
        timerInterval: null, // Track the timer interval
        attempts: [], // Track all attempts with their colors
        playButtonsShown: false, // Track if play buttons have been shown
        firstSelectionMade: false, // Track if first selection has been made
      };

      // Audio management
      function playSound(word, audioFile) {
        try {
          // Stop any currently playing audio for this word
          if (gameState.audioInstances.has(word)) {
            const existingAudio = gameState.audioInstances.get(word);
            existingAudio.pause();
            existingAudio.currentTime = 0;
          }

          const audio = new Audio(audioFile);
          audio.volume = 0.7;

          // Store the audio instance
          gameState.audioInstances.set(word, audio);

          // Update button state when audio starts playing
          audio.addEventListener("play", () => {
            updatePlayButtonState(word, "playing");
          });

          // Update button state when audio ends
          audio.addEventListener("ended", () => {
            updatePlayButtonState(word, "stopped");
            gameState.audioInstances.delete(word);
          });

          // Update button state when audio is paused
          audio.addEventListener("pause", () => {
            updatePlayButtonState(word, "stopped");
          });

          audio.play().catch((e) => {
            console.warn("Could not play audio:", audioFile, e);
            updatePlayButtonState(word, "stopped");
          });
        } catch (e) {
          console.warn("Audio error:", e);
        }
      }

      function stopSound(word) {
        if (gameState.audioInstances.has(word)) {
          const audio = gameState.audioInstances.get(word);
          audio.pause();
          audio.currentTime = 0;
          updatePlayButtonState(word, "stopped");
          gameState.audioInstances.delete(word);
        }
      }

      function updatePlayButtonState(word, state) {
        const tiles = document.querySelectorAll(".word-tile");
        tiles.forEach((tile) => {
          const hiddenWordEl = tile.querySelector(".hidden-word");
          const playButton = tile.querySelector(".play-button");
          if (hiddenWordEl && hiddenWordEl.textContent === word && playButton) {
            if (state === "playing") {
              playButton.innerHTML = "⏸"; // Pause/stop symbol
              playButton.classList.add("playing");
            } else {
              playButton.innerHTML = "▶"; // Play symbol
              playButton.classList.remove("playing");
            }
          }
        });
      }

      // DOM elements
      const wordGrid = document.getElementById("wordGrid");
      const toastEl = document.getElementById("toast");
      const shuffleBtn = document.getElementById("shuffleBtn");
      const deselectBtn = document.getElementById("deselectBtn");
      const submitBtn = document.getElementById("submitBtn");
      const gameOverEl = document.getElementById("gameOver");
      const gameOverTitle = document.getElementById("gameOverTitle");
      const gameOverMessage = document.getElementById("gameOverMessage");
      const cooldownTimer = document.getElementById("cooldownTimer");
      const playAgainBtn = document.getElementById("playAgainBtn");
      const timerSection = document.getElementById("timerSection");
      const timerEl = document.getElementById("timer");

      // Check if user is in cooldown period
      function isInCooldown() {
        const lastAttempt = localStorage.getItem("sonnections_lastAttemptTime");
        if (!lastAttempt) return false;

        const now = new Date().getTime();
        const timeDiff = now - parseInt(lastAttempt);
        return timeDiff < COOLDOWN_DURATION;
      }

      // Update cooldown timer display
      function updateCooldownTimer() {
        const lastAttempt = localStorage.getItem("sonnections_lastAttemptTime");
        if (!lastAttempt) return;

        const now = new Date().getTime();
        const timeDiff = now - parseInt(lastAttempt);
        const timeLeft = Math.max(COOLDOWN_DURATION - timeDiff, 0);

        if (timeLeft === 0) {
          cooldownTimer.textContent = "You can now play again!";
          playAgainBtn.disabled = false;
          playAgainBtn.textContent = "Play Again";
          clearInterval(gameState.timerInterval);
          // Don't auto-close popup - let user click Play Again button
          return;
        }

        const hours = Math.floor(timeLeft / 3600000);
        const minutes = Math.floor((timeLeft % 3600000) / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);

        cooldownTimer.textContent = `Next game available in: ${String(
          hours
        ).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(
          seconds
        ).padStart(2, "0")}`;
        playAgainBtn.disabled = true;
        playAgainBtn.textContent = "Please Wait";
      }

      // Show toast message
      function showToast(message) {
        // Clear any existing timeout
        if (window.toastTimeout) {
          clearTimeout(window.toastTimeout);
        }

        toastEl.textContent = message;
        toastEl.className = "toast show";

        window.toastTimeout = setTimeout(() => {
          toastEl.className = "toast";
        }, 2000);
      }

      // Show early access popup
      function showEarlyAccessPopup() {
        const popup = document.getElementById("early-access-popup");
        popup.classList.add("show");
      }

      // Close early access popup
      function closeEarlyAccessPopup() {
        const popup = document.getElementById("early-access-popup");
        popup.classList.remove("show");
      }

      // Close game over popup
      function closeGameOverPopup() {
        const popup = document.getElementById("gameOver");
        popup.classList.remove("show");
      }

      // Save game state with error handling
      function saveGameState() {
        try {
          if (!gameState || gameState.gameOver) {
            return; // Don't save if game is over
          }

          const stateToSave = {
            words: gameState.words || [],
            selectedWords: gameState.selectedWords || [],
            foundGroups: gameState.foundGroups || [],
            completionOrder: gameState.completionOrder || [],
            mistakes: gameState.mistakes || 0,
            maxMistakes: gameState.maxMistakes || 4,
            previousGuesses: Array.from(gameState.previousGuesses || []),
            attempts: gameState.attempts || [],
            playButtonsShown: gameState.playButtonsShown || false,
            firstSelectionMade: gameState.firstSelectionMade || false,
            timestamp: Date.now(),
          };
          localStorage.setItem(
            "sonnections_gameState",
            JSON.stringify(stateToSave)
          );
        } catch (e) {
          console.warn("Failed to save game state:", e);
        }
      }

      // Load game state with validation
      function loadGameState() {
        try {
          const savedState = localStorage.getItem("sonnections_gameState");
          if (!savedState) return false;

          const state = JSON.parse(savedState);

          // Validate the loaded state
          if (
            !state.words ||
            !Array.isArray(state.words) ||
            state.words.length === 0
          ) {
            return false;
          }

          // Restore game state
          gameState.words = state.words;
          gameState.selectedWords = state.selectedWords || [];
          gameState.foundGroups = state.foundGroups || [];
          gameState.completionOrder = state.completionOrder || [];
          gameState.mistakes = state.mistakes || 0;
          gameState.maxMistakes = state.maxMistakes || 4;
          gameState.previousGuesses = new Set(state.previousGuesses || []);
          gameState.attempts = state.attempts || [];
          gameState.playButtonsShown = state.playButtonsShown || false;
          gameState.firstSelectionMade = state.firstSelectionMade || false;
          gameState.gameOver = false;
          gameState.lastAttemptTime = null;
          gameState.timerInterval = null;
          gameState.audioInstances = new Map();
          gameState.wordToAudio = new Map();

          return true;
        } catch (e) {
          console.warn("Failed to load game state:", e);
          localStorage.removeItem("sonnections_gameState");
          return false;
        }
      }

      // Clear saved game state
      function clearSavedGameState() {
        localStorage.removeItem("sonnections_gameState");
      }

      // Initialize game
      function initGame() {
        // Check if cooldown has expired and clean up if needed
        const lastAttempt = localStorage.getItem("sonnections_lastAttemptTime");
        if (lastAttempt) {
          const now = new Date().getTime();
          const timeDiff = now - parseInt(lastAttempt);
          if (timeDiff >= COOLDOWN_DURATION) {
            // Cooldown has expired - clear all saved data for fresh start
            localStorage.removeItem("sonnections_lastAttemptTime");
            clearSavedGameState();
            localStorage.removeItem("sonnections_lastAttempts");
          }
        }

        // NOW check cooldown (after cleanup)
        if (isInCooldown()) {
          // Try to load the saved game state from when they lost
          const hasLoadedState = loadGameState();

          if (!hasLoadedState) {
            // Fallback if no saved state - create basic game state
            gameState = {
              words: [],
              wordToAudio: new Map(),
              audioInstances: new Map(),
              selectedWords: [],
              foundGroups: [],
              completionOrder: [],
              mistakes: 4,
              maxMistakes: 4,
              gameOver: true,
              previousGuesses: new Set(),
              lastAttemptTime: null,
              timerInterval: null,
              attempts: [],
              playButtonsShown: false,
              firstSelectionMade: false,
            };
            // Create word-to-audio mapping
            gameData.groups.forEach((group) => {
              group.words.forEach((word, index) => {
                gameState.words.push(word);
                gameState.wordToAudio.set(word, group.audioFiles[index]);
              });
            });
            shuffleArray(gameState.words);
          } else {
            // Use loaded state but ensure game is marked as over and rebuild audio mapping
            gameState.gameOver = true;
            gameData.groups.forEach((group) => {
              group.words.forEach((word, index) => {
                gameState.wordToAudio.set(word, group.audioFiles[index]);
              });
            });
          }

          // Reset UI and render grid so tiles are visible behind popup
          toastEl.className = "toast";
          updateMistakesDisplay();
          renderWordGrid();
          updateControls();
          showGameOverScreen(false, true);
          return;
        }

        // Initialize base game state
        gameState = {
          words: [],
          wordToAudio: new Map(),
          audioInstances: new Map(),
          selectedWords: [],
          foundGroups: [],
          completionOrder: [],
          mistakes: 0,
          maxMistakes: 4,
          gameOver: false,
          previousGuesses: new Set(),
          lastAttemptTime: null,
          timerInterval: null,
          attempts: [],
          playButtonsShown: false,
          firstSelectionMade: false,
        };

        // Try to load existing game state
        const hasLoadedState = loadGameState();

        if (!hasLoadedState) {
          // Create new game - flatten all words and shuffle, also create word-to-audio mapping
          gameState.words = [];
          gameData.groups.forEach((group) => {
            group.words.forEach((word, index) => {
              gameState.words.push(word);
              gameState.wordToAudio.set(word, group.audioFiles[index]);
            });
          });
          shuffleArray(gameState.words);
        } else {
          // If we loaded state, rebuild the word-to-audio mapping
          gameData.groups.forEach((group) => {
            group.words.forEach((word, index) => {
              gameState.wordToAudio.set(word, group.audioFiles[index]);
            });
          });
        }

        // Clear saved attempts when starting new game
        localStorage.removeItem("sonnections_lastAttempts");

        // Reset UI
        toastEl.className = "toast";
        gameOverEl.className = "game-over";
        updateMistakesDisplay();
        renderWordGrid();
        updateControls();
      }

      // Shuffle array
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      // Optimized render word grid with reduced DOM manipulation
      function renderWordGrid() {
        const currentTiles = wordGrid.querySelectorAll(".word-tile");
        const currentWords = Array.from(currentTiles).map((tile) => {
          const hiddenWordElement = tile.querySelector(".hidden-word");
          return hiddenWordElement
            ? hiddenWordElement.textContent
            : tile.textContent;
        });

        // Get remaining words (not found yet) - use Set for faster lookup
        const foundWords = new Set(
          gameState.foundGroups.flatMap((group) => group.words)
        );
        const remainingWords = gameState.words.filter(
          (word) => !foundWords.has(word)
        );
        const selectedWordsSet = new Set(gameState.selectedWords);

        // Update existing tiles if possible (but only if order is also the same)
        if (
          currentWords.length === remainingWords.length &&
          currentWords.every((word, index) => word === remainingWords[index])
        ) {
          // Just update selection states - words are in same order
          currentTiles.forEach((tile) => {
            const hiddenWordElement = tile.querySelector(".hidden-word");
            const word = hiddenWordElement
              ? hiddenWordElement.textContent
              : tile.textContent;
            tile.classList.toggle("selected", selectedWordsSet.has(word));
          });
        } else {
          // Full re-render needed - use DocumentFragment for better performance
          const fragment = document.createDocumentFragment();

          // Add found groups first (at the top) - preserve existing groups
          gameState.foundGroups.forEach((group, index) => {
            const groupBlock = document.createElement("div");
            groupBlock.className = `group-block ${group.color}`;

            groupBlock.innerHTML = `
                        <div class="group-category">${group.category}</div>
                        <div class="group-words">${group.words.join(", ")}</div>
                    `;

            fragment.appendChild(groupBlock);
          });

          // Add remaining word tiles below the groups
          remainingWords.forEach((word) => {
            const tile = document.createElement("div");
            tile.className = `word-tile${
              selectedWordsSet.has(word) ? " selected" : ""
            }`;

            // Create play button
            const playButton = document.createElement("button");
            playButton.className = "play-button";
            playButton.innerHTML = "▶";
            playButton.addEventListener("click", (e) => {
              e.stopPropagation();
              if (gameState.audioInstances.has(word)) {
                // Audio is playing, stop it
                stopSound(word);
              } else {
                // Audio is not playing, start it
                playSound(word, gameState.wordToAudio.get(word));
              }
            });

            // Create hidden word element for reference
            const hiddenWord = document.createElement("span");
            hiddenWord.className = "hidden-word";
            hiddenWord.textContent = word;

            tile.appendChild(playButton);
            tile.appendChild(hiddenWord);
            tile.addEventListener("click", () => selectWord(word), {
              passive: true,
            });

            fragment.appendChild(tile);
          });

          // Single DOM update
          wordGrid.innerHTML = "";
          wordGrid.appendChild(fragment);
        }
      }

      // Select/deselect word
      function selectWord(word) {
        if (gameState.gameOver) return;

        // Check if word is already found
        const isFound = gameState.foundGroups.some((group) =>
          group.words.includes(word)
        );
        if (isFound) return;

        const index = gameState.selectedWords.indexOf(word);

        if (index > -1) {
          // Deselect word
          gameState.selectedWords.splice(index, 1);
        } else if (gameState.selectedWords.length < 4) {
          // Select word and only play sound on very first selection
          gameState.selectedWords.push(word);
          if (!gameState.firstSelectionMade) {
            playSound(word, gameState.wordToAudio.get(word));
            gameState.firstSelectionMade = true;
          }
        }

        // Show play buttons when any word is selected for the first time
        if (gameState.selectedWords.length > 0 && !gameState.playButtonsShown) {
          wordGrid.classList.add("show-play-buttons");
          gameState.playButtonsShown = true;
        }

        renderWordGrid();
        updateControls();
        saveGameState();
      }

      // Update control buttons
      function updateControls() {
        submitBtn.disabled = gameState.selectedWords.length !== 4;
        deselectBtn.disabled = gameState.selectedWords.length === 0;
        shuffleBtn.disabled =
          gameState.gameOver ||
          gameState.mistakes >= gameState.maxMistakes ||
          gameState.foundGroups.length === 4;
      }

      // Shuffle words with optimized performance
      function shuffleWords() {
        // Get remaining words (not found yet) - use cached check for better performance
        const foundWords = new Set(
          gameState.foundGroups.flatMap((group) => group.words)
        );
        const remainingWords = gameState.words.filter(
          (word) => !foundWords.has(word)
        );

        // Shuffle only the remaining words
        shuffleArray(remainingWords);

        // Update the words array with found groups first, then shuffled remaining
        gameState.words = [
          ...gameState.foundGroups.flatMap((group) => group.words),
          ...remainingWords,
        ];

        // DON'T clear selections when shuffling - keep user's selected words

        // Use requestAnimationFrame for smoother rendering
        requestAnimationFrame(() => {
          wordGrid.innerHTML = "";
          renderWordGrid();
          updateControls();
        });
      }

      // Deselect all words
      function deselectAll() {
        gameState.selectedWords = [];
        // Don't hide play buttons once they've been shown
        renderWordGrid();
        updateControls();
        saveGameState();
      }

      // Submit guess
      function submitGuess() {
        if (gameState.selectedWords.length !== 4) return;

        // Sort selected words to ensure consistent comparison
        const sortedGuess = [...gameState.selectedWords].sort().join(",");

        // Check if this guess was already tried
        if (gameState.previousGuesses.has(sortedGuess)) {
          showToast("Already guessed");
          gameState.selectedWords = [];
          saveGameState(); // Save state after clearing selections
          // Don't hide play buttons once they've been shown
          renderWordGrid();
          updateControls();
          return;
        }

        // Check if this combination forms a valid group
        const correctGroup = gameData.groups.find(
          (group) =>
            gameState.selectedWords.every((word) =>
              group.words.includes(word)
            ) && gameState.selectedWords.length === 4
        );

        if (correctGroup) {
          // Animate correct guess sequence
          animateCorrectGuess(correctGroup);
        } else {
          // Add to previous guesses
          gameState.previousGuesses.add(sortedGuess);

          // Find the group that has the most matches with the selected words
          let bestMatch = null;
          let maxMatches = 0;
          gameData.groups.forEach((group) => {
            const matches = gameState.selectedWords.filter((word) =>
              group.words.includes(word)
            ).length;
            if (matches > maxMatches) {
              maxMatches = matches;
              bestMatch = group;
            }
          });

          // Track the attempt with colors in order
          const selectedColors = gameState.selectedWords.map((word) => {
            // Find which group this word belongs to
            const group = gameData.groups.find((g) => g.words.includes(word));
            return group ? group.color : "gray";
          });
          gameState.attempts.push({
            words: [...gameState.selectedWords],
            colors: selectedColors,
            correct: false,
          });

          // Check if "one away" (3 out of 4 words are correct)
          const oneAwayGroup = gameData.groups.find((group) => {
            const matchingWords = gameState.selectedWords.filter((word) =>
              group.words.includes(word)
            );
            return matchingWords.length === 3;
          });

          if (oneAwayGroup) {
            showToast("One away");
          }

          // Shake the selected tiles for incorrect guess - optimized cleanup
          const selectedTiles = document.querySelectorAll(
            ".word-tile.selected"
          );
          selectedTiles.forEach((tile) => {
            tile.classList.add("incorrect-guess");
            // Use requestAnimationFrame for smoother cleanup
            requestAnimationFrame(() => {
              setTimeout(() => {
                tile.classList.remove("incorrect-guess");
              }, 400);
            });
          });

          // Incorrect guess
          gameState.mistakes++;
          // Clear selected words after submitting guess
          gameState.selectedWords = [];

          updateMistakesDisplay();
          saveGameState(); // Save state after incorrect guess
          renderWordGrid(); // Re-render to show cleared selections

          // Check if game is lost
          if (gameState.mistakes >= gameState.maxMistakes) {
            // Store the loss time and attempts in localStorage
            localStorage.setItem(
              "sonnections_lastAttemptTime",
              new Date().getTime().toString()
            );
            localStorage.setItem(
              "sonnections_lastAttempts",
              JSON.stringify(gameState.attempts)
            );
            // DON'T clear saved state on loss - preserve it for cooldown period
            saveGameState(); // Save final state so user can see it during cooldown
            endGame(false);
          }
        }

        updateControls();
      }

      async function animateCorrectGuess(correctGroup) {
        const selectedTiles = Array.from(
          document.querySelectorAll(".word-tile.selected")
        );

        // Step 1: Hop animation - each tile hops one at a time with optimized timing
        const hopPromises = selectedTiles.map((tile, i) => {
          return new Promise((resolve) => {
            setTimeout(() => {
              tile.classList.add("hop");
              // Use requestAnimationFrame for smoother cleanup
              requestAnimationFrame(() => {
                setTimeout(() => {
                  tile.classList.remove("hop");
                  resolve();
                }, 300);
              });
            }, i * 100);
          });
        });

        await Promise.all(hopPromises);

        // Step 2: Calculate target row and positions
        const grid = document.getElementById("wordGrid");
        const gridRect = grid.getBoundingClientRect();
        const allTiles = Array.from(grid.querySelectorAll(".word-tile"));

        // Target row is right after existing groups (at index gameState.foundGroups.length)
        const targetRowIndex = gameState.foundGroups.length;

        // Calculate the exact grid positions for the target row
        const targetPositions = [];
        const tileHeight = selectedTiles[0].offsetHeight;
        const tileWidth = selectedTiles[0].offsetWidth;
        const gap = 8; // CSS gap value

        for (let col = 0; col < 4; col++) {
          const x = gridRect.left + col * (tileWidth + gap);
          const y = gridRect.top + targetRowIndex * (tileHeight + gap);
          targetPositions.push({ x, y });
        }

        // Step 3: Find tiles that are exactly in the target row positions
        const tilesToDisplace = [];
        const swapAnimations = [];

        // Get all non-selected tiles currently in the target row
        const tilesInTargetRow = allTiles.filter((tile) => {
          if (tile.classList.contains("selected")) return false;

          const tileRect = tile.getBoundingClientRect();
          const tileRowIndex = Math.round(
            (tileRect.top - gridRect.top) / (tileHeight + gap)
          );

          // Only include tiles that are exactly in the target row
          return tileRowIndex === targetRowIndex;
        });

        // These are the tiles that need to be displaced
        tilesToDisplace.push(...tilesInTargetRow);

        // Move selected tiles to target row
        selectedTiles.forEach((selectedTile, index) => {
          const selectedRect = selectedTile.getBoundingClientRect();
          const targetPos = targetPositions[index];

          const deltaX = targetPos.x - selectedRect.left;
          const deltaY = targetPos.y - selectedRect.top;

          selectedTile.classList.add("moving");
          selectedTile.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
        });

        // Calculate exact destination positions for displaced tiles
        const remainingTiles = allTiles.filter(
          (tile) =>
            !tile.classList.contains("selected") &&
            !tilesToDisplace.includes(tile)
        );

        // Create a list of all available positions after the target row
        const availablePositions = [];
        for (let row = targetRowIndex + 1; row < 4; row++) {
          for (let col = 0; col < 4; col++) {
            const x = gridRect.left + col * (tileWidth + gap);
            const y = gridRect.top + row * (tileHeight + gap);
            availablePositions.push({ x, y, row, col });
          }
        }

        // First, account for tiles that are already in correct positions and don't need to move
        const occupiedPositions = new Set();
        remainingTiles.forEach((tile) => {
          const tileRect = tile.getBoundingClientRect();
          availablePositions.forEach((pos, index) => {
            if (
              Math.abs(tileRect.left - pos.x) < 10 &&
              Math.abs(tileRect.top - pos.y) < 10
            ) {
              occupiedPositions.add(index);
            }
          });
        });

        // Assign displaced tiles to the first available positions
        let assignmentIndex = 0;
        tilesToDisplace.forEach((displacedTile) => {
          // Find next available position
          while (
            assignmentIndex < availablePositions.length &&
            occupiedPositions.has(assignmentIndex)
          ) {
            assignmentIndex++;
          }

          if (assignmentIndex < availablePositions.length) {
            const targetPos = availablePositions[assignmentIndex];
            const tileRect = displacedTile.getBoundingClientRect();

            const deltaX = targetPos.x - tileRect.left;
            const deltaY = targetPos.y - tileRect.top;

            displacedTile.classList.add("moving");
            displacedTile.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            swapAnimations.push({ targetTile: displacedTile });

            // Mark this position as occupied
            occupiedPositions.add(assignmentIndex);
            assignmentIndex++;
          }
        });

        // Wait for movement animation to complete
        await new Promise((resolve) => setTimeout(resolve, 600));

        // Step 4: Update game state
        gameState.foundGroups.push(correctGroup);
        gameState.completionOrder.push(correctGroup.color);
        gameState.attempts.push({
          words: [...gameState.selectedWords],
          colors: gameState.selectedWords.map(() => correctGroup.color),
          correct: true,
        });
        gameState.selectedWords = [];

        // Don't hide play buttons once they've been shown

        // Step 5: Clean up transforms first, THEN modify DOM
        selectedTiles.forEach((tile) => {
          tile.classList.remove("moving", "selected");
          tile.style.transform = "";
        });

        swapAnimations.forEach(({ targetTile }) => {
          targetTile.classList.remove("moving");
          targetTile.style.transform = "";
        });

        // Wait a frame to ensure transforms are cleared
        await new Promise((resolve) => requestAnimationFrame(resolve));

        // Step 6: Temporarily disable transitions to prevent second movement
        const allRemainingTiles = wordGrid.querySelectorAll(
          ".word-tile:not(.selected)"
        );
        allRemainingTiles.forEach((tile) => {
          tile.style.transition = "none";
        });
    <script>
        // Mobile redirect - redirect to mobile version if on mobile device
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (window.innerWidth <= 768 && window.innerHeight <= 1024);
        }
        
        if (isMobile()) {
            window.location.href = 'sonnections-mobile.html';
        }
        
        // Game data
        const gameData = {
            groups: [
                    {
                        category: "\"CAFE\" SPELLED MUSICALLY",
                        words: ["GUITAR", "HARMONIUM", "ORCHESTRA", "PIANO"],
                        audioFiles: ["audio/guitar.mp3", "audio/harmonium.mp3", "audio/orchestra.mp3", "audio/piano.mp3"],
                        color: "yellow",
                        difficulty: 1
                    },
                    {
                        category: "WORKPLACE AMBIENCE",
                        words: ["SLACK NOTIFICATION", "TYPING", "GOOGLE MEET", "MICROWAVE"],
                        audioFiles: ["audio/slack.mp3", "audio/typing.mp3", "audio/gmeet.mp3", "audio/microwave.mp3"],
                        color: "green",
                        difficulty: 2
                    },
                    {
                        category: "SOUNDS LIKE BANGALORE",
                        words: ["NAMMA YATRI", "MONSOON", "AUTO RICKSHAW", "GPAY"],
                        audioFiles: ["audio/namma-yatri.mp3", "audio/monsoon.mp3", "audio/auto.mp3", "audio/gpay.mp3"],
                        color: "blue",
                        difficulty: 3
                    },
                    {
                        category: "SOUNDS ALSO MADE BY GEESE",
                        words: ["HONK", "HISS", "TRUMPET", "CHATTER"],
                        audioFiles: ["audio/honk.mp3", "audio/hiss.mp3", "audio/trumpet.mp3", "audio/chatter.mp3"],
                        color: "purple",
                        difficulty: 4
                    }
                ]
            };

        // Flag to control next puzzle access
        const NEXT_PUZZLES_ENABLED = true; // Set to true to enable all next puzzles
        
        // Cooldown duration in milliseconds
        const COOLDOWN_DURATION = 3600000; // 1 hour (3600000ms)
        
        // Game state
        let gameState = {
            words: [],
            wordToAudio: new Map(), // Map words to their audio files
            audioInstances: new Map(), // Map words to their audio instances
            selectedWords: [],
            foundGroups: [],
            completionOrder: [],
            mistakes: 0,
            maxMistakes: 4,
            gameOver: false,
            previousGuesses: new Set(), // Track previous incorrect guesses
            lastAttemptTime: null, // Track when the last attempt was made
            timerInterval: null, // Track the timer interval
            attempts: [], // Track all attempts with their colors
            playButtonsShown: false, // Track if play buttons have been shown
            firstSelectionMade: false // Track if first selection has been made
        };

        const categoryEl = document.createElement("div");
        categoryEl.className = "group-category";
        categoryEl.textContent = correctGroup.category;

        const wordsEl = document.createElement("div");
        wordsEl.className = "group-words";
        wordsEl.textContent = correctGroup.words.join(", ");

        groupBlock.appendChild(categoryEl);
        groupBlock.appendChild(wordsEl);

        // Insert at the correct position
        const firstTile = wordGrid.querySelector(".word-tile");

        if (firstTile) {
          wordGrid.insertBefore(groupBlock, firstTile);
        } else {
          wordGrid.appendChild(groupBlock);
        }

        // Re-enable transitions after a frame
        requestAnimationFrame(() => {
          allRemainingTiles.forEach((tile) => {
            if (tile.parentNode) {
              // Check if tile still exists
              tile.style.transition = "";
            }
          });
        });

        // Remove the animation class after animation completes
        setTimeout(() => {
          groupBlock.classList.remove("new-group");
        }, 500);

        updateControls();
        saveGameState(); // Save state after correct guess

        // Check if game is won
        if (gameState.foundGroups.length === 4) {
          clearSavedGameState(); // Clear saved state on game completion
          endGame(true);
        }
      }

      // Update mistakes display
      function updateMistakesDisplay() {
        for (let i = 1; i <= 4; i++) {
          const dot = document.getElementById(`dot${i}`);
          if (i <= gameState.mistakes) {
            dot.classList.add("used");
          } else {
            dot.classList.remove("used");
          }
        }
      }

      // Playful toast messages for clicked cells
      const playfulMessages = [
        '"ouch"',
        '"that\'s rude"',
        '"that tickles"',
        '"hey!"',
        '"stop that!"',
        '"easy!"',
        '"careful!"',
        '"jeez"',
        '"what was that for?"',
        '"space please!"',
        '"ow"',
        '"that stings"',
        '"why?"',
        '"I didn\'t do anything"',
        '"uncalled for"',
        '"rude"',
        '"ooof"',
        '"no touchy!"',
        '"personal bubble!"',
        '"excuse you"',
        '"do I know you?"',
        '"again?!"',
        '"hands off!"',
        '"yikes"',
        '"how dare you"',
        '"stop poking me"',
        '"I\'m delicate!"',
        '"what are you, five?"',
        '"ma\'am, this is harassment"',
        '"please don\'t"',
        '"ouchies"',
        '"bruh"',
        '"you monster"',
        '"goose! (no context)"',
        '"file a complaint, I dare you"',
        '"I’ll remember this"',
        '"my lawyer will hear about this"',
      ];

      // Function to get random playful message
      function getRandomPlayfulMessage() {
        return playfulMessages[
          Math.floor(Math.random() * playfulMessages.length)
        ];
      }

      // Show game over screen
      function showGameOverScreen(won, fromCooldown = false) {
        gameState.gameOver = true;

        // Clear any existing grids from previous games (but only from inside game-over element)
        const existingGrids = gameOverEl.querySelectorAll(
          ".attempts-grid, .completion-grid"
        );
        existingGrids.forEach((grid) => grid.remove());

        // Handle close button visibility
        const closeBtn = gameOverEl.querySelector(".close-btn");
        if (won || !fromCooldown) {
          // Show close button for wins or new losses
          closeBtn.style.display = "block";
        } else {
          // Hide close button during cooldown
          closeBtn.style.display = "none";
        }

        if (won) {
          gameOverTitle.textContent = "Congratulations!";
          gameOverMessage.textContent = "You found all the sonnections!";
          playAgainBtn.disabled = false;
          playAgainBtn.textContent = "Play Again";
          cooldownTimer.textContent = "";
          // Clear saved attempts when user wins
          localStorage.removeItem("sonnections_lastAttempts");
          // Mark sonnections as completed
          localStorage.setItem("sonnections_completed", "true");
        } else {
          gameOverTitle.textContent = "Game Over";
          gameOverMessage.textContent = "Better luck next time!";
          playAgainBtn.textContent = "Play Again";

          if (fromCooldown) {
            // Start the cooldown timer, button starts disabled
            playAgainBtn.disabled = true;
            updateCooldownTimer();
            gameState.timerInterval = setInterval(updateCooldownTimer, 1000);
          } else {
            // Start the cooldown timer, button starts disabled
            playAgainBtn.disabled = true;
            updateCooldownTimer();
            gameState.timerInterval = setInterval(updateCooldownTimer, 1000);
          }
        }

        // For losers, always try to show saved attempts grid first
        let attemptsToShow = gameState.attempts;
        if (!won && fromCooldown) {
          const savedAttempts = localStorage.getItem(
            "sonnections_lastAttempts"
          );
          if (savedAttempts) {
            try {
              attemptsToShow = JSON.parse(savedAttempts);
            } catch (e) {
              console.warn("Failed to parse saved attempts:", e);
            }
          }
        }

        // Always show attempts grid at the end
        if (attemptsToShow && attemptsToShow.length > 0) {
          const attemptsGrid = document.createElement("div");
          attemptsGrid.className = "attempts-grid";

          attemptsToShow.forEach((attempt, rowIndex) => {
            const attemptRow = document.createElement("div");
            attemptRow.className = "attempt-row";

            attempt.colors.forEach((color, cellIndex) => {
              const cell = document.createElement("div");
              cell.className = "attempt-cell";

              const bgColor = getColorCode(color);

              // Try multiple approaches to ensure color is set
              cell.style.backgroundColor = bgColor;
              cell.style.background = bgColor;
              cell.setAttribute("data-color", color);
              cell.setAttribute("data-bg-color", bgColor);

              // Store cell reference for later link assignment
              cell.globalIndex = rowIndex * 4 + cellIndex;

              cell.style.setProperty("--row-index", rowIndex);
              cell.style.setProperty("--cell-index", cellIndex);
              attemptRow.appendChild(cell);
            });

            attemptsGrid.appendChild(attemptRow);
          });

          gameOverMessage.insertAdjacentElement("afterend", attemptsGrid);

          // Add shake animation and click handlers to random half of cells (only when won)
          if (won) {
            setTimeout(() => {
              addShakeAndClickHandlers(attemptsGrid);
            }, 500);
          }
        }

        // Use groups in the order they were solved (preserve existing layout)
        const solvedGroups = gameState.foundGroups;

        // Clear the word grid
        wordGrid.innerHTML = "";

        // Add all groups in the order they were solved
        solvedGroups.forEach((group) => {
          const groupBlock = document.createElement("div");
          groupBlock.className = `group-block ${group.color}`;

          const categoryEl = document.createElement("div");
          categoryEl.className = "group-category";
          categoryEl.textContent = group.category;

          const wordsEl = document.createElement("div");
          wordsEl.className = "group-words";
          wordsEl.textContent = group.words.join(", ");

          groupBlock.appendChild(categoryEl);
          groupBlock.appendChild(wordsEl);
          wordGrid.appendChild(groupBlock);
        });
        // Add shake animation and click handlers to random half of cells
        function addShakeAndClickHandlers(attemptsGrid) {
            const attemptCells = Array.from(attemptsGrid.querySelectorAll('.attempt-cell'));
            
            if (attemptCells.length === 0) return;
            
            // Select random half of the cells
            const halfCount = Math.ceil(attemptCells.length / 2);
            const shuffledCells = [...attemptCells];
            
            // Shuffle the array
            for (let i = shuffledCells.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledCells[i], shuffledCells[j]] = [shuffledCells[j], shuffledCells[i]];
            }
            
            // Take the first half
            const selectedCells = shuffledCells.slice(0, halfCount);
            
            // Pick one cell from selected cells to be the enhanced shaking cell
            const enhancedShakeIndex = Math.floor(Math.random() * selectedCells.length);
            
            // Add shake animation and click handlers to selected cells
            selectedCells.forEach((cell, index) => {
                cell.classList.add('shake-link');
                
                const isEnhancedCell = index === enhancedShakeIndex;
                
                // Randomly assign one of the shake animations (reusing existing ones)
                const shakeAnimations = ['subtle-shake-1', 'subtle-shake-2', 'subtle-shake-3', 'subtle-shake-4'];
                const randomAnimation = shakeAnimations[Math.floor(Math.random() * shakeAnimations.length)];
                
                // Enhanced cell gets more intense shaking
                let randomDuration, randomDelay;
                if (isEnhancedCell) {
                    // Enhanced cell: faster, more intense shaking
                    randomDuration = (0.8 + Math.random() * 0.4).toFixed(1); // 0.8-1.2s
                    randomDelay = (Math.random() * 0.3).toFixed(2); // 0-0.3s delay
                    cell.classList.add('victory-shake'); // Add special styling
                } else {
                    // Regular cells: normal shaking
                    randomDuration = (1.5 + Math.random()).toFixed(1); // 1.5-2.5s
                    randomDelay = (Math.random() * 0.5).toFixed(2); // 0-0.5s delay
                }
                
                cell.style.animation = `${randomAnimation} ${randomDuration}s ease-in-out infinite`;
                cell.style.animationDelay = `${randomDelay}s`;
                
                // Add click handler
                if (isEnhancedCell) {
                    // Enhanced cell: link or popup functionality
                    cell.addEventListener('click', () => {
                        if (!NEXT_PUZZLES_ENABLED) {
                            showEarlyAccessPopup();
                        } else {
                            // Navigate to wordle.html when enabled
                            const link = 'wordle.html';
                            window.open(link, '_blank');
                        }
                    });
                } else {
                    // Regular cells: toast message
                    cell.addEventListener('click', () => {
                        const message = getRandomPlayfulMessage();
                        showToast(message);
                    });
                }
            });

            tile.appendChild(playButton);
            tile.appendChild(hiddenWord);
            wordGrid.appendChild(tile);
          });

          // Show play buttons if they were shown during gameplay
          if (gameState.playButtonsShown) {
            wordGrid.classList.add("show-play-buttons");
          }
        }

        // Show the game over screen
        gameOverEl.className = "game-over show";

        // Ensure all attempt cells are visible with optimized DOM manipulation
        requestAnimationFrame(() => {
          const attemptsGrid = gameOverEl.querySelector(".attempts-grid");
          if (attemptsGrid) {
            attemptsGrid.style.display = "grid";
            // Batch DOM updates for better performance
            const attemptCells = attemptsGrid.querySelectorAll(".attempt-cell");
            attemptCells.forEach((cell) => {
              cell.style.cssText = "opacity: 1; transform: scale(1);";
            });
          }
        });
      }

      // Add shake animation and click handlers to random half of cells
      function addShakeAndClickHandlers(attemptsGrid) {
        const attemptCells = Array.from(
          attemptsGrid.querySelectorAll(".attempt-cell")
        );

        if (attemptCells.length === 0) return;

        // Select random half of the cells
        const halfCount = Math.ceil(attemptCells.length / 2);
        const shuffledCells = [...attemptCells];

        // Shuffle the array
        for (let i = shuffledCells.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffledCells[i], shuffledCells[j]] = [
            shuffledCells[j],
            shuffledCells[i],
          ];
        }

        // Take the first half
        const selectedCells = shuffledCells.slice(0, halfCount);

        // Pick one cell from selected cells to be the enhanced shaking cell
        const enhancedShakeIndex = Math.floor(
          Math.random() * selectedCells.length
        );

        // Add shake animation and click handlers to selected cells
        selectedCells.forEach((cell, index) => {
          cell.classList.add("shake-link");

          const isEnhancedCell = index === enhancedShakeIndex;

          // Randomly assign one of the shake animations (reusing existing ones)
          const shakeAnimations = [
            "subtle-shake-1",
            "subtle-shake-2",
            "subtle-shake-3",
            "subtle-shake-4",
          ];
          const randomAnimation =
            shakeAnimations[Math.floor(Math.random() * shakeAnimations.length)];

          // Enhanced cell gets more intense shaking
          let randomDuration, randomDelay;
          if (isEnhancedCell) {
            // Enhanced cell: faster, more intense shaking
            randomDuration = (0.8 + Math.random() * 0.4).toFixed(1); // 0.8-1.2s
            randomDelay = (Math.random() * 0.3).toFixed(2); // 0-0.3s delay
            cell.classList.add("victory-shake"); // Add special styling
          } else {
            // Regular cells: normal shaking
            randomDuration = (1.5 + Math.random()).toFixed(1); // 1.5-2.5s
            randomDelay = (Math.random() * 0.5).toFixed(2); // 0-0.5s delay
          }

          cell.style.animation = `${randomAnimation} ${randomDuration}s ease-in-out infinite`;
          cell.style.animationDelay = `${randomDelay}s`;

          // Add click handler
          if (isEnhancedCell) {
            // Enhanced cell: link or popup functionality
            cell.addEventListener("click", () => {
              if (!NEXT_PUZZLES_ENABLED) {
                showEarlyAccessPopup();
              } else {
                // Navigate to wordle.html when enabled
                const link = "wordle.html";
                window.open(link, "_blank");
              }
            });
          } else {
            // Regular cells: toast message
            cell.addEventListener("click", () => {
              const message = getRandomPlayfulMessage();
              showToast(message);
            });
          }
        });
      }

      // End game
      function endGame(won) {
        showGameOverScreen(won);
      }

      // Helper function to get color codes
      function getColorCode(color) {
        const colorMap = {
          yellow: "#f9df84",
          green: "#a0c35a",
          blue: "#b0c4ef",
          purple: "#ba81c5",
        };
        return colorMap[color] || "#999";
      }

      // Show how to play popup
      function showHowToPlayPopup() {
        const popup = document.getElementById("how-to-play-popup");
        popup.classList.add("show");
      }

      // Close how to play popup
      function closeHowToPlayPopup() {
        const popup = document.getElementById("how-to-play-popup");
        popup.classList.remove("show");
      }

      // Event listeners
      shuffleBtn.addEventListener("click", shuffleWords);
      deselectBtn.addEventListener("click", deselectAll);
      submitBtn.addEventListener("click", submitGuess);
      playAgainBtn.addEventListener("click", () => {
        // If cooldown just ended, clear all saved data first
        if (!isInCooldown()) {
          localStorage.removeItem("sonnections_lastAttemptTime");
          clearSavedGameState();
          localStorage.removeItem("sonnections_lastAttempts");
          gameOverEl.classList.remove("show");
        }
        initGame();
      });
      document
        .getElementById("helpIcon")
        .addEventListener("click", showHowToPlayPopup);

      // Initialize game on load
      initGame();
    </script>

    <!-- Early Access Popup -->
    <div class="early-access-popup" id="early-access-popup">
      <button class="close-btn" onclick="closeEarlyAccessPopup()">✕</button>
      <h2>You Found It!</h2>
      <p>
        No harmony escapes you!<br /><br />Your ears have led you to something
        still in harmony.
      </p>
      <p style="font-style: italic; font-size: 1rem; color: #999">
        The next movement hasn't been composed yet...
      </p>
      <button class="btn" onclick="closeEarlyAccessPopup()">I hear you</button>
    </div>

    <!-- How to Play Popup -->
    <div class="how-to-play-popup" id="how-to-play-popup">
      <button class="close-btn" onclick="closeHowToPlayPopup()">✕</button>
      <h2>How to Play</h2>
      <p>Find groups of four items that share something in common.</p>

      <ul>
        <li>
          Select four items and tap <strong>'Submit'</strong> to check if your
          guess is correct.
        </li>
        <li>Find the groups without making 4 mistakes!</li>
      </ul>

      <h3>Category Examples</h3>
      <ul>
        <li><strong>FISH:</strong> Bass, Flounder, Salmon, Trout</li>
        <li><strong>FIRE ___:</strong> Ant, Drill, Island, Opal</li>
      </ul>

      <p>
        Categories will always be more specific than "5-LETTER-WORDS," "NAMES"
        or "VERBS."
      </p>

      <p>
        Each puzzle has exactly one solution. Watch out for words that seem to
        belong to multiple categories!
      </p>

      <p>
        Each group is assigned a color, which will be revealed as you solve:
      </p>

      <div class="difficulty-colors">
        <div class="difficulty-item">
          <div class="color-box color-yellow"></div>
          <span>Straightforward</span>
        </div>
        <div class="difficulty-item">
          <div class="color-box color-green"></div>
          <span>↓</span>
        </div>
        <div class="difficulty-item">
          <div class="color-box color-blue"></div>
          <span></span>
        </div>
        <div class="difficulty-item">
          <div class="color-box color-purple"></div>
          <span>Tricky</span>
        </div>
      </div>
    </div>
  </body>
</html>
