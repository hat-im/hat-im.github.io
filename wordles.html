<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="A Wordle-style word guessing game" />
    <title>Wordle Game</title>
    <style>
      /* Dark Mode Wordle Color Scheme */
      :root {
        --color-correct: #538d4e; /* Green */
        --color-present: #b59f3b; /* Yellow */
        --color-absent: #3a3a3c; /* Gray */
        --color-empty: #121213; /* Dark tile background */
        --color-border: #3a3a3c; /* Dark border */
        --color-border-focus: #565758; /* Focused border */
        --color-text: #ffffff; /* White text */
        --color-bg: #121213; /* Dark background */
        --color-tile-text: #ffffff; /* White tile text */
        --animation-flip-duration: 0.5s;
        --animation-flip-delay: 0.2s;
        --animation-fade-duration: 0.4s;
        --animation-bounce-duration: 0.6s;
        --animation-slide-duration: 0.5s;
        --animation-typing-duration: 0.8s;
        --animation-collapse-duration: 0.8s;
        --animation-expand-duration: 0.6s;
        --animation-stack-duration: 1.2s;
        --ease-out-expo: cubic-bezier(0.19, 1, 0.22, 1);
        --ease-in-out-cubic: cubic-bezier(0.645, 0.045, 0.355, 1);
        --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
        --ease-smooth: cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        background-color: var(--color-bg);
        color: var(--color-text);
        line-height: 1.4;
        padding: 20px;
      }
      .container {
        max-width: 500px;
        margin: 0 auto;
        text-align: center;
        overflow: visible;
      }
      h1 {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 10px;
        letter-spacing: 0.2rem;
      }
      .completed-words-stack {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        margin-bottom: 0px;
      }
      .completed-word-row {
        position: relative;
        cursor: pointer;
        margin-bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: all 0.3s var(--ease-in-out-cubic);
        transform-origin: center;
      }
      .completed-word-row:hover {
        filter: brightness(1.1);
      }
      .completed-word-row.collapsing {
        animation: collapseUp var(--animation-collapse-duration)
          var(--ease-smooth) forwards;
      }
      .completed-word-row.moving-to-stack {
        animation: moveToStack var(--animation-stack-duration)
          var(--ease-smooth) forwards;
      }
      @keyframes collapseUp {
        0% {
          transform: translateY(0);
        }
        100% {
          transform: translateY(-67px);
        }
      }
      @keyframes moveToStack {
        0% {
          transform: translateY(0);
        }
        100% {
          transform: translateY(-50px);
        }
      }
      .completed-word-grid {
        display: grid;
        gap: 5px;
        justify-content: center;
      }
      .word-with-punctuation {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .completed-tile {
        width: 62px;
        height: 62px;
        border: 2px solid var(--color-border);
        background-color: var(--color-empty);
        color: var(--color-tile-text);
        display: inline-flex;
        justify-content: center;
        align-items: center;
        font-size: 2rem;
        font-weight: bold;
        text-transform: uppercase;
        transition: all 0.2s ease;
      }
      .completed-tile.correct {
        background-color: var(--color-correct);
        border-color: var(--color-correct);
        color: white;
      }
      .completed-tile.present {
        background-color: var(--color-present);
        border-color: var(--color-present);
        color: white;
      }
      .completed-tile.absent {
        background-color: var(--color-absent);
        border-color: var(--color-absent);
        color: white;
      }
      .punctuation-tile {
        font-size: 2rem;
        color: var(--color-text);
        font-weight: bold;
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        height: 62px;
        display: flex;
        align-items: center;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      /* Punctuation for completed words in the stack */
      .completed-word-grid .punctuation-tile {
        right: -36px;
      }
      /* Punctuation for current word grid */
      .current-word-punctuation {
        position: absolute;
        left: 67px; /* 62px tile width + 5px gap */
        top: 50%;
        transform: translateY(-50%);
        font-size: 2rem;
        color: var(--color-text);
        font-weight: bold;
        height: 62px;
        display: flex;
        align-items: center;
        z-index: 10;
      }
      .punctuation-tile.revealed {
        opacity: 1;
      }
      .correct-row-clickable {
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .correct-row-clickable:hover {
        filter: brightness(1.1);
      }
      .drawer-row {
        transition: transform 0.4s ease, height 0.4s ease, margin 0.4s ease;
        overflow: hidden;
      }
      .completed-grid-wrapper.drawer-collapsed
        .drawer-row:not([data-correct-row="true"]) {
        height: 0px !important;
        margin-bottom: 0px !important;
        visibility: hidden !important;
        z-index: -1 !important;
        overflow: hidden !important;
      }
      .completed-grid-wrapper.drawer-collapsed {
        gap: 0px !important;
      }
      .completed-word-container.drawer-collapsed .completed-grid-wrapper {
        gap: 0px !important;
      }
      .completed-grid-wrapper {
        transition: all 0.4s ease;
      }
      #game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        overflow: visible;
      }
      .current-word-container {
        margin-top: 0px;
        margin-bottom: 0px;
        overflow: visible;
      }
      .current-word-container.fade-in {
        animation: fadeInSlideUp 0.5s ease forwards;
      }
      @keyframes fadeInSlideUp {
        0% {
          opacity: 0;
          transform: translateY(30px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .game-grid {
        display: grid;
        gap: 5px;
        margin: 0 auto;
        justify-content: center;
        overflow: visible;
        position: relative;
      }
      .word-attempts {
        max-height: 0;
        overflow: hidden;
        margin-bottom: 0;
        transition: all var(--animation-expand-duration) var(--ease-out-expo);
        opacity: 0;
      }
      .word-attempts.expanded {
        max-height: 500px;
        margin-bottom: 10px;
        opacity: 1;
      }
      .word-attempts.expanding {
        animation: expandDown var(--animation-expand-duration)
          var(--ease-out-expo) forwards;
      }
      .word-attempts.collapsing {
        animation: collapseUpAttempts var(--animation-expand-duration)
          var(--ease-out-expo) forwards;
      }
      @keyframes expandDown {
        0% {
          max-height: 0;
          opacity: 0;
          transform: translateY(-20px);
        }
        50% {
          opacity: 0.5;
        }
        100% {
          max-height: 500px;
          opacity: 1;
          transform: translateY(0);
        }
      }
      @keyframes collapseUpAttempts {
        0% {
          max-height: 500px;
          opacity: 1;
          transform: translateY(0);
        }
        50% {
          opacity: 0.5;
        }
        100% {
          max-height: 0;
          opacity: 0;
          transform: translateY(-20px);
        }
      }
      .attempt-row {
        display: grid;
        gap: 5px;
        justify-content: center;
        margin-bottom: 0;
      }
      .attempt-wrapper {
        display: flex;
        justify-content: center;
        margin-bottom: 0;
      }
      .tile {
        width: 62px;
        height: 62px;
        border: 2px solid var(--color-border);
        background-color: var(--color-empty);
        color: var(--color-tile-text);
        display: inline-flex;
        justify-content: center;
        align-items: center;
        font-size: 2rem;
        font-weight: bold;
        text-transform: uppercase;
        transition: all 0.3s var(--ease-in-out-cubic);
        transform: scale(1);
        transform-style: preserve-3d;
      }
      .tile.filled {
        border-color: var(--color-border-focus);
      }
      .tile.correct {
        background-color: var(--color-correct);
        border-color: var(--color-correct);
        color: white;
      }
      .tile.present {
        background-color: var(--color-present);
        border-color: var(--color-present);
        color: white;
      }
      .tile.absent {
        background-color: var(--color-absent);
        border-color: var(--color-absent);
        color: white;
      }
      .tile.current {
        border-color: var(--color-border-focus);
        box-shadow: 0 0 0 2px var(--color-border-focus),
          0 0 20px rgba(86, 87, 88, 0.3);
        animation: currentGlow 2s ease-in-out infinite alternate;
      }
      @keyframes currentGlow {
        0% {
          box-shadow: 0 0 0 2px var(--color-border-focus),
            0 0 10px rgba(86, 87, 88, 0.2);
        }
        100% {
          box-shadow: 0 0 0 2px var(--color-border-focus),
            0 0 25px rgba(86, 87, 88, 0.5);
        }
      }
      .title-s {
        opacity: 0;
        transform: translateY(-15px) scale(0.6) rotate(-10deg);
        transition: all 1.2s var(--ease-bounce);
        display: inline-block;
      }
      .title-s.show {
        opacity: 1;
        transform: translateY(0) scale(1) rotate(0deg);
      }
      .title-s.morphing {
        animation: titleMorph 1.5s var(--ease-bounce) forwards;
      }
      @keyframes titleMorph {
        0% {
          opacity: 0;
          transform: translateY(-20px) scale(0.3) rotate(-45deg);
          filter: blur(4px);
        }
        30% {
          opacity: 0.3;
          transform: translateY(-10px) scale(0.7) rotate(-15deg);
          filter: blur(2px);
        }
        60% {
          opacity: 0.8;
          transform: translateY(5px) scale(1.1) rotate(5deg);
          filter: blur(0px);
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1) rotate(0deg);
          filter: blur(0px);
        }
      }
      .punctuation {
        font-size: 1.5rem;
        margin-left: 10px;
        color: var(--color-text);
      }
      .status-message {
        margin: 20px 0;
        font-size: 1.1rem;
        font-weight: 600;
        min-height: 25px;
      }
      .success {
        color: var(--color-correct);
      }
      .error {
        color: #e53e3e;
      }
      .loading {
        opacity: 0.7;
        pointer-events: none;
        position: relative;
        transition: all 0.3s ease;
      }
      .loading::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        margin: -10px 0 0 -10px;
        border: 3px solid transparent;
        border-top: 3px solid var(--color-correct);
        border-right: 3px solid var(--color-present);
        border-radius: 50%;
        animation: spinColorful 1.2s ease-in-out infinite;
      }
      @keyframes spinColorful {
        0% {
          transform: rotate(0deg) scale(1);
          border-top-color: var(--color-correct);
          border-right-color: var(--color-present);
        }
        25% {
          transform: rotate(90deg) scale(1.1);
          border-top-color: var(--color-present);
          border-right-color: var(--color-absent);
        }
        50% {
          transform: rotate(180deg) scale(1);
          border-top-color: var(--color-absent);
          border-right-color: var(--color-correct);
        }
        75% {
          transform: rotate(270deg) scale(1.1);
          border-top-color: var(--color-correct);
          border-right-color: var(--color-present);
        }
        100% {
          transform: rotate(360deg) scale(1);
          border-top-color: var(--color-present);
          border-right-color: var(--color-absent);
        }
      }
      .status-message.loading-text {
        animation: loadingPulse 1.5s ease-in-out infinite;
      }
      @keyframes loadingPulse {
        0%,
        100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }
      .tile.flipping {
        animation: flip3d var(--animation-flip-duration)
          var(--ease-in-out-cubic) forwards;
        transform-style: preserve-3d;
      }
      @keyframes flip3d {
        0% {
          transform: rotateX(0deg);
        }
        50% {
          transform: rotateX(-90deg);
          /* Color will be applied via JS at this point */
        }
        100% {
          transform: rotateX(0deg);
        }
      }
      /* Invalid word shake animation */
      .tile.shake {
        animation: shake 0.5s ease-in-out;
      }
      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-3px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(3px);
        }
      }
      /* Success bounce animation */
      .tile.success {
        animation: successBounce var(--animation-bounce-duration)
          cubic-bezier(0.68, -0.55, 0.265, 1.55);
      }
      @keyframes successBounce {
        0% {
          transform: scale(1);
        }
        25% {
          transform: scale(1.1) rotate(2deg);
        }
        50% {
          transform: scale(0.95) rotate(-1deg);
        }
        75% {
          transform: scale(1.05) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      .tile.typing {
        background-color: #2d2d30;
        border-color: var(--color-border-focus);
        animation: typing-pulse var(--animation-typing-duration) ease-in-out
          infinite alternate;
      }
      @keyframes typing-pulse {
        0% {
          transform: scale(1);
          box-shadow: 0 0 0 rgba(86, 87, 88, 0);
        }
        100% {
          transform: scale(1.05);
          box-shadow: 0 0 20px rgba(86, 87, 88, 0.4);
        }
      }
      .status-message.show {
        opacity: 1;
        transform: translateY(0);
      }
      @media (max-width: 480px) {
        .tile {
          width: 50px;
          height: 50px;
          font-size: 1.5rem;
        }
        h1 {
          font-size: 2rem;
        }
        .container {
          padding: 10px;
        }
      }
      .status-message {
        margin: 20px 0;
        font-size: 1.1rem;
        font-weight: 600;
        min-height: 25px;
        transition: all 0.3s ease;
        opacity: 0;
        transform: translateY(10px);
      }
      .status-message.show {
        opacity: 1;
        transform: translateY(0);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 id="main-title">Wordle<span class="title-s" id="title-s">s</span></h1>
      <div id="game-container">
        <div id="completed-words-stack" class="completed-words-stack">
          <!-- Completed words will stack here -->
        </div>
        <div id="current-word-container" class="current-word-container">
          <div
            class="word-grid-wrapper"
            style="
              position: relative;
              width: 500px;
              height: 400px;
              margin: 0 auto;
            "
          >
            <div
              class="game-grid"
              id="game-grid"
              style="
                position: absolute;
                top: 0;
                left: 50%;
                transform: translateX(-50%);
              "
            >
              <!-- Current word grid will be generated here -->
            </div>
            <div
              id="punctuation-overlay"
              style="
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 1000;
              "
            >
              <!-- Punctuation will be positioned here -->
            </div>
          </div>
        </div>
      </div>
      <div id="status-message" class="status-message"></div>
    </div>
    <script>
      // Game data embedded from Python
      const WORDS_DATA = [
        {
          word: "ANGRY",
          punctuation: "?",
          length: 5,
          guesses: 5,
        },
        {
          word: "EVEN",
          punctuation: "",
          length: 4,
          guesses: 4,
        },
        {
          word: "NOW",
          punctuation: "?",
          length: 3,
          guesses: 3,
        },
      ];
      const FIRST_LETTER_LINK = "{FIRST_LETTER_LINK}";
      const LAST_LETTER_LINK = "{LAST_LETTER_LINK}";
      // Dictionary API URLs with fallbacks
      const DICTIONARY_APIS = [
        "https://api.dictionaryapi.dev/api/v2/entries/en/",
        "https://dictionaryapi.com/api/v3/references/collegiate/json/",
      ];
      // Game state variables
      let currentWordIndex = 0;
      let currentGuessIndex = 0;
      let currentLetterIndex = 0; // Track current typing position within the row
      let gameGrid = [];
      let gameState = []; // Track tile states (correct, present, absent)
      let allWordsData = []; // Store game state for all words
      let usedGuesses = new Set(); // Track guesses used for current word
      let knownLetters = {}; // Track confirmed letter positions
      let isWordComplete = false;
      let isWordFailed = false; // Track if word failed (exceeded guesses)
      let isGameComplete = false;
      let cooldownActive = false;
      let cooldownEndTime = 0;
      let cooldownTimer = null;
      let expandedWords = new Set(); // Track which completed words show attempts
      let collapsedWords = new Set(); // Track which completed words are collapsed
      let hasCompletedFirstWord = false; // Track title change
      let isAnimating = false;
      let punctuationAnimated = false; // Track if punctuation has been animated for current word
      let gameStats = {
        wordsCompleted: 0,
        wordsFailed: 0,
        totalGuesses: 0,
        perfectWords: 0,
      };
      // Initialize the game when page loads
      document.addEventListener("DOMContentLoaded", function () {
        // Check if user wants to continue previous game
        const savedGame = localStorage.getItem("wordleGameState");
        if (savedGame && confirm("Continue previous game?")) {
          loadGameProgress();
          setupCurrentWord();
          updateUI();
        } else {
          initGame();
        }
      });
      function initGame() {
        if (WORDS_DATA.length === 0) {
          animateInvalidWord(currentGuessIndex);
          return;
        }
        // Clear all game state for fresh start
        clearGameState();
        setupCurrentWord();
        updateUI();
      }
      function clearGameState() {
        // Reset all game variables to initial state
        currentWordIndex = 0;
        currentGuessIndex = 0;
        gameGrid = [];
        gameState = [];
        allWordsData = [];
        usedGuesses.clear();
        knownLetters = {};
        isWordComplete = false;
        isWordFailed = false;
        isGameComplete = false;
        cooldownActive = false;
        cooldownEndTime = 0;
        punctuationAnimated = false;
        if (cooldownTimer) {
          clearInterval(cooldownTimer);
          cooldownTimer = null;
        }
        gameStats = {
          wordsCompleted: 0,
          wordsFailed: 0,
          totalGuesses: 0,
          perfectWords: 0,
        };
        // Initialize allWordsData with empty state for each word
        for (let i = 0; i < WORDS_DATA.length; i++) {
          allWordsData[i] = {
            gameGrid: [],
            gameState: [],
            usedGuesses: [],
            knownLetters: {},
            isComplete: false,
            isFailed: false,
            guessCount: 0,
            failedAttempts: 0,
          };
        }
        // Clear localStorage
        localStorage.removeItem("wordleGameState");
      }
      function saveCurrentWordState() {
        // Save current word state to allWordsData
        if (allWordsData[currentWordIndex]) {
          allWordsData[currentWordIndex].gameGrid = JSON.parse(
            JSON.stringify(gameGrid)
          );
          allWordsData[currentWordIndex].gameState = JSON.parse(
            JSON.stringify(gameState)
          );
          allWordsData[currentWordIndex].usedGuesses = Array.from(usedGuesses);
          allWordsData[currentWordIndex].knownLetters = JSON.parse(
            JSON.stringify(knownLetters)
          );
          allWordsData[currentWordIndex].isComplete = isWordComplete;
          allWordsData[currentWordIndex].isFailed = isWordFailed;
          allWordsData[currentWordIndex].guessCount = currentGuessIndex;
          allWordsData[currentWordIndex].currentLetterIndex =
            currentLetterIndex;
        }
      }
      function loadCurrentWordState() {
        // Load state for current word from allWordsData
        const wordData = allWordsData[currentWordIndex];
        if (wordData) {
          gameGrid = JSON.parse(JSON.stringify(wordData.gameGrid));
          gameState = JSON.parse(JSON.stringify(wordData.gameState));
          usedGuesses = new Set(wordData.usedGuesses);
          knownLetters = JSON.parse(JSON.stringify(wordData.knownLetters));
          isWordComplete = wordData.isComplete;
          isWordFailed = wordData.isFailed || false;
          currentGuessIndex = wordData.guessCount;
          currentLetterIndex = wordData.currentLetterIndex || 0;
        }
      }
      function setupCurrentWord() {
        const currentWord = WORDS_DATA[currentWordIndex];
        const wordLength = currentWord.length;
        const maxGuesses = currentWord.guesses;
        // Reset punctuation animation flag for new word
        punctuationAnimated = false;
        // Initialize empty state if this word hasn't been set up yet
        if (!allWordsData[currentWordIndex]) {
          allWordsData[currentWordIndex] = {
            gameGrid: [],
            gameState: [],
            usedGuesses: [],
            knownLetters: {},
            isComplete: false,
            guessCount: 0,
          };
          // Initialize empty grid
          for (let i = 0; i < maxGuesses; i++) {
            allWordsData[currentWordIndex].gameGrid[i] = new Array(
              wordLength
            ).fill("");
            allWordsData[currentWordIndex].gameState[i] = new Array(
              wordLength
            ).fill("");
          }
        }
        // Load state for current word
        loadCurrentWordState();
        // If gameGrid is empty, initialize it
        if (gameGrid.length === 0) {
          gameGrid = [];
          gameState = [];
          for (let i = 0; i < maxGuesses; i++) {
            gameGrid[i] = new Array(wordLength).fill("");
            gameState[i] = new Array(wordLength).fill("");
          }
          currentGuessIndex = 0;
          currentLetterIndex = 0;
          usedGuesses.clear();
          knownLetters = {};
          isWordComplete = false;
        }
        renderGrid();
      }
      function startCooldown(durationSeconds) {
        cooldownActive = true;
        cooldownEndTime = Date.now() + durationSeconds * 1000;
        // Update cooldown timer
        updateCooldownDisplay();
        cooldownTimer = setInterval(() => {
          updateCooldownDisplay();
          if (Date.now() >= cooldownEndTime) {
            endCooldown();
          }
        }, 1000);
      }
      function endCooldown() {
        cooldownActive = false;
        cooldownEndTime = 0;
        if (cooldownTimer) {
          clearInterval(cooldownTimer);
          cooldownTimer = null;
        }
        // Update the grid display
        renderGrid();
        updateUI();
        const currentWord = WORDS_DATA[currentWordIndex];
        const failedAttempts =
          allWordsData[currentWordIndex].failedAttempts || 0;
      }
      function updateCooldownDisplay() {
        if (!cooldownActive) return;
        const timeLeft = Math.max(
          0,
          Math.ceil((cooldownEndTime - Date.now()) / 1000)
        );
        if (timeLeft > 0) {
          const hours = Math.floor(timeLeft / 3600);
          const minutes = Math.floor((timeLeft % 3600) / 60);
          const seconds = timeLeft % 60;
          let timeDisplay = "";
          if (hours > 0) {
            timeDisplay = `${hours}h ${minutes}m ${seconds}s`;
          } else if (minutes > 0) {
            timeDisplay = `${minutes}m ${seconds}s`;
          } else {
            timeDisplay = `${seconds}s`;
          }
          animateInvalidWord(currentGuessIndex);
        }
      }
      function resetCurrentWordForRetry() {
        // Reset the current word state to allow retry after cooldown
        const currentWord = WORDS_DATA[currentWordIndex];
        const wordLength = currentWord.length;
        const maxGuesses = currentWord.guesses;
        // Clear current attempt data but keep failure count
        currentGuessIndex = 0;
        currentLetterIndex = 0;
        gameGrid = [];
        gameState = [];
        usedGuesses.clear();
        knownLetters = {};
        isWordComplete = false;
        isWordFailed = false;
        // Reinitialize grid
        for (let i = 0; i < maxGuesses; i++) {
          gameGrid[i] = new Array(wordLength).fill("");
          gameState[i] = new Array(wordLength).fill("");
        }
        // Update stored data (but keep failedAttempts count)
        if (allWordsData[currentWordIndex]) {
          allWordsData[currentWordIndex].gameGrid = JSON.parse(
            JSON.stringify(gameGrid)
          );
          allWordsData[currentWordIndex].gameState = JSON.parse(
            JSON.stringify(gameState)
          );
          allWordsData[currentWordIndex].usedGuesses = [];
          allWordsData[currentWordIndex].knownLetters = {};
          allWordsData[currentWordIndex].isComplete = false;
          allWordsData[currentWordIndex].isFailed = false;
          allWordsData[currentWordIndex].guessCount = 0;
          // Keep failedAttempts count for progressive tracking
        }
      }
      function calculateCooldownDuration(failedAttempts) {
        // Fixed 1-hour cooldown for any failure
        // For testing, you can change this to a shorter duration like 10 seconds:
        return 10; // 10 seconds for testing
        // return 60 * 60; // 3600 seconds = 1 hour
      }
      function updateTitle() {
        const titleElement = document.querySelector("h1");
        if (hasCompletedFirstWord && titleElement.textContent === "Wordle") {
          titleElement.textContent = "Wordles";
          titleElement.style.transition = "all 0.5s ease";
        }
      }
      function renderCompletedWordsStack() {
        const stackContainer = document.getElementById("completed-words-stack");
        stackContainer.innerHTML = "";
        // Render all completed words in order (including current word if it's complete)
        const endIndex = isWordComplete
          ? currentWordIndex + 1
          : currentWordIndex;
        for (let i = 0; i < endIndex; i++) {
          const wordData = allWordsData[i];
          const wordInfo = WORDS_DATA[i];
          if (wordData && wordData.isComplete) {
            const wordRow = createCompletedWordRow(i, wordData, wordInfo);
            stackContainer.appendChild(wordRow);
            // Restore collapsed state if this word is in the collapsed set
            if (collapsedWords.has(i)) {
              const container = document.getElementById(`completed-word-${i}`);
              const gridWrapper = container?.querySelector(
                ".completed-grid-wrapper"
              );
              if (container && gridWrapper) {
                gridWrapper.classList.add("drawer-collapsed");
                container.classList.add("drawer-collapsed");
                // Apply transforms to maintain collapsed appearance
                const drawerRows = gridWrapper.querySelectorAll(".drawer-row");
                const correctRow = gridWrapper.querySelector(
                  '[data-correct-row="true"]'
                );
                if (correctRow) {
                  const correctRowIndex = parseInt(correctRow.dataset.rowIndex);
                  drawerRows.forEach((row) => {
                    const rowIndex = parseInt(row.dataset.rowIndex);
                    if (rowIndex !== correctRowIndex) {
                      const isAbove = rowIndex < correctRowIndex;
                      const distance =
                        Math.abs(rowIndex - correctRowIndex) * 67;
                      if (isAbove) {
                        row.style.transform = `translateY(${distance}px)`;
                      } else {
                        row.style.transform = `translateY(-${distance}px)`;
                      }
                    }
                  });
                }
              }
            }
          }
        }
      }
      function createCompletedWordRow(wordIndex, wordData, wordInfo) {
        const wordContainer = document.createElement("div");
        wordContainer.className = "completed-word-container";
        wordContainer.id = `completed-word-${wordIndex}`;
        // Create a complete grid showing all rows (used and unused)
        const gridWrapper = document.createElement("div");
        gridWrapper.className = "completed-grid-wrapper";
        gridWrapper.style.position = "relative";
        gridWrapper.style.display = "flex";
        gridWrapper.style.flexDirection = "column";
        gridWrapper.style.alignItems = "center";
        gridWrapper.style.gap = "5px";
        gridWrapper.style.overflow = "hidden";
        const correctRowIndex = wordData.guessCount - 1; // The row where the correct guess was made
        const maxGuesses = wordInfo.guesses;
        // Show all rows including empty ones
        for (let row = 0; row < maxGuesses; row++) {
          const rowWrapper = document.createElement("div");
          rowWrapper.className = "completed-word-grid drawer-row";
          rowWrapper.dataset.rowIndex = row;
          rowWrapper.dataset.correctRow = row === correctRowIndex;
          rowWrapper.style.gridTemplateColumns = `repeat(${wordInfo.length}, 62px)`;
          rowWrapper.style.transition =
            "transform 0.4s ease, height 0.4s ease, margin 0.4s ease";
          // Mark correct row as clickable and set z-index
          if (row === correctRowIndex) {
            rowWrapper.style.cursor = "pointer";
            rowWrapper.onclick = () => toggleWordDrawer(wordIndex);
            rowWrapper.classList.add("correct-row-clickable");
            rowWrapper.style.zIndex = "10"; // Keep correct row on top
            rowWrapper.style.position = "relative";
          } else {
            rowWrapper.style.zIndex = "1"; // Other rows go underneath
            rowWrapper.style.position = "relative";
          }
          // Set initial values to ensure animations work from first click
          rowWrapper.style.height = "62px";
          rowWrapper.style.visibility = "visible";
          // Add tiles for this row
          for (let col = 0; col < wordInfo.length; col++) {
            const tile = document.createElement("div");
            tile.className = "completed-tile";
            // Get letter and state from saved data
            const letter =
              wordData.gameGrid[row] && wordData.gameGrid[row][col]
                ? wordData.gameGrid[row][col]
                : "";
            const state =
              wordData.gameState[row] && wordData.gameState[row][col]
                ? wordData.gameState[row][col]
                : "";
            tile.textContent = letter;
            // Apply color state if available
            if (state) {
              tile.classList.add(state);
            }
            rowWrapper.appendChild(tile);
          }
          // Add punctuation if present (positioned next to the correct row)
          if (wordInfo.punctuation && row === correctRowIndex) {
            rowWrapper.style.position = "relative";
            const punctuationSpan = document.createElement("span");
            punctuationSpan.className = "punctuation-tile revealed";
            punctuationSpan.textContent = wordInfo.punctuation;
            punctuationSpan.style.position = "absolute";
            punctuationSpan.style.right = "-36px";
            punctuationSpan.style.top = "50%";
            punctuationSpan.style.transform = "translateY(-50%)";
            punctuationSpan.style.height = "62px";
            punctuationSpan.style.display = "flex";
            punctuationSpan.style.alignItems = "center";
            punctuationSpan.style.fontSize = "2rem";
            punctuationSpan.style.fontWeight = "bold";
            punctuationSpan.style.color = "var(--color-text)";
            punctuationSpan.style.opacity = "1";
            punctuationSpan.style.visibility = "visible";
            rowWrapper.appendChild(punctuationSpan);
          }
          gridWrapper.appendChild(rowWrapper);
        }
        wordContainer.appendChild(gridWrapper);
        return wordContainer;
      }
      function toggleWordDrawer(wordIndex) {
        const wordContainer = document.getElementById(
          `completed-word-${wordIndex}`
        );
        if (!wordContainer) return;
        const gridWrapper = wordContainer.querySelector(
          ".completed-grid-wrapper"
        );
        const drawerRows = gridWrapper.querySelectorAll(".drawer-row");
        const correctRow = gridWrapper.querySelector(
          '[data-correct-row="true"]'
        );
        if (!correctRow) return;
        const correctRowIndex = parseInt(correctRow.dataset.rowIndex);
        const isCurrentlyCollapsed =
          gridWrapper.classList.contains("drawer-collapsed");
        if (isCurrentlyCollapsed) {
          // Expand: show all rows with sliding animation
          gridWrapper.classList.remove("drawer-collapsed");
          wordContainer.classList.remove("drawer-collapsed");
          collapsedWords.delete(wordIndex); // Remove from collapsed set
          drawerRows.forEach((row, index) => {
            const rowIndex = parseInt(row.dataset.rowIndex);
            if (rowIndex !== correctRowIndex) {
              // Animate the slide back to original position
              setTimeout(() => {
                row.style.transform = "translateY(0)";
              }, 50);
            }
          });
          // Animate adjacent wordles after expansion completes
          setTimeout(() => {
            animateAdjacentWordles();
          }, 450);
        } else {
          // Collapse: hide all rows except correct one by sliding them toward the correct row
          gridWrapper.classList.add("drawer-collapsed");
          wordContainer.classList.add("drawer-collapsed");
          collapsedWords.add(wordIndex); // Add to collapsed set
          drawerRows.forEach((row, index) => {
            const rowIndex = parseInt(row.dataset.rowIndex);
            if (rowIndex !== correctRowIndex) {
              // ALL rows slide toward the correct row position
              const isAbove = rowIndex < correctRowIndex;
              const distance = Math.abs(rowIndex - correctRowIndex) * 67; // 62px tile + 5px gap
              if (isAbove) {
                // Rows above slide DOWN toward the correct row
                row.style.transform = `translateY(${distance}px)`;
              } else {
                // Rows below slide UP toward the correct row
                row.style.transform = `translateY(-${distance}px)`;
              }
              // Animate adjacent wordles after all animations complete
              if (
                rowIndex ===
                Math.max(
                  ...Array.from(drawerRows).map((r) =>
                    parseInt(r.dataset.rowIndex)
                  )
                )
              ) {
                setTimeout(() => {
                  animateAdjacentWordles();
                }, 450);
              }
            }
          });
        }
      }
      function animateAdjacentWordles() {
        const stackContainer = document.getElementById("completed-words-stack");
        if (!stackContainer) return;
        const completedWords = Array.from(
          stackContainer.querySelectorAll(".completed-word-container")
        );
        // Add smooth transition to all word containers for repositioning
        completedWords.forEach((wordContainer) => {
          wordContainer.style.transition = "transform 0.3s ease";
        });
        // Force layout recalculation to trigger the repositioning animation
        requestAnimationFrame(() => {
          // Trigger a reflow to make flexbox recalculate positions
          stackContainer.offsetHeight;
          // The height changes from display:none will cause natural repositioning
          // with the smooth transitions we just added
          // Clean up transitions after animation
          setTimeout(() => {
            completedWords.forEach((wordContainer) => {
              wordContainer.style.transition = "";
            });
          }, 300);
        });
      }
      function renderCurrentWordGrid() {
        const currentWord = WORDS_DATA[currentWordIndex];
        const wordLength = currentWord.length;
        const maxGuesses = currentWord.guesses;
        const gridContainer = document.getElementById("game-grid");
        gridContainer.innerHTML = "";
        gridContainer.style.gridTemplateColumns = `repeat(${wordLength}, 62px)`;
        for (let row = 0; row < maxGuesses; row++) {
          for (let col = 0; col < wordLength; col++) {
            const tile = document.createElement("div");
            tile.className = "tile";
            tile.id = `tile-${row}-${col}`;
            const letter = gameGrid[row] ? gameGrid[row][col] : "";
            tile.textContent = letter;
            if (letter) {
              tile.classList.add("filled");
              // Apply color state if available
              const state = gameState[row] ? gameState[row][col] : "";
              if (state) {
                tile.classList.add(state);
              }
            }
            // Highlight current typing position
            if (
              row === currentGuessIndex &&
              col === currentLetterIndex &&
              !isWordComplete &&
              !isWordFailed &&
              !cooldownActive
            ) {
              tile.classList.add("current");
            }
            gridContainer.appendChild(tile);
          }
        }
        // Handle punctuation separately in the overlay
        renderPunctuation();
      }
      function renderPunctuation() {
        // NEVER clear overlay if there's animated punctuation visible
        const punctuationOverlay = document.getElementById(
          "punctuation-overlay"
        );
        // If punctuation has been animated for this word, NEVER touch the overlay
        if (punctuationAnimated) {
          return;
        }
        // Skip rendering punctuation in overlay if we're beyond the current word
        if (currentWordIndex >= WORDS_DATA.length) {
          return;
        }
        const currentWord = WORDS_DATA[currentWordIndex];
        // Only clear overlay if no punctuation is currently animated
        if (!punctuationAnimated) {
          punctuationOverlay.innerHTML = "";
        }
        // Don't render anything else - punctuation should only be rendered by animation
      }
      function renderGrid() {
        renderCompletedWordsStack();
        renderCurrentWordGrid();
        updateTitle();
      }
      function addLetter(letter) {
        const currentWord = WORDS_DATA[currentWordIndex];
        if (isWordComplete || isWordFailed || cooldownActive || isAnimating) {
          return;
        }
        if (currentLetterIndex < currentWord.length) {
          gameGrid[currentGuessIndex][currentLetterIndex] = letter;
          currentLetterIndex++;
          renderGrid();
        }
      }
      function deleteLetter() {
        if (isWordComplete || isWordFailed || cooldownActive || isAnimating) {
          return;
        }
        if (currentLetterIndex > 0) {
          currentLetterIndex--;
          gameGrid[currentGuessIndex][currentLetterIndex] = "";
          renderGrid();
        }
      }
      async function makeGuess() {
        const currentWord = WORDS_DATA[currentWordIndex];
        // Prevent action during animations or cooldown
        if (isAnimating || cooldownActive) {
          updateCooldownDisplay();
          return;
        }
        // Get current guess from grid
        const guess = gameGrid[currentGuessIndex].join("");
        // Basic validation
        if (guess.length !== currentWord.length) {
          animateInvalidWord(currentGuessIndex);
          return;
        }
        if (currentGuessIndex >= currentWord.guesses) {
          return;
        }
        if (isWordComplete || isWordFailed) {
          return;
        }
        // Check for repeat guess
        if (usedGuesses.has(guess)) {
          animateInvalidWord(currentGuessIndex);
          return;
        }
        // Validate green letter constraints
        if (!validateGreenConstraints(guess)) {
          animateInvalidWord(currentGuessIndex);
          return;
        }
        // Validate against dictionary
        const isValidWord = await validateGuessWithFallback(guess);
        if (!isValidWord) {
          animateInvalidWord(currentGuessIndex);
          return;
        }
        // Store the guess
        usedGuesses.add(guess);
        // Check the guess and animate the results
        const results = checkWord(guess, currentGuessIndex);
        await animateFlipTiles(currentGuessIndex, results);
        currentGuessIndex++;
        currentLetterIndex = 0; // Reset for next row
        if (guess === currentWord.word) {
          // Word completed successfully
          isWordComplete = true;
          // Trigger title change animation for first word completion
          if (currentWordIndex === 0 && !hasCompletedFirstWord) {
            animateTitleChange();
          }
          // Skip all success animations - go straight to grid transition
          gameStats.wordsCompleted++;
          gameStats.totalGuesses += currentGuessIndex;
          if (currentGuessIndex === 1) gameStats.perfectWords++;
          // Animate punctuation fade-in if word has punctuation
          if (
            currentWord.punctuation &&
            currentWord.punctuation.trim() !== ""
          ) {
            animatePunctuationFadeIn();
          }
          // Perform the grid transition animation
          await animateGridTransition();
          // Wait a bit for animations to complete, then transition
          setTimeout(() => {
            if (currentWordIndex < WORDS_DATA.length - 1) {
              nextWord();
            } else {
              handleLastWordCompletion();
            }
          }, 500);
        } else if (currentGuessIndex >= currentWord.guesses) {
          // Word failed - exceeded guess limit, but allow retry after cooldown
          gameStats.wordsFailed++;
          // Track failed attempts for this word
          if (!allWordsData[currentWordIndex].failedAttempts) {
            allWordsData[currentWordIndex].failedAttempts = 0;
          }
          allWordsData[currentWordIndex].failedAttempts++;
          const failedAttempts = allWordsData[currentWordIndex].failedAttempts;
          const cooldownDuration = calculateCooldownDuration(failedAttempts);
          // Reset word for retry after cooldown
          resetCurrentWordForRetry();
          // Start cooldown
          startCooldown(cooldownDuration);
        }
        renderGrid();
        saveCurrentWordState();
        saveGameProgress();
      }
      function validateGreenConstraints(guess) {
        // Check if guess respects known correct letter positions
        for (let pos in knownLetters) {
          if (guess[pos] !== knownLetters[pos]) {
            return false;
          }
        }
        return true;
      }
      async function validateGuessWithFallback(word) {
        // For testing, allow common words immediately
        const commonWords = [
          "THE",
          "AND",
          "FOR",
          "ARE",
          "BUT",
          "NOT",
          "YOU",
          "ALL",
          "CAN",
          "HER",
          "WAS",
          "ONE",
          "OUR",
          "HAD",
          "BY",
          "HOT",
          "WORD",
          "WHAT",
          "SOME",
          "WE",
          "IT",
          "DO",
          "OUT",
          "OTHER",
          "MANY",
          "TIME",
          "VERY",
          "WHEN",
          "COME",
          "HERE",
          "HOW",
          "JUST",
          "LIKE",
          "LONG",
          "MAKE",
          "MUCH",
          "OVER",
          "SUCH",
          "TAKE",
          "THAN",
          "THEM",
          "WELL",
          "WERE",
          "WILL",
          "WITH",
          "HAVE",
          "THIS",
          "THAT",
          "FROM",
          "THEY",
          "KNOW",
          "WANT",
          "BEEN",
          "GOOD",
          "SOME",
          "TIME",
          "VERY",
          "WHEN",
          "COME",
          "HERE",
          "HELLO",
          "WORLD",
          "HOUSE",
          "WATER",
          "LIGHT",
          "RIGHT",
          "MUSIC",
          "PHONE",
          "MONEY",
          "STORY",
          "HAPPY",
          "PLACE",
          "THINK",
          "GREAT",
          "WHERE",
          "EVERY",
          "STILL",
          "SMALL",
          "FOUND",
          "THOSE",
          "NEVER",
          "UNDER",
          "MIGHT",
          "WHILE",
          "SOUND",
          "BELOW",
          "SAW",
          "SOMETHING",
          "THOUGHT",
          "BOTH",
          "CAT",
          "DOG",
          "RUN",
          "JUMP",
          "TREE",
          "BOOK",
          "LOVE",
          "HELP",
          "WORK",
          "PLAY",
          "LOOK",
          "TALK",
          "WALK",
          "READ",
          "OPEN",
          "CLOSE",
          "START",
          "STOP",
          "END",
          "BEGIN",
          "NICE",
          "COOL",
          "WARM",
          "COLD",
          "TESTS",
          "WORDS",
          "GUESS",
          "GAMES",
          "LETTERS",
          "TILES",
          "VALID",
          "WRONG",
          "RIGHT",
          "CHECK",
        ];
        if (commonWords.includes(word.toUpperCase())) {
          return true;
        }
        // Try dictionary API
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 3000);
          const response = await fetch(
            `https://api.dictionaryapi.dev/api/v2/entries/en/${word.toLowerCase()}`,
            { signal: controller.signal }
          );
          clearTimeout(timeoutId);
          if (response.ok) {
            const data = await response.json();
            if (Array.isArray(data) && data.length > 0) {
              return true;
            }
          } else if (response.status === 404) {
            return false;
          }
        } catch (error) {}
        // Reject obviously invalid words
        if (word.length < 2 || !/^[A-Z]+$/.test(word)) {
          return false;
        }
        // Allow as fallback but warn
        return true;
      }
      function checkWord(guess, rowIndex) {
        const currentWord = WORDS_DATA[currentWordIndex];
        const targetWord = currentWord.word;
        const targetLetters = targetWord.split("");
        const guessLetters = guess.split("");
        // Initialize result arrays
        const result = new Array(targetWord.length);
        const targetLetterCounts = {};
        // Count letters in target word
        for (let letter of targetLetters) {
          targetLetterCounts[letter] = (targetLetterCounts[letter] || 0) + 1;
        }
        // First pass: mark correct letters (green)
        for (let i = 0; i < guessLetters.length; i++) {
          if (guessLetters[i] === targetLetters[i]) {
            result[i] = "correct";
            targetLetterCounts[guessLetters[i]]--;
            // Track known correct positions
            knownLetters[i] = guessLetters[i];
          }
        }
        // Second pass: mark present letters (yellow) and absent letters (gray)
        for (let i = 0; i < guessLetters.length; i++) {
          if (result[i] === "correct") {
            continue; // Already marked as correct
          }
          const letter = guessLetters[i];
          if (targetLetterCounts[letter] > 0) {
            result[i] = "present";
            targetLetterCounts[letter]--;
          } else {
            result[i] = "absent";
          }
        }
        // Apply styles to tiles
        for (let i = 0; i < result.length; i++) {
          const tile = document.getElementById(`tile-${rowIndex}-${i}`);
          const state = result[i];
          // Remove any existing state classes
          tile.classList.remove("correct", "present", "absent");
          // Add new state class
          tile.classList.add(state);
          // Store state for this tile
          gameState[rowIndex][i] = state;
        }
        return result;
      }
      function animateTiles(rowIndex) {
        // Placeholder for tile animations
      }
      function handleLastWordCompletion() {
        // Handle the last word completion with auto-collapse animation
        const lastWordIndex = currentWordIndex;
        // Save the current word state
        saveCurrentWordState();
        // Clear punctuation animation flag and overlay - game is ending
        punctuationAnimated = false;
        const punctuationOverlay = document.getElementById(
          "punctuation-overlay"
        );
        if (punctuationOverlay) {
          punctuationOverlay.innerHTML = "";
        }
        // Move to "post-game" state by incrementing currentWordIndex
        currentWordIndex++;
        // Hide the current word grid since there's no next word
        const currentWordContainer = document.getElementById(
          "current-word-container"
        );
        if (currentWordContainer) {
          currentWordContainer.style.display = "none";
        }
        // Render only the completed words stack
        renderCompletedWordsStack();
        updateUI();
        // Auto-collapse the last completed word with animation
        setTimeout(() => {
          const completedWordContainer = document.getElementById(
            `completed-word-${lastWordIndex}`
          );
          if (completedWordContainer) {
            const gridWrapper = completedWordContainer.querySelector(
              ".completed-grid-wrapper"
            );
            if (
              gridWrapper &&
              !gridWrapper.classList.contains("drawer-collapsed")
            ) {
              // Trigger the collapse animation
              toggleWordDrawer(lastWordIndex);
            }
          }
        }, 200);
        // Show game complete after collapse animation
        setTimeout(() => {
          showGameComplete();
        }, 700); // Give time for collapse animation to complete
      }
      function nextWord() {
        if (currentWordIndex < WORDS_DATA.length - 1) {
          // Save current word state before switching
          saveCurrentWordState();
          const previousWordIndex = currentWordIndex; // Store the index of the word that was just completed
          // FIRST: Clear the punctuation animation flag and overlay
          // Now that the word is saved, punctuation will be rendered in completed stack
          punctuationAnimated = false;
          const punctuationOverlay = document.getElementById(
            "punctuation-overlay"
          );
          if (punctuationOverlay) {
            punctuationOverlay.innerHTML = "";
          }
          currentWordIndex++;
          setupCurrentWord();
          updateUI();
          saveGameProgress();
          // Auto-collapse the previously completed word with animation
          setTimeout(() => {
            const completedWordContainer = document.getElementById(
              `completed-word-${previousWordIndex}`
            );
            if (completedWordContainer) {
              // Check if it's not already collapsed (it should be expanded when first rendered)
              const gridWrapper = completedWordContainer.querySelector(
                ".completed-grid-wrapper"
              );
              if (
                gridWrapper &&
                !gridWrapper.classList.contains("drawer-collapsed")
              ) {
                // Trigger the collapse animation - this will automatically add it to collapsedWords set
                toggleWordDrawer(previousWordIndex);
              }
            }
          }, 200); // Small delay to ensure the completed word is rendered in the stack
          // Trigger fade-in animation for new word
          const currentWordContainer = document.getElementById(
            "current-word-container"
          );
          if (currentWordContainer) {
            currentWordContainer.classList.add("fade-in");
            // Remove animation class after it completes
            setTimeout(() => {
              currentWordContainer.classList.remove("fade-in");
            }, 500);
          }
        }
      }
      function previousWord() {
        if (currentWordIndex > 0) {
          // Save current word state before switching
          saveCurrentWordState();
          currentWordIndex--;
          setupCurrentWord();
          updateUI();
          saveGameProgress();
        }
      }
      function updateUI() {
      }
      function startNewGame() {
        if (confirm("Start a new game? This will reset all progress.")) {
          initGame();
        }
      }
      function showGameComplete() {
        isGameComplete = true;
        // Clear any active cooldown
        if (cooldownTimer) {
          clearInterval(cooldownTimer);
          cooldownTimer = null;
        }
        cooldownActive = false;
        const completionRate = Math.round(
          (gameStats.wordsCompleted / WORDS_DATA.length) * 100
        );
        const avgGuesses =
          gameStats.totalGuesses / Math.max(gameStats.wordsCompleted, 1);
        animateInvalidWord(currentGuessIndex);
        // Clear localStorage for this session
        localStorage.removeItem("wordleGameState");
      }
      // Local storage functions
      function saveGameProgress() {
        // Save current word state first
        saveCurrentWordState();
        const gameProgressState = {
          currentWordIndex,
          currentGuessIndex,
          gameGrid,
          gameState,
          allWordsData,
          gameStats,
          usedGuesses: Array.from(usedGuesses),
          knownLetters,
          isWordComplete,
          isWordFailed,
          isGameComplete,
          cooldownActive,
          cooldownEndTime,
          expandedWords: Array.from(expandedWords),
          collapsedWords: Array.from(collapsedWords),
          hasCompletedFirstWord,
          timestamp: Date.now(),
        };
        localStorage.setItem(
          "wordleGameState",
          JSON.stringify(gameProgressState)
        );
      }
      function loadGameProgress() {
        const saved = localStorage.getItem("wordleGameState");
        if (saved) {
          try {
            const savedState = JSON.parse(saved);
            // Only load if from same session (within 24 hours)
            if (Date.now() - savedState.timestamp < 24 * 60 * 60 * 1000) {
              currentWordIndex = savedState.currentWordIndex || 0;
              currentGuessIndex = savedState.currentGuessIndex || 0;
              gameGrid = savedState.gameGrid || [];
              gameState = savedState.gameState || [];
              allWordsData = savedState.allWordsData || [];
              gameStats = savedState.gameStats || gameStats;
              usedGuesses = new Set(savedState.usedGuesses || []);
              knownLetters = savedState.knownLetters || {};
              isWordComplete = savedState.isWordComplete || false;
              isWordFailed = savedState.isWordFailed || false;
              isGameComplete = savedState.isGameComplete || false;
              cooldownActive = savedState.cooldownActive || false;
              cooldownEndTime = savedState.cooldownEndTime || 0;
              expandedWords = new Set(savedState.expandedWords || []);
              collapsedWords = new Set(savedState.collapsedWords || []);
              hasCompletedFirstWord = savedState.hasCompletedFirstWord || false;
              // Ensure allWordsData is properly initialized
              if (allWordsData.length === 0) {
                for (let i = 0; i < WORDS_DATA.length; i++) {
                  allWordsData[i] = {
                    gameGrid: [],
                    gameState: [],
                    usedGuesses: [],
                    knownLetters: {},
                    isComplete: false,
                    guessCount: 0,
                  };
                }
              }
              // Resume cooldown if it was active
              if (cooldownActive && cooldownEndTime > Date.now()) {
                updateCooldownDisplay();
                cooldownTimer = setInterval(() => {
                  updateCooldownDisplay();
                  if (Date.now() >= cooldownEndTime) {
                    endCooldown();
                  }
                }, 1000);
              } else if (cooldownActive) {
                // Cooldown expired while game was closed
                cooldownActive = false;
                cooldownEndTime = 0;
              }
            } else {
              localStorage.removeItem("wordleGameState");
            }
          } catch (error) {
            console.error("Error loading game progress:", error);
            localStorage.removeItem("wordleGameState");
          }
        }
      }
      // Global keyboard handling for direct grid input
      document.addEventListener("keydown", function (event) {
        // Don't interfere with browser shortcuts
        if (event.ctrlKey || event.metaKey || event.altKey) {
          return; // Let browser handle Ctrl+R, Cmd+W, Alt+Tab, etc.
        }
        // Only process if game is active
        if (isWordComplete || isWordFailed || cooldownActive) {
          return;
        }
        const isLetter = /^[a-zA-Z]$/.test(event.key);
        // Only prevent default for keys we actually use
        if (event.key === "Enter") {
          event.preventDefault();
          makeGuess();
        } else if (event.key === "Backspace" || event.key === "Delete") {
          event.preventDefault();
          deleteLetter();
        } else if (isLetter) {
          event.preventDefault();
          addLetter(event.key.toUpperCase());
        }
        // All other keys (F5, Ctrl+R, Cmd+W, etc.) pass through normally
      });
      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      async function animateFlipTiles(rowIndex, results) {
        if (!results || !Array.isArray(results)) {
          console.error("Invalid results passed to animateFlipTiles:", results);
          isAnimating = false;
          return;
        }
        isAnimating = true;
        const currentWord = WORDS_DATA[currentWordIndex];
        // Get the actual CSS variable values from the DOM (cached for performance)
        const rootStyles = getComputedStyle(document.documentElement);
        const flipDurationStr = rootStyles
          .getPropertyValue("--animation-flip-duration")
          .trim();
        const flipDelayStr = rootStyles
          .getPropertyValue("--animation-flip-delay")
          .trim();
        // Convert CSS time values to milliseconds
        const flipDuration =
          parseFloat(flipDurationStr) *
          (flipDurationStr.includes("ms") ? 1 : 1000);
        const flipDelay =
          parseFloat(flipDelayStr) * (flipDelayStr.includes("ms") ? 1 : 1000);
        const halfFlip = flipDuration / 2;
        // Collect tiles for batch operations
        const tilesToFlip = [];
        for (let i = 0; i < currentWord.length; i++) {
          const tile = document.getElementById(`tile-${rowIndex}-${i}`);
          if (tile) {
            tilesToFlip.push({ tile: tile, index: i, state: results[i] });
          }
        }
        // Clear any existing animation classes first (batch operation)
        tilesToFlip.forEach((tileData) => {
          const tile = tileData.tile;
          tile.classList.remove("flipping", "correct", "present", "absent");
        });
        // Wait a moment for cleanup
        await new Promise((resolve) => setTimeout(resolve, 30));
        // Start all animations with staggered delays
        const animationPromises = tilesToFlip.map((tileData) => {
          const tile = tileData.tile;
          const index = tileData.index;
          const state = tileData.state;
          return new Promise((resolve) => {
            setTimeout(() => {
              // Use requestAnimationFrame for smooth animation start
              requestAnimationFrame(() => {
                // Optimize for animation
                tile.style.willChange = "transform";
                tile.classList.add("flipping");
                // Change color at midpoint (50%)
                setTimeout(() => {
                  tile.classList.add(state);
                  gameState[rowIndex][index] = state;
                }, flipDuration / 2);
                // Remove flip class when done and clean up
                setTimeout(() => {
                  tile.classList.remove("flipping");
                  tile.style.willChange = "auto";
                  resolve();
                }, flipDuration);
              });
            }, index * flipDelay);
          });
        });
        // Wait for all animations to complete
        await Promise.all(animationPromises);
        isAnimating = false;
      }
      async function animateSuccessRow(rowIndex) {
        const currentWord = WORDS_DATA[currentWordIndex];
        for (let i = 0; i < currentWord.length; i++) {
          const tile = document.getElementById(`tile-${rowIndex}-${i}`);
          if (tile) {
            tile.classList.add("success");
            await delay(50);
          }
        }
        setTimeout(() => {
          for (let i = 0; i < currentWord.length; i++) {
            const tile = document.getElementById(`tile-${rowIndex}-${i}`);
            if (tile) tile.classList.remove("success");
          }
        }, 600);
      }
      function animateInvalidWord(rowIndex) {
        // Check if currentWordIndex is valid
        if (
          currentWordIndex >= WORDS_DATA.length ||
          !WORDS_DATA[currentWordIndex]
        ) {
          return;
        }
        const currentWord = WORDS_DATA[currentWordIndex];
        for (let i = 0; i < currentWord.length; i++) {
          const tile = document.getElementById(`tile-${rowIndex}-${i}`);
          if (tile) tile.classList.add("shake");
        }
        setTimeout(() => {
          for (let i = 0; i < currentWord.length; i++) {
            const tile = document.getElementById(`tile-${rowIndex}-${i}`);
            if (tile) tile.classList.remove("shake");
          }
        }, 500);
      }
      function animatePunctuationFadeIn() {
        const currentWord = WORDS_DATA[currentWordIndex];
        // Don't animate if there's no punctuation
        if (!currentWord.punctuation || currentWord.punctuation.trim() === "") {
          return;
        }
        // Create punctuation element directly for animation (bypass normal rendering)
        const punctuationOverlay = document.getElementById(
          "punctuation-overlay"
        );
        const correctRowIndex = currentGuessIndex - 1;
        const wordLength = currentWord.length;
        // Clear existing punctuation first
        punctuationOverlay.innerHTML = "";
        const punctuationSpan = document.createElement("div");
        punctuationSpan.className =
          "punctuation-tile current-word-punctuation revealed";
        punctuationSpan.id = `current-punctuation-${correctRowIndex}`;
        punctuationSpan.textContent = currentWord.punctuation;
        // Position it right after the last tile of the correct row
        const gridWidth = wordLength * 62 + (wordLength - 1) * 5;
        const wrapperWidth = 500;
        const gridStartX = (wrapperWidth - gridWidth) / 2;
        const leftPosition = gridStartX + gridWidth + 10;
        const topPosition = correctRowIndex * 67; // 62px tile + 5px gap
        // Set positioning and prepare for animation
        punctuationSpan.style.position = "absolute";
        punctuationSpan.style.left = leftPosition + "px";
        punctuationSpan.style.top = topPosition + "px";
        punctuationSpan.style.width = "50px";
        punctuationSpan.style.height = "62px";
        punctuationSpan.style.display = "flex";
        punctuationSpan.style.alignItems = "center";
        punctuationSpan.style.justifyContent = "center";
        punctuationSpan.style.fontSize = "2rem";
        punctuationSpan.style.fontWeight = "bold";
        punctuationSpan.style.color = "var(--color-text)";
        punctuationSpan.style.zIndex = "1001";
        punctuationSpan.style.visibility = "visible";
        // Start with opacity 0 and small scale for animation
        punctuationSpan.style.opacity = "0";
        punctuationSpan.style.transform = "scale(0.8)";
        punctuationSpan.style.transition =
          "opacity 0.5s ease, transform 0.5s ease";
        punctuationOverlay.appendChild(punctuationSpan);
        // Set flag to prevent interference from renderPunctuation
        punctuationAnimated = true;
        // Trigger animation after a short delay
        setTimeout(() => {
          punctuationSpan.style.opacity = "1";
          punctuationSpan.style.transform = "scale(1)";
        }, 100);
      }
      function animateTitleChange() {
        if (!hasCompletedFirstWord) {
          hasCompletedFirstWord = true;
          const titleS = document.getElementById("title-s");
          if (titleS) {
            setTimeout(() => titleS.classList.add("show"), 500);
          } else {
            console.error('Element with id "title-s" not found');
          }
        }
      }
      function setLoadingState(element, isLoading) {
        if (isLoading) {
          element.classList.add("loading");
        } else {
          element.classList.remove("loading");
        }
      }
      async function animateGridTransition() {
        isAnimating = true;
        // No hiding or animation - just let the grids stack naturally
        isAnimating = false;
      }
      async function animateMoveToStack() {
        const rootStyles = getComputedStyle(document.documentElement);
        const stackDuration =
          parseFloat(
            rootStyles.getPropertyValue("--animation-stack-duration")
          ) * 1000;
        const correctRowIndex = currentGuessIndex - 1;
        const currentWord = WORDS_DATA[currentWordIndex];
        // Collect tiles for batch operations
        const correctTiles = [];
        for (let col = 0; col < currentWord.length; col++) {
          const tile = document.getElementById(
            `tile-${correctRowIndex}-${col}`
          );
          if (tile) {
            correctTiles.push(tile);
          }
        }
        // Animate the correct row moving to the stack
        return new Promise((resolve) => {
          if (correctTiles.length === 0) {
            resolve();
            return;
          }
          // Use requestAnimationFrame for smooth animation start
          requestAnimationFrame(() => {
            correctTiles.forEach((tile, index) => {
              tile.style.willChange = "transform"; // Optimize for animation
              tile.style.animation =
                "moveToStack var(--animation-stack-duration) var(--ease-out-expo) forwards";
              // Stagger tile animations slightly for organic feel
              tile.style.animationDelay = `${index * 20}ms`;
            });
            setTimeout(() => {
              // Clean up animation optimizations
              correctTiles.forEach((tile) => {
                tile.style.willChange = "auto";
                tile.style.animationDelay = "";
              });
              resolve();
            }, stackDuration + correctTiles.length * 20); // Account for stagger
          });
        });
      }
      async function animateNewGridFadeIn() {
        if (currentWordIndex >= WORDS_DATA.length - 1) {
          return; // No more words, don't create new grid
        }
        const rootStyles = getComputedStyle(document.documentElement);
        const fadeDuration =
          parseFloat(rootStyles.getPropertyValue("--animation-fade-duration")) *
          1000;
        // Wait a moment, then fade in the new grid
        return new Promise((resolve) => {
          const container = document.getElementById("current-word-container");
          if (!container) {
            resolve();
            return;
          }
          // Use requestAnimationFrame for smooth animation timing
          requestAnimationFrame(() => {
            setTimeout(() => {
              requestAnimationFrame(() => {
                container.style.willChange = "transform, opacity";
                container.classList.add("fading-in");
                setTimeout(() => {
                  container.classList.remove("fading-in");
                  container.style.willChange = "auto";
                  resolve();
                }, fadeDuration);
              });
            }, 50); // Reduced delay for smoother transition
          });
        });
      }
      function enhancedAnimateTitleChange() {
        if (!hasCompletedFirstWord) {
          hasCompletedFirstWord = true;
          const titleS = document.getElementById("title-s");
          if (titleS) {
            // Use the enhanced morphing animation
            titleS.classList.add("morphing");
            setTimeout(() => {
              titleS.classList.remove("morphing");
              titleS.classList.add("show");
            }, 1500);
          } else {
            console.error('Element with id "title-s" not found');
          }
        }
      }
      // Performance monitoring and cleanup utilities
      function cleanupAnimations() {
        // Reset all willChange properties to auto for better performance
        const allTiles = document.querySelectorAll(".tile, .completed-tile");
        allTiles.forEach((tile) => {
          tile.style.willChange = "auto";
          tile.style.animation = "";
          tile.style.animationDelay = "";
        });
        // Clean up container optimizations
        const containers = document.querySelectorAll(
          ".current-word-container, .completed-words-stack"
        );
        containers.forEach((container) => {
          container.style.willChange = "auto";
        });
        // Reset animation flag
        isAnimating = false;
      }
      function cleanupAllAnimationStyles() {
        // Comprehensive cleanup of all animation-related styles
        const allTiles = document.querySelectorAll(".tile, .completed-tile");
        allTiles.forEach((tile) => {
          tile.style.willChange = "auto";
          tile.style.animation = "";
          tile.style.animationDelay = "";
          tile.style.zIndex = "";
          tile.style.transform = "";
          tile.style.opacity = "";
          tile.style.transition = "";
        });
        // Clean up containers
        const containers = document.querySelectorAll(
          ".current-word-container, .completed-words-stack, .word-attempts"
        );
        containers.forEach((container) => {
          container.style.willChange = "auto";
          container.style.transform = "";
          container.style.opacity = "";
        });
      }
      // Add performance monitoring (development only)
      function measureAnimationPerformance(animationName, startTime) {
        const endTime = performance.now();
        const duration = endTime - startTime;
        if (duration > 100) {
          // Log if animation takes longer than 100ms
          console.warn(
            `Animation '${animationName}' took ${duration.toFixed(2)}ms`
          );
        }
      }
      // Debounced cleanup for better performance
      let cleanupTimeout;
      function scheduleCleanup() {
        if (cleanupTimeout) clearTimeout(cleanupTimeout);
        cleanupTimeout = setTimeout(cleanupAnimations, 1000);
      }
      // Add cleanup after major animations
      window.addEventListener("beforeunload", cleanupAnimations);
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          scheduleCleanup();
        }
      });
    </script>
  </body>
</html>
