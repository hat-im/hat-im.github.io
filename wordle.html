<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="A Wordle-style word guessing game" />
    <title>Wordle++</title>
    <script>
      // Mobile detection and redirect script
      (function () {
        // Check if already on mobile version
        if (window.location.pathname.includes("wordle-mobile.html")) {
          return;
        }

        // Detect mobile devices
        function isMobileDevice() {
          // Check user agent for mobile indicators
          const userAgent = navigator.userAgent.toLowerCase();
          const mobileKeywords = [
            "android",
            "webos",
            "iphone",
            "ipad",
            "ipod",
            "blackberry",
            "windows phone",
            "opera mini",
          ];

          const hasMobileKeyword = mobileKeywords.some((keyword) =>
            userAgent.includes(keyword)
          );

          // Check for touch capability and screen size
          const isTouchDevice =
            "ontouchstart" in window ||
            navigator.maxTouchPoints > 0 ||
            navigator.msMaxTouchPoints > 0;

          const hasSmallScreen =
            window.screen.width <= 768 || window.innerWidth <= 768;

          // Additional mobile checks
          const hasLimitedPointer =
            window.matchMedia("(pointer: coarse)").matches;
          const hasLimitedHover = window.matchMedia("(hover: none)").matches;

          return (
            hasMobileKeyword ||
            (isTouchDevice && hasSmallScreen) ||
            (hasLimitedPointer && hasLimitedHover)
          );
        }

        // Redirect to mobile version if on mobile device
        if (isMobileDevice()) {
          // Preserve any URL parameters or hash
          const currentUrl = new URL(window.location);
          const mobileUrl = new URL(
            "wordle-mobile.html",
            currentUrl.origin + currentUrl.pathname.replace(/\/[^\/]*$/, "/")
          );

          // Copy search parameters and hash
          mobileUrl.search = currentUrl.search;
          mobileUrl.hash = currentUrl.hash;

          // Add a parameter to indicate redirect happened (useful for analytics)
          const params = new URLSearchParams(mobileUrl.search);
          if (!params.has("mobile_redirect")) {
            params.set("mobile_redirect", "1");
            mobileUrl.search = params.toString();
          }

          // Perform redirect
          window.location.replace(mobileUrl.toString());
        }
      })();
    </script>
    <style>
      /* Dark Mode Wordle Color Scheme */
      :root {
        --color-correct: #538d4e; /* Green */
        --color-present: #b59f3b; /* Yellow */
        --color-absent: #3a3a3c; /* Gray */
        --color-empty: #121213; /* Dark tile background */
        --color-border: #3a3a3c; /* Dark border */
        --color-border-focus: #565758; /* Focused border */
        --color-text: #ffffff; /* White text */
        --color-bg: #121213; /* Dark background */
        --color-tile-text: #ffffff; /* White tile text */
        --animation-flip-duration: 0.5s;
        --animation-flip-delay: 0.2s;
        --animation-fade-duration: 0.4s;
        --animation-bounce-duration: 0.6s;
        --animation-slide-duration: 0.5s;
        --animation-typing-duration: 0.8s;
        --animation-collapse-duration: 0.8s;
        --animation-expand-duration: 0.6s;
        --animation-stack-duration: 1.2s;
        --ease-out-expo: cubic-bezier(0.19, 1, 0.22, 1);
        --ease-in-out-cubic: cubic-bezier(0.645, 0.045, 0.355, 1);
        --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
        --ease-smooth: cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: "Clear Sans", "Helvetica Neue", Arial, sans-serif;
        background-color: var(--color-bg);
        color: var(--color-text);
        line-height: 1.4;
        padding: 20px;
      }
      .container {
        max-width: 500px; /* Increased to accommodate punctuation */
        margin: 0 auto;
        text-align: center;
        overflow: visible;
      }
      h1 {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 10px;
        letter-spacing: 0.2rem;
      }
      .completed-words-stack {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        margin-bottom: 0px;
      }
      .completed-word-row {
        position: relative;
        cursor: pointer;
        margin-bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: all 0.3s var(--ease-in-out-cubic);
        transform-origin: center;
      }
      .completed-word-row:hover {
        filter: brightness(1.1);
      }
      .completed-word-row.collapsing {
        animation: collapseUp var(--animation-collapse-duration)
          var(--ease-smooth) forwards;
      }
      .completed-word-row.moving-to-stack {
        animation: moveToStack var(--animation-stack-duration)
          var(--ease-smooth) forwards;
      }
      @keyframes collapseUp {
        0% {
          transform: translateY(0);
        }
        100% {
          transform: translateY(-67px);
        }
      }
      @keyframes moveToStack {
        0% {
          transform: translateY(0);
        }
        100% {
          transform: translateY(-50px);
        }
      }
      .completed-word-grid {
        display: grid;
        gap: 5px;
        justify-content: center;
      }
      .completed-tile {
        width: 62px;
        height: 62px;
        border: 2px solid var(--color-border);
        background-color: var(--color-empty);
        color: var(--color-tile-text);
        display: inline-flex;
        justify-content: center;
        align-items: center;
        font-size: 2rem;
        font-weight: bold;
        text-transform: uppercase;
        transition: all 0.2s ease;
      }
      .completed-tile.correct {
        background-color: var(--color-correct);
        border-color: var(--color-correct);
        color: white;
      }
      .completed-tile.present {
        background-color: var(--color-present);
        border-color: var(--color-present);
        color: white;
      }
      .completed-tile.absent {
        background-color: var(--color-absent);
        border-color: var(--color-absent);
        color: white;
      }
      .punctuation-tile {
        font-size: 2rem;
        color: var(--color-text);
        font-weight: bold;
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        height: 62px;
        display: flex;
        align-items: center;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      /* Punctuation for current word grid */
      .current-word-punctuation {
        position: absolute;
        left: 67px; /* 62px tile width + 5px gap */
        top: 50%;
        transform: translateY(-50%);
        font-size: 2rem;
        color: var(--color-text);
        font-weight: bold;
        height: 62px;
        display: flex;
        align-items: center;
        z-index: 10;
      }
      .punctuation-tile.revealed {
        opacity: 1;
      }
      .correct-row-clickable {
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .correct-row-clickable:hover {
        filter: brightness(1.1);
      }
      .drawer-row {
        transition: transform 0.4s ease, height 0.4s ease, margin 0.4s ease;
        overflow: hidden;
      }
      .completed-grid-wrapper.drawer-collapsed
        .drawer-row:not([data-correct-row="true"]) {
        height: 0px !important;
        margin-bottom: 0px !important;
        visibility: hidden !important;
        z-index: -1 !important;
        overflow: hidden !important;
      }
      .completed-grid-wrapper.drawer-collapsed {
        gap: 0px !important;
      }
      .completed-word-container.drawer-collapsed .completed-grid-wrapper {
        gap: 0px !important;
      }
      .completed-grid-wrapper {
        transition: all 0.4s ease;
      }
      #game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        overflow: visible;
      }
      .current-word-container {
        margin-top: 0px;
        margin-bottom: 0px;
        overflow: visible;
      }
      .current-word-container.fade-in {
        animation: fadeInSlideUp 0.5s ease forwards;
      }
      @keyframes fadeInSlideUp {
        0% {
          opacity: 0;
          transform: translateY(30px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .game-grid {
        display: grid;
        gap: 5px;
        margin: 0 auto;
        justify-content: center;
        overflow: visible;
        position: relative;
      }
      .tile {
        width: 62px;
        height: 62px;
        border: 2px solid var(--color-border);
        background-color: var(--color-empty);
        color: var(--color-tile-text);
        display: inline-flex;
        justify-content: center;
        align-items: center;
        font-size: 2rem;
        font-weight: bold;
        text-transform: uppercase;
        transition: all 0.3s var(--ease-in-out-cubic);
        transform: scale(1);
        transform-style: preserve-3d;
      }
      .tile.filled {
        border-color: var(--color-border-focus);
      }
      .tile.correct {
        background-color: var(--color-correct);
        border-color: var(--color-correct);
        color: white;
      }
      .tile.present {
        background-color: var(--color-present);
        border-color: var(--color-present);
        color: white;
      }
      .tile.absent {
        background-color: var(--color-absent);
        border-color: var(--color-absent);
        color: white;
      }
      .tile.current {
        border-color: var(--color-border-focus);
        box-shadow: 0 0 0 2px var(--color-border-focus),
          0 0 20px rgba(86, 87, 88, 0.3);
        animation: currentGlow 2s ease-in-out infinite alternate;
      }
      @keyframes currentGlow {
        0% {
          box-shadow: 0 0 0 2px var(--color-border-focus),
            0 0 10px rgba(86, 87, 88, 0.2);
        }
        100% {
          box-shadow: 0 0 0 2px var(--color-border-focus),
            0 0 25px rgba(86, 87, 88, 0.5);
        }
      }
      .title-s {
        opacity: 0;
        transform: translateY(-15px) scale(0.6) rotate(-10deg);
        transition: all 1.2s var(--ease-bounce);
        display: inline-block;
      }
      .title-s.show {
        opacity: 1;
        transform: translateY(0) scale(1) rotate(0deg);
      }
      .title-s.morphing {
        animation: titleMorph 1.5s var(--ease-bounce) forwards;
      }

      .title-s.shaking {
        animation: titleShake 0.8s ease-in-out infinite;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .title-s.shaking:hover {
        color: var(--color-correct);
        transform: scale(1.1);
      }

      .title-s.shaking:active {
        transform: scale(0.95);
        color: var(--color-present);
      }

      @keyframes titleMorph {
        0% {
          opacity: 0;
          transform: translateY(-20px) scale(0.3) rotate(-45deg);
          filter: blur(4px);
        }
        30% {
          opacity: 0.3;
          transform: translateY(-10px) scale(0.7) rotate(-15deg);
          filter: blur(2px);
        }
        60% {
          opacity: 0.8;
          transform: translateY(5px) scale(1.1) rotate(5deg);
          filter: blur(0px);
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1) rotate(0deg);
          filter: blur(0px);
        }
      }

      @keyframes titleShake {
        0%,
        100% {
          transform: translateX(0) rotate(0deg);
        }
        10% {
          transform: translateX(-2px) rotate(-1deg);
        }
        20% {
          transform: translateX(2px) rotate(1deg);
        }
        30% {
          transform: translateX(-3px) rotate(-2deg);
        }
        40% {
          transform: translateX(3px) rotate(2deg);
        }
        50% {
          transform: translateX(-2px) rotate(-1deg);
        }
        60% {
          transform: translateX(2px) rotate(1deg);
        }
        70% {
          transform: translateX(-1px) rotate(-0.5deg);
        }
        80% {
          transform: translateX(1px) rotate(0.5deg);
        }
        90% {
          transform: translateX(-0.5px) rotate(-0.25deg);
        }
      }
      .punctuation {
        font-size: 1.5rem;
        margin-left: 10px;
        color: var(--color-text);
      }
      .status-message {
        margin: 20px 0;
        font-size: 1.1rem;
        font-weight: 600;
        min-height: 25px;
      }
      .success {
        color: var(--color-correct);
      }
      .error {
        color: #e53e3e;
      }
      .loading {
        opacity: 0.7;
        pointer-events: none;
        position: relative;
        transition: all 0.3s ease;
      }
      .loading::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        margin: -10px 0 0 -10px;
        border: 3px solid transparent;
        border-top: 3px solid var(--color-correct);
        border-right: 3px solid var(--color-present);
        border-radius: 50%;
        animation: spinColorful 1.2s ease-in-out infinite;
      }
      .title-header {
        border-bottom: 1px solid lightgrey;
        padding-bottom: 0.5em; /* Optional: adds space between text and line */
        margin-bottom: 1em; /* Optional: adds space below the header */
      }

      @keyframes spinColorful {
        0% {
          transform: rotate(0deg) scale(1);
          border-top-color: var(--color-correct);
          border-right-color: var(--color-present);
        }
        25% {
          transform: rotate(90deg) scale(1.1);
          border-top-color: var(--color-present);
          border-right-color: var(--color-absent);
        }
        50% {
          transform: rotate(180deg) scale(1);
          border-top-color: var(--color-absent);
          border-right-color: var(--color-correct);
        }
        75% {
          transform: rotate(270deg) scale(1.1);
          border-top-color: var(--color-correct);
          border-right-color: var(--color-present);
        }
        100% {
          transform: rotate(360deg) scale(1);
          border-top-color: var(--color-present);
          border-right-color: var(--color-absent);
        }
      }
      @keyframes loadingPulse {
        0%,
        100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }
      .tile.flipping {
        animation: flip3d var(--animation-flip-duration)
          var(--ease-in-out-cubic) forwards;
        transform-style: preserve-3d;
      }
      @keyframes flip3d {
        0% {
          transform: rotateX(0deg);
        }
        50% {
          transform: rotateX(-90deg);
          /* Color will be applied via JS at this point */
        }
        100% {
          transform: rotateX(0deg);
        }
      }
      /* Invalid word shake animation */
      .tile.shake {
        animation: shake 0.5s ease-in-out;
      }
      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-3px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(3px);
        }
      }
      /* Success bounce animation */
      .tile.success {
        animation: successBounce var(--animation-bounce-duration)
          cubic-bezier(0.68, -0.55, 0.265, 1.55);
      }
      @keyframes successBounce {
        0% {
          transform: scale(1);
        }
        25% {
          transform: scale(1.1) rotate(2deg);
        }
        50% {
          transform: scale(0.95) rotate(-1deg);
        }
        75% {
          transform: scale(1.05) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      .tile.typing {
        background-color: #2d2d30;
        border-color: var(--color-border-focus);
        animation: typing-pulse var(--animation-typing-duration) ease-in-out
          infinite alternate;
      }
      .tile.timer-tile {
        background-color: #3a3a3c;
        border-color: #565758;
        color: #ffffff;
        font-family: "Helvetica Neue", Arial, sans-serif;
        font-weight: bold;
        width: 62px;
        height: 62px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 2rem;
      }
      .tile.timer-tile.colon {
        background-color: transparent;
        border: none;
        font-size: 2.5rem;
      }
      .timer-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 5px;
        margin-top: 5px;
        opacity: 0;
        transform: translateY(20px);
        animation: timerFadeInSlideUp 0.5s ease forwards;
      }
      .timer-container.hidden {
        display: none;
      }
      .timer-digit {
        width: 62px;
        height: 62px;
        border: 2px solid var(--color-border-focus);
        background-color: var(--color-empty);
        color: var(--color-tile-text);
        display: inline-flex;
        justify-content: center;
        align-items: center;
        font-size: 2rem;
        font-weight: bold;
        text-transform: uppercase;
        transition: all 0.3s var(--ease-in-out-cubic);
        transform: scale(1);
        transform-style: preserve-3d;
      }
      .timer-digit.filled {
        border-color: var(--color-border-focus);
      }
      .timer-digit.colon {
        background-color: transparent;
        border: none;
        font-size: 2.5rem;
      }
      .timer-digit.flipping {
        animation: flip3d var(--animation-flip-duration)
          var(--ease-in-out-cubic) forwards;
        transform-style: preserve-3d;
      }
      @keyframes timerFadeInSlideUp {
        0% {
          opacity: 0;
          transform: translateY(20px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @keyframes timerFadeOutSlideDown {
        0% {
          opacity: 1;
          transform: translateY(0);
        }
        100% {
          opacity: 0;
          transform: translateY(20px);
        }
      }
      @keyframes typing-pulse {
        0% {
          transform: scale(1);
          box-shadow: 0 0 0 rgba(86, 87, 88, 0);
        }
        100% {
          transform: scale(1.05);
          box-shadow: 0 0 20px rgba(86, 87, 88, 0.4);
        }
      }
      .status-message.show {
        opacity: 1;
        transform: translateY(0);
      }
      @media (max-width: 480px) {
        .tile {
          width: 50px;
          height: 50px;
          font-size: 1.5rem;
        }
        h1 {
          font-size: 2rem;
        }
        .container {
          padding: 10px;
        }
      }
      .status-message {
        margin: 20px 0;
        font-size: 1.1rem;
        font-weight: 600;
        min-height: 25px;
        transition: all 0.3s ease;
        opacity: 0;
        transform: translateY(10px);
      }
      .status-message.show {
        opacity: 1;
        transform: translateY(0);
      }
      .continue-game-popup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      }
      .continue-game-popup.hidden {
        display: none;
      }
      .popup-content {
        background-color: var(--color-bg);
        padding: 30px;
        text-align: center;
        max-width: 400px;
        width: 90%;
      }
      .popup-title {
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 15px;
        color: var(--color-text);
      }
      .popup-message {
        font-size: 1rem;
        margin-bottom: 25px;
        color: var(--color-text);
        line-height: 1.4;
      }
      .popup-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
      }
      .popup-button {
        padding: 12px 24px;
        border: 2px solid var(--color-border-focus);
        background-color: var(--color-empty);
        color: var(--color-text);
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .popup-button:hover {
        background-color: var(--color-border-focus);
        transform: translateY(-1px);
      }
      .popup-button.primary {
        background-color: var(--color-correct);
        border-color: var(--color-correct);
        color: white;
      }
      .popup-button.primary:hover {
        background-color: #4a7c59;
        border-color: #4a7c59;
      }
      .toast {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--color-absent);
        color: white;
        padding: 12px 20px;
        font-size: 0.9rem;
        font-weight: 500;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.3s ease, transform 0.3s ease;
        pointer-events: none;
      }
      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(-10px);
      }
      .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 20px;
        text-align: left;
      }
      .stats-label {
        text-align: left;
        font-weight: normal;
      }
      .stats-value {
        text-align: right;
        font-weight: bold;
      }
      .star-rating {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 5px;
        margin: 20px 0;
        font-size: 2rem;
      }
      .star {
        color: #3a3a3c;
        transition: color 0.3s ease;
      }
      .star.filled {
        color: #ffd700;
      }
      .rating-text {
        font-size: 1.1rem;
        font-weight: bold;
        margin-top: 10px;
      }
      
      /* Early Access Popup - Match existing popup style */
      .early-access-popup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      }
      .early-access-popup.show {
        display: flex;
      }
      .early-access-content {
        background-color: var(--color-bg);
        padding: 30px;
        text-align: center;
        max-width: 400px;
        width: 90%;
      }
      .early-access-title {
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 15px;
        color: var(--color-text);
      }
      .early-access-message {
        font-size: 1rem;
        margin-bottom: 25px;
        color: var(--color-text);
        line-height: 1.4;
      }
      .early-access-close {
        padding: 12px 24px;
        border: 2px solid var(--color-correct);
        background-color: var(--color-correct);
        color: white;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .early-access-close:hover {
        background-color: #4a7c59;
        border-color: #4a7c59;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 id="main-title" class="title-header">
        Wordle<span class="title-s" id="title-s">s</span>
      </h1>
      <div id="game-container">
        <div id="completed-words-stack" class="completed-words-stack">
          <!-- Completed words will stack here -->
        </div>
        <div id="current-word-container" class="current-word-container">
          <div
            class="word-grid-wrapper"
            style="
              position: relative;
              width: 500px;
              height: 400px;
              margin: 0 auto;
            "
          >
            <div
              class="game-grid"
              id="game-grid"
              style="
                position: absolute;
                top: 0;
                left: 50%;
                transform: translateX(-50%);
              "
            >
              <!-- Current word grid will be generated here -->
            </div>
            <div
              id="punctuation-overlay"
              style="
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 1000;
              "
            >
              <!-- Punctuation will be positioned here -->
            </div>
          </div>
        </div>
        <div id="timer-container" class="timer-container hidden">
          <div class="timer-digit filled" id="timer-m1">0</div>
          <div class="timer-digit filled" id="timer-m2">0</div>
          <div class="timer-digit colon">:</div>
          <div class="timer-digit filled" id="timer-s1">0</div>
          <div class="timer-digit filled" id="timer-s2">0</div>
        </div>
      </div>
      <div id="status-message" class="status-message"></div>
    </div>
    <div id="continue-game-popup" class="continue-game-popup hidden">
      <div class="popup-content">
        <div class="popup-title">Hello again</div>
        <div class="popup-message">
          Do you want to start a new game, or continue where you left?
        </div>
        <div class="popup-buttons">
          <button class="popup-button primary" id="continue-game-btn">
            Continue
          </button>
          <button class="popup-button" id="new-game-btn">New Game</button>
        </div>
      </div>
    </div>
    <div id="toast" class="toast"></div>
    <div id="congratulations-popup" class="continue-game-popup hidden">
      <div class="popup-content">
        <div class="popup-title">Awesome!</div>
        <div id="congratulations-message" class="popup-message"></div>
        <div id="star-rating" class="star-rating">
          <span class="star">★</span>
          <span class="star">★</span>
          <span class="star">★</span>
        </div>
        <div id="rating-text" class="rating-text"></div>
        <div id="stats-display" class="popup-message"></div>
        <div class="popup-buttons">
          <button class="popup-button primary" id="play-again-btn">
            Play Again
          </button>
          <button class="popup-button" id="close-popup-btn">Close</button>
        </div>
      </div>
    </div>
    <script>
      // Game data embedded from Python
      const WORDS_DATA = [
        {
          word: "ANGRY",
          punctuation: "?",
          length: 5,
          guesses: 6,
          max_score: 100,
        },
        {
          word: "ME",
          punctuation: "",
          length: 2,
          guesses: 13,
          max_score: 100,
        },
        {
          word: "TOO",
          punctuation: ",",
          length: 3,
          guesses: 10,
          max_score: 90,
        },
        {
          word: "SOMETIMES",
          punctuation: ".",
          length: 9,
          guesses: 4,
          max_score: 90,
        },
        {
          word: "MOSTLY",
          punctuation: "",
          length: 6,
          guesses: 6,
          max_score: 90,
        },
        {
          word: "MISS",
          punctuation: "",
          length: 4,
          guesses: 8,
          max_score: 90,
        },
        {
          word: "YOU",
          punctuation: ".",
          length: 3,
          guesses: 10,
          max_score: 90,
        },
        {
          word: "HOPE",
          punctuation: "",
          length: 4,
          guesses: 8,
          max_score: 90,
        },
        {
          word: "YOU",
          punctuation: "",
          length: 3,
          guesses: 10,
          max_score: 90,
        },
        {
          word: "ARE",
          punctuation: "",
          length: 3,
          guesses: 10,
          max_score: 90,
        },
        {
          word: "OKAY",
          punctuation: ".",
          length: 4,
          guesses: 8,
          max_score: 90,
        },
      ];
      // Dictionary API URLs with fallbacks
      const DICTIONARY_APIS = [
        "https://api.dictionaryapi.dev/api/v2/entries/en/",
        "https://dictionaryapi.com/api/v3/references/collegiate/json/",
      ];
      // Flag to control next puzzle access
      const NEXT_PUZZLES_ENABLED = false; // Set to true to enable all next puzzles
      
      // Game state variables
      let currentWordIndex = 0;
      let currentGuessIndex = 0;
      let currentLetterIndex = 0; // Track current typing position within the row
      let gameGrid = [];
      let gameState = []; // Track tile states (correct, present, absent)
      let allWordsData = []; // Store game state for all words
      let usedGuesses = new Set(); // Track guesses used for current word
      let knownLetters = {}; // Track confirmed letter positions
      let isWordComplete = false;
      let isWordFailed = false; // Track if word failed (exceeded guesses)
      let isGameComplete = false;
      let cooldownActive = false;
      let cooldownEndTime = 0;
      let cooldownTimer = null;
      let expandedWords = new Set(); // Track which completed words show attempts
      let collapsedWords = new Set(); // Track which completed words are collapsed
      let revealedPunctuation = new Set(); // Track which words have had their punctuation revealed
      let hasCompletedFirstWord = false; // Track title change
      let isAnimating = false;
      let punctuationAnimated = false; // Track if punctuation has been animated for current word
      let gameStats = {
        wordsCompleted: 0,
        wordsFailed: 0,
        totalGuesses: 0,
        perfectWords: 0,
        totalScore: 0,
        maxPossibleScore: 0,
      };
      // Initialize the game when page loads
      document.addEventListener("DOMContentLoaded", function () {
        // Check if user wants to continue previous game
        const savedGame = localStorage.getItem("wordleGameState");
        if (savedGame) {
          try {
            const savedState = JSON.parse(savedGame);
            // Don't show continue popup if game was already complete
            if (!savedState.isGameComplete) {
              showContinueGamePopup();
            } else {
              // Game was complete, clear storage and start fresh
              localStorage.removeItem("wordleGameState");
              initGame();
            }
          } catch (error) {
            localStorage.removeItem("wordleGameState");
            initGame();
          }
        } else {
          initGame();
        }
      });
      function initGame() {
        if (WORDS_DATA.length === 0) {
          animateInvalidWord(currentGuessIndex);
          return;
        }
        // Clear all game state for fresh start
        clearGameState();
        setupCurrentWord();
        updateUI();
      }
      function clearGameState() {
        // Reset all game variables to initial state
        currentWordIndex = 0;
        currentGuessIndex = 0;
        gameGrid = [];
        gameState = [];
        allWordsData = [];
        usedGuesses.clear();
        knownLetters = {};
        isWordComplete = false;
        isWordFailed = false;
        isGameComplete = false;
        cooldownActive = false;
        cooldownEndTime = 0;
        punctuationAnimated = false;
        if (cooldownTimer) {
          clearInterval(cooldownTimer);
          cooldownTimer = null;
        }
        gameStats = {
          wordsCompleted: 0,
          wordsFailed: 0,
          totalGuesses: 0,
          perfectWords: 0,
          totalScore: 0,
          maxPossibleScore: 0,
        };
        // Initialize allWordsData with empty state for each word
        for (let i = 0; i < WORDS_DATA.length; i++) {
          allWordsData[i] = {
            gameGrid: [],
            gameState: [],
            usedGuesses: [],
            knownLetters: {},
            isComplete: false,
            isFailed: false,
            guessCount: 0,
            failedAttempts: 0,
          };
          // Calculate max possible score for this word
          gameStats.maxPossibleScore += WORDS_DATA[i].max_score;
        }
        // Clear localStorage
        localStorage.removeItem("wordleGameState");
      }
      function saveCurrentWordState() {
        // Save current word state to allWordsData
        if (allWordsData[currentWordIndex]) {
          allWordsData[currentWordIndex].gameGrid = JSON.parse(
            JSON.stringify(gameGrid)
          );
          allWordsData[currentWordIndex].gameState = JSON.parse(
            JSON.stringify(gameState)
          );
          allWordsData[currentWordIndex].usedGuesses = Array.from(usedGuesses);
          allWordsData[currentWordIndex].knownLetters = JSON.parse(
            JSON.stringify(knownLetters)
          );
          allWordsData[currentWordIndex].isComplete = isWordComplete;
          allWordsData[currentWordIndex].isFailed = isWordFailed;
          allWordsData[currentWordIndex].guessCount = currentGuessIndex;
          allWordsData[currentWordIndex].currentLetterIndex =
            currentLetterIndex;
        }
      }
      function loadCurrentWordState() {
        // Load state for current word from allWordsData
        const wordData = allWordsData[currentWordIndex];
        if (wordData) {
          gameGrid = JSON.parse(JSON.stringify(wordData.gameGrid));
          gameState = JSON.parse(JSON.stringify(wordData.gameState));
          usedGuesses = new Set(wordData.usedGuesses);
          knownLetters = JSON.parse(JSON.stringify(wordData.knownLetters));
          isWordComplete = wordData.isComplete;
          isWordFailed = wordData.isFailed || false;
          currentGuessIndex = wordData.guessCount;
          currentLetterIndex = wordData.currentLetterIndex || 0;
        }
      }
      function setupCurrentWord() {
        const currentWord = WORDS_DATA[currentWordIndex];
        const wordLength = currentWord.length;
        const maxGuesses = currentWord.guesses;
        // Reset punctuation animation flag for new word
        punctuationAnimated = false;
        // Initialize empty state if this word hasn't been set up yet
        if (!allWordsData[currentWordIndex]) {
          allWordsData[currentWordIndex] = {
            gameGrid: [],
            gameState: [],
            usedGuesses: [],
            knownLetters: {},
            isComplete: false,
            guessCount: 0,
          };
          // Initialize empty grid
          for (let i = 0; i < maxGuesses; i++) {
            allWordsData[currentWordIndex].gameGrid[i] = new Array(
              wordLength
            ).fill("");
            allWordsData[currentWordIndex].gameState[i] = new Array(
              wordLength
            ).fill("");
          }
        }
        // Load state for current word
        loadCurrentWordState();
        // If gameGrid is empty, initialize it
        if (gameGrid.length === 0) {
          gameGrid = [];
          gameState = [];
          for (let i = 0; i < maxGuesses; i++) {
            gameGrid[i] = new Array(wordLength).fill("");
            gameState[i] = new Array(wordLength).fill("");
          }
          currentGuessIndex = 0;
          currentLetterIndex = 0;
          usedGuesses.clear();
          knownLetters = {};
          isWordComplete = false;
        }
        renderGrid();
      }
      function startCooldown(durationSeconds) {
        cooldownActive = true;
        cooldownEndTime = Date.now() + durationSeconds * 1000;

        // Re-render grid to show timer tiles
        renderGrid();

        // Update cooldown timer
        updateCooldownDisplay();
        cooldownTimer = setInterval(() => {
          updateCooldownDisplay();
          if (Date.now() >= cooldownEndTime) {
            endCooldown();
          }
        }, 1000);
      }
      async function endCooldown() {
        cooldownActive = false;
        cooldownEndTime = 0;
        if (cooldownTimer) {
          clearInterval(cooldownTimer);
          cooldownTimer = null;
        }
        // Reset word for retry now that cooldown has ended
        await resetCurrentWordForRetry();
        // Update the grid display
        renderGrid();
        updateUI();
        const currentWord = WORDS_DATA[currentWordIndex];
        const failedAttempts =
          allWordsData[currentWordIndex].failedAttempts || 0;
      }
      function updateCooldownDisplay() {
        if (!cooldownActive) return;
        const timeLeft = Math.max(
          0,
          Math.ceil((cooldownEndTime - Date.now()) / 1000)
        );
        if (timeLeft > 0) {
          const hours = Math.floor(timeLeft / 3600);
          const minutes = Math.floor((timeLeft % 3600) / 60);
          const seconds = timeLeft % 60;
          let timeDisplay = "";
          if (hours > 0) {
            timeDisplay = `${hours}h ${minutes}m ${seconds}s`;
          } else if (minutes > 0) {
            timeDisplay = `${minutes}m ${seconds}s`;
          } else {
            timeDisplay = `${seconds}s`;
          }
          // Update timer tiles during cooldown
          updateTimerDisplay();
        }
      }
      async function resetCurrentWordForRetry() {
        // Reset the current word state to allow retry after cooldown
        const currentWord = WORDS_DATA[currentWordIndex];
        const wordLength = currentWord.length;
        const maxGuesses = currentWord.guesses;

        // First, animate all filled tiles flipping and clearing
        await animateGridClear();

        // Clear current attempt data but keep failure count
        currentGuessIndex = 0;
        currentLetterIndex = 0;
        gameGrid = [];
        gameState = [];
        usedGuesses.clear();
        knownLetters = {};
        isWordComplete = false;
        isWordFailed = false;
        // Reinitialize grid
        for (let i = 0; i < maxGuesses; i++) {
          gameGrid[i] = new Array(wordLength).fill("");
          gameState[i] = new Array(wordLength).fill("");
        }
        // Update stored data (but keep failedAttempts count)
        if (allWordsData[currentWordIndex]) {
          allWordsData[currentWordIndex].gameGrid = JSON.parse(
            JSON.stringify(gameGrid)
          );
          allWordsData[currentWordIndex].gameState = JSON.parse(
            JSON.stringify(gameState)
          );
          allWordsData[currentWordIndex].usedGuesses = [];
          allWordsData[currentWordIndex].knownLetters = {};
          allWordsData[currentWordIndex].isComplete = false;
          allWordsData[currentWordIndex].isFailed = false;
          allWordsData[currentWordIndex].guessCount = 0;
          // Keep failedAttempts count for progressive tracking
        }
      }
      function calculateCooldownDuration(failedAttempts) {
        return 10 * 60; // 10 minutes
      }
      function updateTitle() {
        const titleElement = document.querySelector("h1");
        if (hasCompletedFirstWord && titleElement.textContent === "Wordle") {
          titleElement.textContent = "Wordles";
          titleElement.style.transition = "all 0.5s ease";
        }
      }
      function renderCompletedWordsStack() {
        const stackContainer = document.getElementById("completed-words-stack");
        stackContainer.innerHTML = "";
        // Render all completed words in order (including current word if it's complete)
        const endIndex = isWordComplete
          ? currentWordIndex + 1
          : currentWordIndex;
        for (let i = 0; i < endIndex; i++) {
          const wordData = allWordsData[i];
          const wordInfo = WORDS_DATA[i];
          if (wordData && wordData.isComplete) {
            const wordRow = createCompletedWordRow(i, wordData, wordInfo);
            stackContainer.appendChild(wordRow);
            // Restore collapsed state if this word is in the collapsed set
            if (collapsedWords.has(i)) {
              const container = document.getElementById(`completed-word-${i}`);
              const gridWrapper = container?.querySelector(
                ".completed-grid-wrapper"
              );
              if (container && gridWrapper) {
                gridWrapper.classList.add("drawer-collapsed");
                container.classList.add("drawer-collapsed");
                // Apply transforms to maintain collapsed appearance
                const drawerRows = gridWrapper.querySelectorAll(".drawer-row");
                const correctRow = gridWrapper.querySelector(
                  '[data-correct-row="true"]'
                );
                if (correctRow) {
                  const correctRowIndex = parseInt(correctRow.dataset.rowIndex);
                  drawerRows.forEach((row) => {
                    const rowIndex = parseInt(row.dataset.rowIndex);
                    if (rowIndex !== correctRowIndex) {
                      const isAbove = rowIndex < correctRowIndex;
                      const distance =
                        Math.abs(rowIndex - correctRowIndex) * 67;
                      if (isAbove) {
                        row.style.transform = `translateY(${distance}px)`;
                      } else {
                        row.style.transform = `translateY(-${distance}px)`;
                      }
                    }
                  });
                }
                // Reveal punctuation for already collapsed words
                revealCompletedWordPunctuation(i);
              }
            }
          }
        }
      }
      function createCompletedWordRow(wordIndex, wordData, wordInfo) {
        const wordContainer = document.createElement("div");
        wordContainer.className = "completed-word-container";
        wordContainer.id = `completed-word-${wordIndex}`;
        // Set container width to accommodate punctuation
        const hasP = wordInfo.punctuation && wordInfo.punctuation.trim() !== "";
        const containerWidth = hasP
          ? `${wordInfo.length * 67 + 67}px`
          : `${wordInfo.length * 67}px`;
        wordContainer.style.width = containerWidth;
        // Create a complete grid showing all rows (used and unused)
        const gridWrapper = document.createElement("div");
        gridWrapper.className = "completed-grid-wrapper";
        gridWrapper.style.position = "relative";
        gridWrapper.style.display = "flex";
        gridWrapper.style.flexDirection = "column";
        gridWrapper.style.alignItems = "center";
        gridWrapper.style.gap = "5px";
        gridWrapper.style.overflow = "hidden";
        gridWrapper.style.width = containerWidth;
        const correctRowIndex = wordData.guessCount - 1; // The row where the correct guess was made
        const maxGuesses = wordInfo.guesses;
        // Show all rows including empty ones
        for (let row = 0; row < maxGuesses; row++) {
          const rowWrapper = document.createElement("div");
          rowWrapper.className = "completed-word-grid drawer-row";
          rowWrapper.dataset.rowIndex = row;
          rowWrapper.dataset.correctRow = row === correctRowIndex;
          rowWrapper.style.gridTemplateColumns = `repeat(${wordInfo.length}, 62px)`;
          // Add extra width for punctuation if this is the correct row
          if (row === correctRowIndex && wordInfo.punctuation) {
            rowWrapper.style.width = `${wordInfo.length * 67 + 67}px`; // Extra space for punctuation
            rowWrapper.style.position = "relative";
          }
          rowWrapper.style.transition =
            "transform 0.4s ease, height 0.4s ease, margin 0.4s ease";
          // Mark correct row as clickable and set z-index
          if (row === correctRowIndex) {
            rowWrapper.style.cursor = "pointer";
            rowWrapper.onclick = () => toggleWordDrawer(wordIndex);
            rowWrapper.classList.add("correct-row-clickable");
            rowWrapper.style.zIndex = "10"; // Keep correct row on top
            rowWrapper.style.position = "relative";
          } else {
            rowWrapper.style.zIndex = "1"; // Other rows go underneath
            rowWrapper.style.position = "relative";
          }
          // Set initial values to ensure animations work from first click
          rowWrapper.style.height = "62px";
          rowWrapper.style.visibility = "visible";
          // Add tiles for this row
          for (let col = 0; col < wordInfo.length; col++) {
            const tile = document.createElement("div");
            tile.className = "completed-tile";
            // Get letter and state from saved data
            const letter =
              wordData.gameGrid[row] && wordData.gameGrid[row][col]
                ? wordData.gameGrid[row][col]
                : "";
            const state =
              wordData.gameState[row] && wordData.gameState[row][col]
                ? wordData.gameState[row][col]
                : "";
            tile.textContent = letter;
            // Apply color state if available
            if (state) {
              tile.classList.add(state);
            }
            rowWrapper.appendChild(tile);
          }

          // Add punctuation positioned absolutely within the row if this is the correct row
          if (row === correctRowIndex && wordInfo.punctuation) {
            const punctuationTile = document.createElement("div");
            punctuationTile.className = "punctuation-tile";
            punctuationTile.id = `completed-punctuation-${wordIndex}`;
            punctuationTile.textContent = wordInfo.punctuation;
            punctuationTile.style.position = "absolute";
            punctuationTile.style.left = `${wordInfo.length * 67 + 26}px`;
            punctuationTile.style.top = "50%";
            punctuationTile.style.transform = "translateY(-50%)";
            punctuationTile.style.width = "62px";
            punctuationTile.style.height = "62px";
            punctuationTile.style.display = "flex";
            punctuationTile.style.alignItems = "center";
            punctuationTile.style.justifyContent = "center";
            punctuationTile.style.fontSize = "2rem";
            punctuationTile.style.fontWeight = "bold";
            punctuationTile.style.color = "var(--color-text)";
            // Check if punctuation has already been revealed for this word
            const isAlreadyRevealed = revealedPunctuation.has(wordIndex);
            punctuationTile.style.opacity = isAlreadyRevealed ? "1" : "0";
            punctuationTile.style.visibility = isAlreadyRevealed
              ? "visible"
              : "hidden";
            punctuationTile.style.transition =
              "opacity 0.5s ease, visibility 0.5s ease";
            rowWrapper.appendChild(punctuationTile);
          }

          gridWrapper.appendChild(rowWrapper);
        }

        wordContainer.appendChild(gridWrapper);
        return wordContainer;
      }
      function toggleWordDrawer(wordIndex) {
        const wordContainer = document.getElementById(
          `completed-word-${wordIndex}`
        );
        if (!wordContainer) return;
        const gridWrapper = wordContainer.querySelector(
          ".completed-grid-wrapper"
        );
        const drawerRows = gridWrapper.querySelectorAll(".drawer-row");
        const correctRow = gridWrapper.querySelector(
          '[data-correct-row="true"]'
        );
        if (!correctRow) return;
        const correctRowIndex = parseInt(correctRow.dataset.rowIndex);
        const isCurrentlyCollapsed =
          gridWrapper.classList.contains("drawer-collapsed");
        if (isCurrentlyCollapsed) {
          // Expand: show all rows with sliding animation
          gridWrapper.classList.remove("drawer-collapsed");
          wordContainer.classList.remove("drawer-collapsed");
          collapsedWords.delete(wordIndex); // Remove from collapsed set
          drawerRows.forEach((row, index) => {
            const rowIndex = parseInt(row.dataset.rowIndex);
            if (rowIndex !== correctRowIndex) {
              // Animate the slide back to original position
              setTimeout(() => {
                row.style.transform = "translateY(0)";
              }, 50);
            }
          });
          // Animate adjacent wordles after expansion completes
          setTimeout(() => {
            animateAdjacentWordles();
          }, 450);
        } else {
          // Collapse: hide all rows except correct one by sliding them toward the correct row
          gridWrapper.classList.add("drawer-collapsed");
          wordContainer.classList.add("drawer-collapsed");
          collapsedWords.add(wordIndex); // Add to collapsed set
          drawerRows.forEach((row, index) => {
            const rowIndex = parseInt(row.dataset.rowIndex);
            if (rowIndex !== correctRowIndex) {
              // ALL rows slide toward the correct row position
              const isAbove = rowIndex < correctRowIndex;
              const distance = Math.abs(rowIndex - correctRowIndex) * 67; // 62px tile + 5px gap
              if (isAbove) {
                // Rows above slide DOWN toward the correct row
                row.style.transform = `translateY(${distance}px)`;
              } else {
                // Rows below slide UP toward the correct row
                row.style.transform = `translateY(-${distance}px)`;
              }
              // Animate adjacent wordles after all animations complete
              if (
                rowIndex ===
                Math.max(
                  ...Array.from(drawerRows).map((r) =>
                    parseInt(r.dataset.rowIndex)
                  )
                )
              ) {
                setTimeout(() => {
                  animateAdjacentWordles();
                  // Reveal punctuation after collapse completes
                  revealCompletedWordPunctuation(wordIndex);
                }, 450);
              }
            }
          });
        }
      }
      function animateAdjacentWordles() {
        const stackContainer = document.getElementById("completed-words-stack");
        if (!stackContainer) return;
        const completedWords = Array.from(
          stackContainer.querySelectorAll(".completed-word-container")
        );
        // Add smooth transition to all word containers for repositioning
        completedWords.forEach((wordContainer) => {
          wordContainer.style.transition = "transform 0.3s ease";
        });
        // Force layout recalculation to trigger the repositioning animation
        requestAnimationFrame(() => {
          // Trigger a reflow to make flexbox recalculate positions
          stackContainer.offsetHeight;
          // The height changes from display:none will cause natural repositioning
          // with the smooth transitions we just added
          // Clean up transitions after animation
          setTimeout(() => {
            completedWords.forEach((wordContainer) => {
              wordContainer.style.transition = "";
            });
          }, 300);
        });
      }

      function revealCompletedWordPunctuation(wordIndex) {
        // Reveal punctuation for a completed word after it has fully collapsed
        const punctuationElement = document.getElementById(
          `completed-punctuation-${wordIndex}`
        );
        if (punctuationElement) {
          setTimeout(() => {
            punctuationElement.style.opacity = "1";
            punctuationElement.style.visibility = "visible";
            punctuationElement.classList.add("revealed");
            // Mark this punctuation as permanently revealed
            revealedPunctuation.add(wordIndex);
          }, 50); // Small delay to ensure collapse animation is complete
        }
      }
      function renderCurrentWordGrid() {
        const currentWord = WORDS_DATA[currentWordIndex];
        const wordLength = currentWord.length;
        const maxGuesses = currentWord.guesses;
        const gridContainer = document.getElementById("game-grid");
        gridContainer.innerHTML = "";
        gridContainer.style.gridTemplateColumns = `repeat(${wordLength}, 62px)`;
        for (let row = 0; row < maxGuesses; row++) {
          for (let col = 0; col < wordLength; col++) {
            const tile = document.createElement("div");
            tile.className = "tile";
            tile.id = `tile-${row}-${col}`;

            const letter = gameGrid[row] ? gameGrid[row][col] : "";
            tile.textContent = letter;
            if (letter) {
              tile.classList.add("filled");
              // Apply color state if available
              const state = gameState[row] ? gameState[row][col] : "";
              if (state) {
                tile.classList.add(state);
              }
            }
            // Highlight current typing position
            if (
              row === currentGuessIndex &&
              col === currentLetterIndex &&
              !isWordComplete &&
              !isWordFailed &&
              !cooldownActive
            ) {
              tile.classList.add("current");
            }
            gridContainer.appendChild(tile);
          }
        }

        // Timer is now rendered separately outside the grid

        // Handle punctuation separately in the overlay
        renderPunctuation();
      }

      function renderTimer() {
        const timerContainer = document.getElementById("timer-container");

        if (cooldownActive) {
          // Show timer with animation
          timerContainer.classList.remove("hidden");
          timerContainer.style.animation =
            "timerFadeInSlideUp 0.5s ease forwards";
          updateTimerDisplay();
        } else {
          // Hide timer
          timerContainer.classList.add("hidden");
          timerContainer.style.animation = "";
        }
      }

      function updateTimerDisplay() {
        if (!cooldownActive) return;

        const timeLeft = Math.max(
          0,
          Math.floor((cooldownEndTime - Date.now()) / 1000)
        );

        // If timer reaches 0, start fade out animation
        if (timeLeft <= 0) {
          const timerContainer = document.getElementById("timer-container");
          timerContainer.style.animation =
            "timerFadeOutSlideDown 0.5s ease forwards";
          return;
        }

        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;

        // Update individual digits with flip animation
        updateTimerDigit("timer-m1", Math.floor(minutes / 10).toString());
        updateTimerDigit("timer-m2", (minutes % 10).toString());
        updateTimerDigit("timer-s1", Math.floor(seconds / 10).toString());
        updateTimerDigit("timer-s2", (seconds % 10).toString());
      }

      function updateTimerDigit(digitId, newDigit) {
        const digit = document.getElementById(digitId);
        if (!digit) return;

        const currentDigit = digit.textContent;
        if (currentDigit !== newDigit) {
          // Use the same flip animation as game tiles
          digit.style.willChange = "transform";
          digit.classList.add("flipping");

          // Change digit at midpoint (50% of animation)
          setTimeout(() => {
            digit.textContent = newDigit;
          }, 250); // Half of flip duration (0.5s / 2)

          // Complete animation
          setTimeout(() => {
            digit.classList.remove("flipping");
            digit.style.willChange = "auto";
          }, 500); // Full flip duration
        }
      }

      function renderPunctuation() {
        // NEVER clear overlay if there's animated punctuation visible
        const punctuationOverlay = document.getElementById(
          "punctuation-overlay"
        );
        // If punctuation has been animated for this word, NEVER touch the overlay
        if (punctuationAnimated) {
          return;
        }
        // Skip rendering punctuation in overlay if we're beyond the current word
        if (currentWordIndex >= WORDS_DATA.length) {
          return;
        }
        const currentWord = WORDS_DATA[currentWordIndex];
        // Only clear overlay if no punctuation is currently animated
        if (!punctuationAnimated) {
          punctuationOverlay.innerHTML = "";
        }
        // Don't render anything else - punctuation should only be rendered by animation
      }
      function renderGrid() {
        renderCompletedWordsStack();
        renderCurrentWordGrid();
        renderTimer();
        updateTitle();
      }
      function addLetter(letter) {
        const currentWord = WORDS_DATA[currentWordIndex];
        if (isWordComplete || isWordFailed || cooldownActive || isAnimating) {
          return;
        }
        if (currentLetterIndex < currentWord.length) {
          gameGrid[currentGuessIndex][currentLetterIndex] = letter;
          currentLetterIndex++;
          renderGrid();
        }
      }
      function deleteLetter() {
        if (isWordComplete || isWordFailed || cooldownActive || isAnimating) {
          return;
        }
        if (currentLetterIndex > 0) {
          currentLetterIndex--;
          gameGrid[currentGuessIndex][currentLetterIndex] = "";
          renderGrid();
        }
      }
      async function makeGuess() {
        const currentWord = WORDS_DATA[currentWordIndex];
        // Prevent action during animations or cooldown
        if (isAnimating || cooldownActive) {
          updateCooldownDisplay();
          return;
        }
        // Get current guess from grid
        const guess = gameGrid[currentGuessIndex].join("");
        // Basic validation
        if (guess.length !== currentWord.length) {
          showToast("Not enough letters");
          animateInvalidWord(currentGuessIndex);
          return;
        }
        if (currentGuessIndex >= currentWord.guesses) {
          return;
        }
        if (isWordComplete || isWordFailed) {
          return;
        }
        // Check for repeat guess
        if (usedGuesses.has(guess)) {
          showToast("Already guessed");
          animateInvalidWord(currentGuessIndex);
          return;
        }
        // Validate green letter constraints
        const constraintError = validateGreenConstraints(guess);
        if (constraintError) {
          showToast(constraintError);
          animateInvalidWord(currentGuessIndex);
          return;
        }
        // Validate against dictionary
        const isValidWord = await validateGuessWithFallback(guess);
        if (!isValidWord) {
          showToast("Word not in list");
          animateInvalidWord(currentGuessIndex);
          return;
        }
        // Store the guess
        usedGuesses.add(guess);
        // Check the guess and animate the results
        const results = checkWord(guess, currentGuessIndex);
        await animateFlipTiles(currentGuessIndex, results);
        currentGuessIndex++;
        currentLetterIndex = 0; // Reset for next row
        if (guess === currentWord.word) {
          // Word completed successfully
          isWordComplete = true;
          // Trigger title change animation for first word completion
          if (currentWordIndex === 0 && !hasCompletedFirstWord) {
            animateTitleChange();
          }
          // Calculate score for this word (max guesses - actual guesses + 1)
          const guessesLeft = currentWord.guesses - currentGuessIndex;
          const wordScore = Math.round(
            (currentWord.max_score * (guessesLeft + 1)) / currentWord.guesses
          );
          gameStats.totalScore += wordScore;
          // Skip all success animations - go straight to grid transition
          gameStats.wordsCompleted++;
          gameStats.totalGuesses += currentGuessIndex;
          if (currentGuessIndex === 1) gameStats.perfectWords++;
          // Skip punctuation animation - punctuation will appear after word joins stack and collapses
          // Perform the grid transition animation
          await animateGridTransition();
          // Wait a bit for animations to complete, then transition
          setTimeout(() => {
            if (currentWordIndex < WORDS_DATA.length - 1) {
              nextWord();
            } else {
              handleLastWordCompletion();
            }
          }, 500);
        } else if (currentGuessIndex >= currentWord.guesses) {
          // Word failed - exceeded guess limit, but allow retry after cooldown
          gameStats.wordsFailed++;
          // Track failed attempts for this word
          if (!allWordsData[currentWordIndex].failedAttempts) {
            allWordsData[currentWordIndex].failedAttempts = 0;
          }
          allWordsData[currentWordIndex].failedAttempts++;
          const failedAttempts = allWordsData[currentWordIndex].failedAttempts;
          const cooldownDuration = calculateCooldownDuration(failedAttempts);
          // Start cooldown - keep current grid visible
          startCooldown(cooldownDuration);
        }
        renderGrid();
        saveCurrentWordState();
        saveGameProgress();
      }
      function validateGreenConstraints(guess) {
        // Check if guess respects known correct letter positions
        for (let pos in knownLetters) {
          if (guess[pos] !== knownLetters[pos]) {
            const position = parseInt(pos) + 1; // Convert to 1-based position
            const ordinal = getOrdinal(position);
            return `${ordinal} letter must be ${knownLetters[pos]}`;
          }
        }
        return null; // No constraint violations
      }

      function getOrdinal(num) {
        const lastDigit = num % 10;
        const lastTwoDigits = num % 100;

        if (lastTwoDigits >= 11 && lastTwoDigits <= 13) {
          return num + "th";
        }

        switch (lastDigit) {
          case 1:
            return num + "st";
          case 2:
            return num + "nd";
          case 3:
            return num + "rd";
          default:
            return num + "th";
        }
      }
      async function validateGuessWithFallback(word) {
        // For testing, allow common words immediately
        const commonWords = [
          "THE",
          "AND",
          "FOR",
          "ARE",
          "BUT",
          "NOT",
          "YOU",
          "ALL",
          "CAN",
          "HER",
          "WAS",
          "ONE",
          "OUR",
          "HAD",
          "BY",
          "HOT",
          "WORD",
          "WHAT",
          "SOME",
          "WE",
          "IT",
          "DO",
          "OUT",
          "OTHER",
          "MANY",
          "TIME",
          "VERY",
          "WHEN",
          "COME",
          "HERE",
          "HOW",
          "JUST",
          "LIKE",
          "LONG",
          "MAKE",
          "MUCH",
          "OVER",
          "SUCH",
          "TAKE",
          "THAN",
          "THEM",
          "WELL",
          "WERE",
          "WILL",
          "WITH",
          "HAVE",
          "THIS",
          "THAT",
          "FROM",
          "THEY",
          "KNOW",
          "WANT",
          "BEEN",
          "GOOD",
          "SOME",
          "TIME",
          "VERY",
          "WHEN",
          "COME",
          "HERE",
          "HELLO",
          "WORLD",
          "HOUSE",
          "WATER",
          "LIGHT",
          "RIGHT",
          "MUSIC",
          "PHONE",
          "MONEY",
          "STORY",
          "HAPPY",
          "PLACE",
          "THINK",
          "GREAT",
          "WHERE",
          "EVERY",
          "STILL",
          "SMALL",
          "FOUND",
          "THOSE",
          "NEVER",
          "UNDER",
          "MIGHT",
          "WHILE",
          "SOUND",
          "BELOW",
          "SAW",
          "SOMETHING",
          "THOUGHT",
          "BOTH",
          "CAT",
          "DOG",
          "RUN",
          "JUMP",
          "TREE",
          "BOOK",
          "LOVE",
          "HELP",
          "WORK",
          "PLAY",
          "LOOK",
          "TALK",
          "WALK",
          "READ",
          "OPEN",
          "CLOSE",
          "START",
          "STOP",
          "END",
          "BEGIN",
          "NICE",
          "COOL",
          "WARM",
          "COLD",
          "TESTS",
          "WORDS",
          "GUESS",
          "GAMES",
          "LETTERS",
          "TILES",
          "VALID",
          "WRONG",
          "RIGHT",
          "CHECK",
        ];
        if (commonWords.includes(word.toUpperCase())) {
          return true;
        }
        // Try dictionary API
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 3000);
          const response = await fetch(
            `https://api.dictionaryapi.dev/api/v2/entries/en/${word.toLowerCase()}`,
            { signal: controller.signal }
          );
          clearTimeout(timeoutId);
          if (response.ok) {
            const data = await response.json();
            if (Array.isArray(data) && data.length > 0) {
              return true;
            }
          } else if (response.status === 404) {
            return false;
          }
        } catch (error) {}
        // Reject obviously invalid words
        if (word.length < 2 || !/^[A-Z]+$/.test(word)) {
          return false;
        }
        // Allow as fallback but warn
        return true;
      }
      function checkWord(guess, rowIndex) {
        const currentWord = WORDS_DATA[currentWordIndex];
        const targetWord = currentWord.word;
        const targetLetters = targetWord.split("");
        const guessLetters = guess.split("");
        // Initialize result arrays
        const result = new Array(targetWord.length);
        const targetLetterCounts = {};
        // Count letters in target word
        for (let letter of targetLetters) {
          targetLetterCounts[letter] = (targetLetterCounts[letter] || 0) + 1;
        }
        // First pass: mark correct letters (green)
        for (let i = 0; i < guessLetters.length; i++) {
          if (guessLetters[i] === targetLetters[i]) {
            result[i] = "correct";
            targetLetterCounts[guessLetters[i]]--;
            // Track known correct positions
            knownLetters[i] = guessLetters[i];
          }
        }
        // Second pass: mark present letters (yellow) and absent letters (gray)
        for (let i = 0; i < guessLetters.length; i++) {
          if (result[i] === "correct") {
            continue; // Already marked as correct
          }
          const letter = guessLetters[i];
          if (targetLetterCounts[letter] > 0) {
            result[i] = "present";
            targetLetterCounts[letter]--;
          } else {
            result[i] = "absent";
          }
        }
        // Apply styles to tiles
        for (let i = 0; i < result.length; i++) {
          const tile = document.getElementById(`tile-${rowIndex}-${i}`);
          const state = result[i];
          // Remove any existing state classes
          tile.classList.remove("correct", "present", "absent");
          // Add new state class
          tile.classList.add(state);
          // Store state for this tile
          gameState[rowIndex][i] = state;
        }
        return result;
      }
      function handleLastWordCompletion() {
        // Handle the last word completion with auto-collapse animation
        const lastWordIndex = currentWordIndex;
        // Save the current word state
        saveCurrentWordState();
        // Clear punctuation animation flag and overlay - game is ending
        punctuationAnimated = false;
        const punctuationOverlay = document.getElementById(
          "punctuation-overlay"
        );
        if (punctuationOverlay) {
          punctuationOverlay.innerHTML = "";
        }
        // Move to "post-game" state by incrementing currentWordIndex
        currentWordIndex++;
        // Hide the current word grid since there's no next word
        const currentWordContainer = document.getElementById(
          "current-word-container"
        );
        if (currentWordContainer) {
          currentWordContainer.style.display = "none";
        }
        // Render only the completed words stack
        renderCompletedWordsStack();
        updateUI();
        // Auto-collapse the last completed word with animation
        setTimeout(() => {
          const completedWordContainer = document.getElementById(
            `completed-word-${lastWordIndex}`
          );
          if (completedWordContainer) {
            const gridWrapper = completedWordContainer.querySelector(
              ".completed-grid-wrapper"
            );
            if (
              gridWrapper &&
              !gridWrapper.classList.contains("drawer-collapsed")
            ) {
              // Trigger the collapse animation
              toggleWordDrawer(lastWordIndex);

              // Reveal punctuation after collapse animation completes
              setTimeout(() => {
                revealCompletedWordPunctuation(lastWordIndex);
              }, 450); // Wait for collapse animation to finish
            }
          }
        }, 200);
        // Show game complete after collapse animation
        setTimeout(() => {
          showGameComplete();
        }, 700); // Give time for collapse animation to complete
      }
      function nextWord() {
        if (currentWordIndex < WORDS_DATA.length - 1) {
          // Save current word state before switching
          saveCurrentWordState();
          const previousWordIndex = currentWordIndex; // Store the index of the word that was just completed
          // FIRST: Clear the punctuation animation flag and overlay
          // Now that the word is saved, punctuation will be rendered in completed stack
          punctuationAnimated = false;
          const punctuationOverlay = document.getElementById(
            "punctuation-overlay"
          );
          if (punctuationOverlay) {
            punctuationOverlay.innerHTML = "";
          }
          currentWordIndex++;
          setupCurrentWord();
          updateUI();
          saveGameProgress();
          // Auto-collapse the previously completed word with animation
          setTimeout(() => {
            const completedWordContainer = document.getElementById(
              `completed-word-${previousWordIndex}`
            );
            if (completedWordContainer) {
              // Check if it's not already collapsed (it should be expanded when first rendered)
              const gridWrapper = completedWordContainer.querySelector(
                ".completed-grid-wrapper"
              );
              if (
                gridWrapper &&
                !gridWrapper.classList.contains("drawer-collapsed")
              ) {
                // Trigger the collapse animation - this will automatically add it to collapsedWords set
                toggleWordDrawer(previousWordIndex);

                // Reveal punctuation after collapse animation completes
                setTimeout(() => {
                  revealCompletedWordPunctuation(previousWordIndex);
                }, 450); // Wait for collapse animation to finish
              }
            }
          }, 200); // Small delay to ensure the completed word is rendered in the stack
          // Trigger fade-in animation for new word
          const currentWordContainer = document.getElementById(
            "current-word-container"
          );
          if (currentWordContainer) {
            currentWordContainer.classList.add("fade-in");
            // Remove animation class after it completes
            setTimeout(() => {
              currentWordContainer.classList.remove("fade-in");
            }, 500);
          }
        }
      }
      function updateUI() {}
      function showGameComplete() {
        isGameComplete = true;
        // Clear any active cooldown
        if (cooldownTimer) {
          clearInterval(cooldownTimer);
          cooldownTimer = null;
        }
        cooldownActive = false;

        // Calculate stats
        const completionRate = Math.round(
          (gameStats.wordsCompleted / WORDS_DATA.length) * 100
        );
        const avgGuesses =
          gameStats.totalGuesses / Math.max(gameStats.wordsCompleted, 1);
        const accuracy = Math.round(
          (gameStats.wordsCompleted /
            (gameStats.wordsCompleted + gameStats.wordsFailed)) *
            100
        );

        // Set completion flag in localStorage (never cleared)
        localStorage.setItem("wordle_completed", "true");

        // Start shaking the 's' and make it clickable
        startTitleShaking();

        // Show congratulations popup
        showCongratulationsPopup(completionRate, avgGuesses, accuracy);

        // Clear localStorage for this session
        localStorage.removeItem("wordleGameState");
      }

      function startTitleShaking() {
        const titleS = document.getElementById("title-s");
        if (titleS && hasCompletedFirstWord) {
          titleS.classList.add("shaking");

          // Add click event listener for navigation
          const handleNavigation = function (e) {
            e.preventDefault();
            e.stopPropagation();

            // Add a brief color change feedback
            titleS.style.color = "var(--color-correct)";
            setTimeout(() => {
              titleS.style.color = "";
              if (NEXT_PUZZLES_ENABLED) {
                window.location.href = "connect1ons.html";
              } else {
                showEarlyAccessPopup();
              }
            }, 150);
          };

          // Remove any existing listeners first
          titleS.removeEventListener("click", handleNavigation);

          // Add click event
          titleS.addEventListener("click", handleNavigation);
        }
      }

      // Local storage functions
      function saveGameProgress() {
        // Save current word state first
        saveCurrentWordState();
        const gameProgressState = {
          currentWordIndex,
          currentGuessIndex,
          gameGrid,
          gameState,
          allWordsData,
          gameStats,
          usedGuesses: Array.from(usedGuesses),
          knownLetters,
          isWordComplete,
          isWordFailed,
          isGameComplete,
          cooldownActive,
          cooldownEndTime,
          expandedWords: Array.from(expandedWords),
          collapsedWords: Array.from(collapsedWords),
          revealedPunctuation: Array.from(revealedPunctuation),
          hasCompletedFirstWord,
          timestamp: Date.now(),
        };
        localStorage.setItem(
          "wordleGameState",
          JSON.stringify(gameProgressState)
        );
      }
      function loadGameProgress() {
        const saved = localStorage.getItem("wordleGameState");
        if (saved) {
          try {
            const savedState = JSON.parse(saved);
            // Only load if from same session (within 24 hours)
            if (Date.now() - savedState.timestamp < 24 * 60 * 60 * 1000) {
              currentWordIndex = savedState.currentWordIndex || 0;
              currentGuessIndex = savedState.currentGuessIndex || 0;
              gameGrid = savedState.gameGrid || [];
              gameState = savedState.gameState || [];
              allWordsData = savedState.allWordsData || [];
              gameStats = savedState.gameStats || gameStats;
              usedGuesses = new Set(savedState.usedGuesses || []);
              knownLetters = savedState.knownLetters || {};
              isWordComplete = savedState.isWordComplete || false;
              isWordFailed = savedState.isWordFailed || false;
              isGameComplete = savedState.isGameComplete || false;
              cooldownActive = savedState.cooldownActive || false;
              cooldownEndTime = savedState.cooldownEndTime || 0;
              expandedWords = new Set(savedState.expandedWords || []);
              collapsedWords = new Set(savedState.collapsedWords || []);
              revealedPunctuation = new Set(
                savedState.revealedPunctuation || []
              );
              hasCompletedFirstWord = savedState.hasCompletedFirstWord || false;
              // Ensure allWordsData is properly initialized
              if (allWordsData.length === 0) {
                for (let i = 0; i < WORDS_DATA.length; i++) {
                  allWordsData[i] = {
                    gameGrid: [],
                    gameState: [],
                    usedGuesses: [],
                    knownLetters: {},
                    isComplete: false,
                    guessCount: 0,
                  };
                }
              }
              // Resume cooldown if it was active
              if (cooldownActive && cooldownEndTime > Date.now()) {
                // Re-render grid to show timer
                renderGrid();
                updateCooldownDisplay();
                cooldownTimer = setInterval(() => {
                  updateCooldownDisplay();
                  if (Date.now() >= cooldownEndTime) {
                    endCooldown();
                  }
                }, 1000);
              } else if (cooldownActive) {
                // Cooldown expired while game was closed - trigger end cooldown with animation
                endCooldown();
              }
            } else {
              localStorage.removeItem("wordleGameState");
            }
          } catch (error) {
            console.error("Error loading game progress:", error);
            localStorage.removeItem("wordleGameState");
          }
        }
      }
      // Global keyboard handling for direct grid input
      document.addEventListener("keydown", function (event) {
        // Don't interfere with browser shortcuts
        if (event.ctrlKey || event.metaKey || event.altKey) {
          return; // Let browser handle Ctrl+R, Cmd+W, Alt+Tab, etc.
        }
        // Only process if game is active
        if (isWordComplete || isWordFailed || cooldownActive) {
          return;
        }
        const isLetter = /^[a-zA-Z]$/.test(event.key);
        // Only prevent default for keys we actually use
        if (event.key === "Enter") {
          event.preventDefault();
          makeGuess();
        } else if (event.key === "Backspace" || event.key === "Delete") {
          event.preventDefault();
          deleteLetter();
        } else if (isLetter) {
          event.preventDefault();
          addLetter(event.key.toUpperCase());
        }
        // All other keys (F5, Ctrl+R, Cmd+W, etc.) pass through normally
      });
      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      async function animateFlipTiles(rowIndex, results) {
        if (!results || !Array.isArray(results)) {
          console.error("Invalid results passed to animateFlipTiles:", results);
          isAnimating = false;
          return;
        }
        isAnimating = true;
        const currentWord = WORDS_DATA[currentWordIndex];
        // Get the actual CSS variable values from the DOM (cached for performance)
        const rootStyles = getComputedStyle(document.documentElement);
        const flipDurationStr = rootStyles
          .getPropertyValue("--animation-flip-duration")
          .trim();
        const flipDelayStr = rootStyles
          .getPropertyValue("--animation-flip-delay")
          .trim();
        // Convert CSS time values to milliseconds
        const flipDuration =
          parseFloat(flipDurationStr) *
          (flipDurationStr.includes("ms") ? 1 : 1000);
        const flipDelay =
          parseFloat(flipDelayStr) * (flipDelayStr.includes("ms") ? 1 : 1000);
        const halfFlip = flipDuration / 2;
        // Collect tiles for batch operations
        const tilesToFlip = [];
        for (let i = 0; i < currentWord.length; i++) {
          const tile = document.getElementById(`tile-${rowIndex}-${i}`);
          if (tile) {
            tilesToFlip.push({ tile: tile, index: i, state: results[i] });
          }
        }
        // Clear any existing animation classes first (batch operation)
        tilesToFlip.forEach((tileData) => {
          const tile = tileData.tile;
          tile.classList.remove("flipping", "correct", "present", "absent");
        });
        // Wait a moment for cleanup
        await new Promise((resolve) => setTimeout(resolve, 30));
        // Start all animations with staggered delays
        const animationPromises = tilesToFlip.map((tileData) => {
          const tile = tileData.tile;
          const index = tileData.index;
          const state = tileData.state;
          return new Promise((resolve) => {
            setTimeout(() => {
              // Use requestAnimationFrame for smooth animation start
              requestAnimationFrame(() => {
                // Optimize for animation
                tile.style.willChange = "transform";
                tile.classList.add("flipping");
                // Change color at midpoint (50%)
                setTimeout(() => {
                  tile.classList.add(state);
                  gameState[rowIndex][index] = state;
                }, flipDuration / 2);
                // Remove flip class when done and clean up
                setTimeout(() => {
                  tile.classList.remove("flipping");
                  tile.style.willChange = "auto";
                  resolve();
                }, flipDuration);
              });
            }, index * flipDelay);
          });
        });
        // Wait for all animations to complete
        await Promise.all(animationPromises);
        isAnimating = false;
      }
      function animateInvalidWord(rowIndex) {
        // Check if currentWordIndex is valid
        if (
          currentWordIndex >= WORDS_DATA.length ||
          !WORDS_DATA[currentWordIndex]
        ) {
          return;
        }
        const currentWord = WORDS_DATA[currentWordIndex];
        for (let i = 0; i < currentWord.length; i++) {
          const tile = document.getElementById(`tile-${rowIndex}-${i}`);
          if (tile) tile.classList.add("shake");
        }
        setTimeout(() => {
          for (let i = 0; i < currentWord.length; i++) {
            const tile = document.getElementById(`tile-${rowIndex}-${i}`);
            if (tile) tile.classList.remove("shake");
          }
        }, 500);
      }
      function animateTitleChange() {
        if (!hasCompletedFirstWord) {
          hasCompletedFirstWord = true;
          const titleS = document.getElementById("title-s");
          if (titleS) {
            setTimeout(() => titleS.classList.add("show"), 500);
          } else {
            console.error('Element with id "title-s" not found');
          }
        }
      }
      async function animateGridTransition() {
        isAnimating = true;
        // No hiding or animation - just let the grids stack naturally
        isAnimating = false;
      }

      async function animateGridClear() {
        isAnimating = true;
        const currentWord = WORDS_DATA[currentWordIndex];
        const wordLength = currentWord.length;
        const maxGuesses = currentWord.guesses;

        // Collect all tiles that have content
        const tilesToClear = [];
        for (let row = 0; row < maxGuesses; row++) {
          for (let col = 0; col < wordLength; col++) {
            const tile = document.getElementById(`tile-${row}-${col}`);
            if (tile && tile.textContent.trim() !== "") {
              tilesToClear.push(tile);
            }
          }
        }

        if (tilesToClear.length === 0) {
          isAnimating = false;
          return;
        }

        // Get flip duration from CSS
        const rootStyles = getComputedStyle(document.documentElement);
        const flipDurationStr = rootStyles
          .getPropertyValue("--animation-flip-duration")
          .trim();
        const flipDuration =
          parseFloat(flipDurationStr) *
          (flipDurationStr.includes("ms") ? 1 : 1000);

        // Get stagger delay from CSS
        const flipDelayStr = rootStyles
          .getPropertyValue("--animation-flip-delay")
          .trim();
        const flipDelay =
          parseFloat(flipDelayStr) * (flipDelayStr.includes("ms") ? 1 : 1000);

        // Start staggered flip animations (left to right, top to bottom)
        const clearPromises = [];
        for (let row = 0; row < maxGuesses; row++) {
          for (let col = 0; col < wordLength; col++) {
            const tile = document.getElementById(`tile-${row}-${col}`);
            if (tile && tile.textContent.trim() !== "") {
              const staggerIndex = row * wordLength + col; // Calculate position for stagger
              const delay = staggerIndex * flipDelay;

              const promise = new Promise((resolve) => {
                setTimeout(() => {
                  // Optimize for animation
                  tile.style.willChange = "transform";
                  tile.classList.add("flipping");

                  // Clear content at midpoint (50% of animation)
                  setTimeout(() => {
                    tile.textContent = "";
                    tile.classList.remove(
                      "correct",
                      "present",
                      "absent",
                      "filled"
                    );
                  }, flipDuration / 2);

                  // Complete animation
                  setTimeout(() => {
                    tile.classList.remove("flipping");
                    tile.style.willChange = "auto";
                    resolve();
                  }, flipDuration);
                }, delay);
              });

              clearPromises.push(promise);
            }
          }
        }

        // Wait for all animations to complete
        await Promise.all(clearPromises);
        isAnimating = false;
      }
      // Performance monitoring and cleanup utilities
      function cleanupAnimations() {
        // Reset all willChange properties to auto for better performance
        const allTiles = document.querySelectorAll(".tile, .completed-tile");
        allTiles.forEach((tile) => {
          tile.style.willChange = "auto";
          tile.style.animation = "";
          tile.style.animationDelay = "";
        });
        // Clean up container optimizations
        const containers = document.querySelectorAll(
          ".current-word-container, .completed-words-stack"
        );
        containers.forEach((container) => {
          container.style.willChange = "auto";
        });
        // Reset animation flag
        isAnimating = false;
      }
      function cleanupAllAnimationStyles() {
        // Comprehensive cleanup of all animation-related styles
        const allTiles = document.querySelectorAll(".tile, .completed-tile");
        allTiles.forEach((tile) => {
          tile.style.willChange = "auto";
          tile.style.animation = "";
          tile.style.animationDelay = "";
          tile.style.zIndex = "";
          tile.style.transform = "";
          tile.style.opacity = "";
          tile.style.transition = "";
        });
        // Clean up containers
        const containers = document.querySelectorAll(
          ".current-word-container, .completed-words-stack, .word-attempts"
        );
        containers.forEach((container) => {
          container.style.willChange = "auto";
          container.style.transform = "";
          container.style.opacity = "";
        });
      }
      // Add cleanup after major animations
      window.addEventListener("beforeunload", cleanupAnimations);

      function showContinueGamePopup() {
        const popup = document.getElementById("continue-game-popup");
        popup.classList.remove("hidden");

        // Add event listeners
        document.getElementById("continue-game-btn").onclick = function () {
          popup.classList.add("hidden");
          loadGameProgress();
          setupCurrentWord();
          updateUI();
        };

        document.getElementById("new-game-btn").onclick = function () {
          popup.classList.add("hidden");
          localStorage.removeItem("wordleGameState");
          initGame();
        };
      }

      function showCongratulationsPopup(completionRate, avgGuesses, accuracy) {
        const popup = document.getElementById("congratulations-popup");
        const messageEl = document.getElementById("congratulations-message");
        const statsEl = document.getElementById("stats-display");
        const starRatingEl = document.getElementById("star-rating");
        const ratingTextEl = document.getElementById("rating-text");

        // Calculate star rating based on score percentage
        const scorePercentage =
          (gameStats.totalScore / gameStats.maxPossibleScore) * 100;
        let stars = 0;
        let ratingText = "";

        if (scorePercentage >= 85) {
          stars = 3;
          ratingText = "Exceptional Performance!";
        } else if (scorePercentage >= 65) {
          stars = 2;
          ratingText = "Great Performance!";
        } else if (scorePercentage >= 40) {
          stars = 1;
          ratingText = "Good Effort!";
        } else {
          stars = 0;
          ratingText = "Keep Practicing!";
        }

        // Update star display
        const starElements = starRatingEl.querySelectorAll(".star");
        starElements.forEach((star, index) => {
          if (index < stars) {
            star.classList.add("filled");
          } else {
            star.classList.remove("filled");
          }
        });

        ratingTextEl.textContent = ratingText;

        // Create congratulations message based on performance
        let message = "";
        if (accuracy === 100) {
          if (gameStats.perfectWords === WORDS_DATA.length) {
            message = "Perfect game! You solved every word on the first try!";
          } else if (avgGuesses <= 2) {
            message = "Holy shit! You got so many of them right! Suspicous...";
          } else {
            message = "You got 'em all! Amaaazing!";
          }
        } else if (accuracy >= 80) {
          message = "Great job! You're a rising wordle-er!";
        } else if (accuracy >= 60) {
          message = "Nicee! You solved the words! (Most of them)";
        } else {
          message = "Maybe you would like to play again!";
        }

        // Create stats display
        const statsHTML = `
          <strong>Game Statistics</strong>
          <div class="stats-grid">
            <div class="stats-label">Words Completed:</div>
            <div class="stats-value">${gameStats.wordsCompleted}/${
          WORDS_DATA.length
        }</div>
            <div class="stats-label">Accuracy:</div>
            <div class="stats-value">${accuracy}%</div>
            <div class="stats-label">Average Guesses:</div>
            <div class="stats-value">${avgGuesses.toFixed(1)}</div>
            <div class="stats-label">Score:</div>
            <div class="stats-value">${gameStats.totalScore}/${
          gameStats.maxPossibleScore
        }</div>
            <div class="stats-label">Perfect Words:</div>
            <div class="stats-value">${gameStats.perfectWords}</div>
          </div>
        `;

        messageEl.innerHTML = message;
        statsEl.innerHTML = statsHTML;

        popup.classList.remove("hidden");

        // Add event listener for play again
        document.getElementById("play-again-btn").onclick = function () {
          popup.classList.add("hidden");
          location.reload(); // Refresh page to start new game
        };

        // Add event listener for close button
        document.getElementById("close-popup-btn").onclick = function () {
          popup.classList.add("hidden");
        };

        // Allow closing popup by clicking outside
        popup.onclick = function (e) {
          if (e.target === popup) {
            popup.classList.add("hidden");
          }
        };
      }

      function showToast(message) {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        toast.classList.add("show");

        // Hide toast after 2 seconds
        setTimeout(() => {
          toast.classList.remove("show");
        }, 2000);
      }
      
      // Show early access popup
      function showEarlyAccessPopup() {
        const popup = document.getElementById('early-access-popup');
        popup.classList.add('show');
      }
      
      // Close early access popup
      function closeEarlyAccessPopup() {
        const popup = document.getElementById('early-access-popup');
        popup.classList.remove('show');
      }
    </script>
    
    <!-- Early Access Popup -->
    <div class="early-access-popup" id="early-access-popup">
      <div class="early-access-content">
        <div class="early-access-title">Word Master!</div>
        <div class="early-access-message">
          Incredible! You've conquered every word puzzle!<br><br>
          You've reached the edge of what exists for now.<br><br>
          <em style="color: #999;">The dictionary is still being written...</em>
        </div>
        <button class="early-access-close" onclick="closeEarlyAccessPopup()">Roger that</button>
      </div>
    </div>
  </body>
</html>
