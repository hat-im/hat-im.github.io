<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eventually This Will Become Shakespeare</title>
    <style>
        @font-face {
            font-family: 'Next Mono';
            src: url('https://raw.githubusercontent.com/hat-im/hat-im.github.io/main/mono.woff') format('woff');
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #fefefe;
            font-family: 'Next Mono', monospace;
            font-size: 14px;
            line-height: 1.2;
            color: #333;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        .text-container {
            width: 100vw;
            height: 100vh;
            white-space: pre;
            font-weight: 400;
            letter-spacing: 0;
            padding: 0;
            margin: 0;
        }

        .fixed-text {
            color: #222;
        }

        .random-text {
            color: #666;
        }
    </style>
</head>
<body>
    <div class="text-container" id="textContainer"></div>

    <script>
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ ';
        const fixedText = 'EVENTUALLY THIS WILL BECOME SHAKESPEARE';
        
        let textGrid = [];
        let cols, rows;
        let lastUpdateTime = 0;
        
        // Nuclear decay parameters
        const DECAY_CONSTANT = 0.0008; // probability per millisecond per character
        const MIN_INTERVAL = 50; // minimum ms between any changes
        
        function calculateGrid() {
            // Measure character dimensions
            const testEl = document.createElement('div');
            testEl.style.cssText = `
                font-family: 'Next Mono', monospace;
                font-size: 14px;
                line-height: 1.2;
                position: absolute;
                visibility: hidden;
                white-space: pre;
            `;
            testEl.textContent = 'M'.repeat(100);
            document.body.appendChild(testEl);
            
            const charWidth = testEl.offsetWidth / 100;
            
            testEl.textContent = 'M\nM';
            const charHeight = testEl.offsetHeight / 2;
            
            document.body.removeChild(testEl);
            
            cols = Math.floor(window.innerWidth / charWidth);
            rows = Math.floor(window.innerHeight / charHeight) + 3; // Add 3 extra lines
            
            return { cols, rows };
        }

        function initializeGrid() {
            const { cols: newCols, rows: newRows } = calculateGrid();
            cols = newCols;
            rows = newRows;
            
            textGrid = [];
            const totalChars = cols * rows;
            
            // Calculate center position for the fixed text
            const centerRow = Math.floor(rows / 2);
            const textMiddle = Math.floor(fixedText.length / 2);
            const screenMiddle = Math.floor(cols / 2);
            const centerCol = screenMiddle - textMiddle;
            const startIndex = centerRow * cols + centerCol;
            
            // Fill entire grid with random characters first
            for (let i = 0; i < totalChars; i++) {
                textGrid.push({
                    char: chars[Math.floor(Math.random() * chars.length)],
                    fixed: false,
                    lastDecay: 0
                });
            }
            
            // Then place the fixed text in the center
            for (let i = 0; i < fixedText.length; i++) {
                const gridIndex = startIndex + i;
                if (gridIndex < totalChars) {
                    const char = fixedText[i];
                    // Only letters are truly fixed, spaces can decay
                    const isFixed = char !== ' ';
                    textGrid[gridIndex] = {
                        char: char,
                        fixed: isFixed,
                        lastDecay: 0
                    };
                }
            }
            
            renderGrid();
        }

        function renderGrid() {
            const container = document.getElementById('textContainer');
            let output = '';
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const index = row * cols + col;
                    if (index < textGrid.length) {
                        output += textGrid[index].char;
                    }
                }
                if (row < rows - 1) {
                    output += '\n';
                }
            }
            
            container.textContent = output;
        }

        function nuclearDecay(currentTime) {
            // Only proceed if minimum interval has passed
            if (currentTime - lastUpdateTime < MIN_INTERVAL) {
                return;
            }
            
            const deltaTime = currentTime - lastUpdateTime;
            let hasChanges = false;
            
            // Check each non-fixed character for decay
            textGrid.forEach((cell, index) => {
                if (!cell.fixed) {
                    // Calculate probability of decay since last update
                    const decayProbability = 1 - Math.exp(-DECAY_CONSTANT * deltaTime);
                    
                    if (Math.random() < decayProbability) {
                        // Character decays (changes)
                        cell.char = chars[Math.floor(Math.random() * chars.length)];
                        cell.lastDecay = currentTime;
                        hasChanges = true;
                    }
                }
            });
            
            if (hasChanges) {
                renderGrid();
                lastUpdateTime = currentTime;
            }
        }

        function animate(currentTime) {
            nuclearDecay(currentTime);
            requestAnimationFrame(animate);
        }

        function init() {
            initializeGrid();
            lastUpdateTime = performance.now();
            requestAnimationFrame(animate);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            setTimeout(init, 100);
        });

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>