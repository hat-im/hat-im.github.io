<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Eventually This Will Become Shakespeare</title>
    <style>
      @font-face {
        font-family: "Next Mono";
        src: url("https://raw.githubusercontent.com/hat-im/hat-im.github.io/main/mono.woff")
          format("woff");
      }
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #fefefe;
        width: 100vw;
        height: 100vh;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      const text = "EVENTUALLY THIS WILL BECOME SHAKESPEARE";
      const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
      const fontSize = 10;
      const lineHeight = 1.2;
      const fontFamily = "Next Mono";
      const delay = 50;
      const baseDecay = 0.0012;

      let canvas = document.getElementById("canvas");
      let ctx = canvas.getContext("2d");

      let cols,
        rows,
        grid = [],
        startTime = 0,
        lastFrame = 0;
      let charWidth, charHeight;
      let mouseX = -1000,
        mouseY = -1000;

      window.addEventListener("mousemove", (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      function measureFontMetrics() {
        ctx.font = `${fontSize}px ${fontFamily}`;
        const metrics = ctx.measureText("M");
        charWidth = metrics.width;
        charHeight = fontSize * lineHeight;
      }
      function resize() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + "px";
        canvas.style.height = window.innerHeight + "px";
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset any previous transform
        ctx.scale(dpr, dpr); // Scale drawing for crispness

        measureFontMetrics();
        cols = Math.ceil(window.innerWidth / charWidth);
        rows = Math.ceil(window.innerHeight / charHeight);

        grid = [];
        let total = cols * rows;

        for (let i = 0; i < total; i++) {
          let o = text[i] || " ";
          let isFinal = o !== " ";
          grid.push({ x: " ", y: isFinal, z: 0, o });
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#333";
        ctx.font = `${fontSize}px ${fontFamily}`;
        ctx.textBaseline = "top";

        const topPadding = 1; // in pixels
        for (let i = 0; i < grid.length; i++) {
          let col = i % cols;
          let row = Math.floor(i / cols);
          let ch = grid[i].x;
          let x = col * charWidth;
          let y = row * charHeight + topPadding;
          ctx.fillText(ch, x, y);
        }
      }

      function update(t) {
        if (!startTime) startTime = t;
        if (t - lastFrame < delay) return;

        let elapsed = t - startTime;
        let T = elapsed / 2000;
        let progress = Math.max(0, (elapsed - 2000) / 20000);
        let decayRate = Math.pow(Math.min(progress, 1), 10) * baseDecay;
        let changed = false;

        if (T < 1) {
          let count = Math.floor(T * text.length) + 1;
          for (let i = 0; i < count && i < grid.length; i++) {
            let g = grid[i];
            if (g.o && g.x !== g.o) {
              g.x = g.o;
              changed = true;
            }
          }
        } else {
          grid.forEach((g, i) => {
            if (g.y) return;

            let col = i % cols;
            let row = Math.floor(i / cols);
            let cx = col * charWidth + charWidth / 2;
            let cy = row * charHeight + charHeight / 2;
            let dx = cx - mouseX;
            let dy = cy - mouseY;
            let dist = Math.sqrt(dx * dx + dy * dy);
            let boost = Math.exp(-dist * 0.02);
            let decay = decayRate * (1 + 35 * boost);
            let chance = 1 - Math.exp(-decay * (t - lastFrame));

            if (g.x === " ") {
              if (Math.random() < chance) {
                g.x = alphabet[Math.floor(Math.random() * alphabet.length)];
                g.z = t;
                changed = true;
              }
            } else {
              let reduceChance = 1 - Math.exp(-decay * (t - lastFrame) * 0.3);
              if (Math.random() < reduceChance) {
                g.x = alphabet[Math.floor(Math.random() * alphabet.length)];
                g.z = t;
                changed = true;
              }
            }
          });
        }

        if (changed) {
          draw();
          lastFrame = t;
        }
      }

      function loop(t) {
        update(t);
        requestAnimationFrame(loop);
      }

      window.addEventListener("resize", () => {
        resize();
        draw();
      });

      window.addEventListener("load", () => {
        resize();
        draw();
        lastFrame = performance.now();
        requestAnimationFrame(loop);
      });
    </script>
  </body>
</html>
